var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [MoM_Kernels]","category":"page"},{"location":"api/#MoM_Kernels.GeosInterval","page":"API","title":"MoM_Kernels.GeosInterval","text":"保存网格数据区间的实例。\n\n\n\n\n\n","category":"constant"},{"location":"api/#MoM_Kernels.MLFMAParams","page":"API","title":"MoM_Kernels.MLFMAParams","text":"多层快速多极子的可调参数\n\n\n\n\n\n","category":"constant"},{"location":"api/#MoM_Kernels.ParallelParams","page":"API","title":"MoM_Kernels.ParallelParams","text":"保存并行参数的实例。\n\n\n\n\n\n","category":"constant"},{"location":"api/#MoM_Kernels.SSCg","page":"API","title":"MoM_Kernels.SSCg","text":"计算面奇异性时用的两个系数。\n\n\n\n\n\n","category":"constant"},{"location":"api/#MoM_Kernels.SSCgdivnp2","page":"API","title":"MoM_Kernels.SSCgdivnp2","text":"计算体奇异性时用到的一些系数。\n\n\n\n\n\n","category":"constant"},{"location":"api/#MoM_Kernels.VSC₃ⁿ","page":"API","title":"MoM_Kernels.VSC₃ⁿ","text":"这一项面、体奇异性都用到了，处理对格林函数梯度求积时的奇异性时用到的。\n\n\n\n\n\n","category":"constant"},{"location":"api/#MoM_Kernels.ZnearT","page":"API","title":"MoM_Kernels.ZnearT","text":"近场阻抗矩阵的类型集合。\n\n\n\n\n\n","category":"type"},{"location":"api/#MoM_Kernels.CubeInfo","page":"API","title":"MoM_Kernels.CubeInfo","text":"CubeInfo{IT<:Integer, FT<:Real}\n\n盒子信息，包括：\n\nkidsInterval    ::UnitRange{IT}     子层盒子id的区间\nbfInterval      ::UnitRange{IT}     包含的基函数区间\nkidsIn8         ::Vector{IT}        非空子盒子在8个子盒子中的id\ngeoIDs          ::Vector{IT}        包含的网格如三角形、四面体的id，以基函数进行分，因此边界上的同一个网格可能被分到不同的盒子内。\nneighbors       ::Vector{IT}        邻盒子id\nfarneighbors    ::Vector{IT}        远亲盒子的id\nID3D            ::MVec3D{IT}        本盒子在本层的三维整数坐标\ncenter          ::MVec3D{FT}        本盒子在本层的三维全局坐标\n\n\n\n\n\n","category":"type"},{"location":"api/#MoM_Kernels.GLPolesInfo","page":"API","title":"MoM_Kernels.GLPolesInfo","text":"多极子的极信息，即角谱空间采样信息 Xθs::Vector{FT}，θ方向的采样点坐标（rad单位），高斯-勒让德求积 Xϕs::Vector{FT}，ϕ方向的采样点坐标（rad单位），均值求积 Wθϕs::Vector{FT}，采样点权重，用于积分时使用，在MLFMA中直接乘在转移项\n\n\n\n\n\n","category":"type"},{"location":"api/#MoM_Kernels.GeosIntervalType","page":"API","title":"MoM_Kernels.GeosIntervalType","text":"GeosIntervalType{T}\n\n保存网格数据区间的类。\n\n\n\n\n\n","category":"type"},{"location":"api/#MoM_Kernels.LagrangeInterp1StepInfo","page":"API","title":"MoM_Kernels.LagrangeInterp1StepInfo","text":"保存总的 稀疏插值矩阵，用于单步插值，根据稀疏度决定保存稀疏阵或是稠密阵 θϕCSC       ::AbstractMatrix{FT} 稀疏矩阵, θ 方向插值矩阵的转置，用于左乘本层多极子矩阵，在 θ 方向反插值 θϕCSCT      ::AbstractMatrix{FT} 稀疏矩阵, ϕ 方向插值矩阵的转置，用于左乘本层多极子矩阵，在 ϕ 方向反插值\n\n\n\n\n\n","category":"type"},{"location":"api/#MoM_Kernels.LagrangeInterp1StepInfo-Union{Tuple{IT}, Tuple{FT}, Tuple{SparseArrays.SparseMatrixCSC{FT, IT}, SparseArrays.SparseMatrixCSC{FT, IT}}} where {FT<:Real, IT}","page":"API","title":"MoM_Kernels.LagrangeInterp1StepInfo","text":"带参数的构造函数\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.LagrangeInterpInfo","page":"API","title":"MoM_Kernels.LagrangeInterpInfo","text":"保存 θ, ϕ 两个方向的稀疏插值矩阵， θ方向为 (npXθs, ntXθs) 稀疏矩阵, 用于左乘本层多极子矩阵，在 θ 方向插值 ϕ方向为 (ntXϕs, ntXϕs) 稀疏矩阵, 用于右乘本层多极子矩阵，在 ϕ 方向插值 θCSCT   ::SparseMatrixCSC{FT} 稀疏矩阵, θ 方向插值矩阵的转置，用于左乘本层多极子矩阵，在 θ 方向反插值 ϕCSCT   ::SparseMatrixCSC{FT} 稀疏矩阵, ϕ 方向插值矩阵的转置，用于左乘本层多极子矩阵，在 ϕ 方向反插值\n\n\n\n\n\n","category":"type"},{"location":"api/#MoM_Kernels.LagrangeInterpInfo-Union{Tuple{IT}, Tuple{FT}, Tuple{SparseArrays.SparseMatrixCSC{FT, IT}, SparseArrays.SparseMatrixCSC{FT, IT}}} where {FT<:Real, IT}","page":"API","title":"MoM_Kernels.LagrangeInterpInfo","text":"带参数的构造函数\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.LevelInfo","page":"API","title":"MoM_Kernels.LevelInfo","text":"LevelInfo{IT<:Integer, FT<:Real, IPT} <: AbstractLevel\n\n层信息：\n\nID          ::IT                        层序号\nisleaf      ::Bool                      是否为叶层\nL           ::IT                        本层截断项数\ncubes       ::Vector{CubeInfo{IT, FT}}  包含每一个盒子信息的向量\ncubeEdgel   ::FT                        本层盒子的边长\npoles       ::PolesInfo{IT, FT}         多极子采样信息\ninterpWθϕ   ::InterpInfo{IT, FT}        插值信息\naggS        ::Array{Complex{FT}, 3}     聚合项\ndisaggG     ::Array{Complex{FT}, 3}     解聚项\nphaseShift2Kids  ::Array{Complex{FT}, 3}本层盒子到子层盒子的相移因子 \nαTrans      ::Array{Complex{FT}, 3}     本层盒子远亲组之间的转移因子，根据相对位置共有 7^3 - 3^3 = 316 个\nαTransIndex ::Array{IT, 2}              远亲盒子的相对位置到其转移因子在所有转移因子数组的索引\n\n\n\n\n\n","category":"type"},{"location":"api/#MoM_Kernels.MLFMAIterator","page":"API","title":"MoM_Kernels.MLFMAIterator","text":"保存 MLFMA 相关信息的结构体\n\n\n\n\n\n","category":"type"},{"location":"api/#MoM_Kernels.MLFMAIterator-Union{Tuple{LT}, Tuple{FT}, Tuple{Any, MoM_Kernels.OctreeInfo{FT, LT}, Vector, Vector}} where {FT<:Real, LT<:MoM_Kernels.LevelInfo}","page":"API","title":"MoM_Kernels.MLFMAIterator","text":"实现矩阵向量乘积，并封装为线性算子\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.MLFMAParamsType","page":"API","title":"MoM_Kernels.MLFMAParamsType","text":"创建可变参数类型以在频率更改时对应更改 MLFMA 的相关参数\n\n\n\n\n\n","category":"type"},{"location":"api/#MoM_Kernels.MatrixChunk","page":"API","title":"MoM_Kernels.MatrixChunk","text":"MatrixChunk{T<:Number} <:AbstractMatrix{T}\n\n创建近场矩阵块结构体，所包含的数据为某一盒子内的近场矩阵元。\n\nm::Int                          行数\nn::Int                          列数\nmat::Matrix{T}                  矩阵\nrowIndices::AbstractVector{Int} 行索引\ncolIndices::AbstractVector{Int} 列索引\nlmul::AbstractVector{T}         用于左乘其它矩阵、向量的临时数组，大小与列数相同\nrmul::AbstractVector{T}         用于右乘其它矩阵、向量的临时数组，大小与行数相同\n\n\n\n\n\n","category":"type"},{"location":"api/#MoM_Kernels.MatrixChunk-Union{Tuple{T}, Tuple{Any, Any}} where T<:Number","page":"API","title":"MoM_Kernels.MatrixChunk","text":"MatrixChunk{T}(rowIndices, colIndices) where {T<:Number}\n\n用行、列索引 rowIndices, colIndices 初始化矩阵块。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.OctreeInfo","page":"API","title":"MoM_Kernels.OctreeInfo","text":"八叉树类 nLevels ::Integer, 叶层ID（定义大盒子为（“0” 层），叶层为第“n”层，nLevels取“n”的值） leafCubeEdgel::FT，叶层盒子边长 bigCubeLowerCoor::MVec3D{FT}，第0层盒子的角坐标 levels  ::Dict{Int, LevelInfo}，保存各层信息的字典\n\n\n\n\n\n","category":"type"},{"location":"api/#MoM_Kernels.OctreeInfo-Union{Tuple{LT}, Tuple{FT}, Tuple{Matrix{FT}, FT}} where {FT<:Real, LT<:MoM_Kernels.AbstractLevel}","page":"API","title":"MoM_Kernels.OctreeInfo","text":"构建八叉树类\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.PartitionedVector","page":"API","title":"MoM_Kernels.PartitionedVector","text":"PartitionedVector{T} <: AbstractVector{T}\n\n用于保存向量块的类，同时在块内保存一些其他块的数据。\n\nsize::Int                           原始 Vector 的大小\ndata::OffsetVector{T, Vector{T}}    本地保存的数据\nindices::UnitRange{Int}             本地保存数据的索引区间\nghostdata::SparseVector{T, Int}     用到的其它数据\nghostindices::Vector{Int}           用到的其它数据的索引区间\n\n\n\n\n\n","category":"type"},{"location":"api/#MoM_Kernels.SAIChunkPrec","page":"API","title":"MoM_Kernels.SAIChunkPrec","text":"SAIChunkPrec{T} <: AbstractMatrix{T}\n\n分块系数近似逆的结构体。\n\n\n\n\n\n","category":"type"},{"location":"api/#MoM_Kernels.SAIPrec","page":"API","title":"MoM_Kernels.SAIPrec","text":"SAIPrec{T} <: AbstractMatrix{T}\n\n封装系数近似逆矩阵的类型。\n\n\n\n\n\n","category":"type"},{"location":"api/#MoM_Kernels.ZnearChunksStruct","page":"API","title":"MoM_Kernels.ZnearChunksStruct","text":"创建近场矩阵结构体，所包含的数据为所有盒子内的近场矩阵元，多线程版本\n\nm::Int                  行数\nn::Int                  列数\nnChunks::Int            矩阵块儿数\nchunks::Vector{ZnearChunksStruct{T}}    矩阵\nlmul::Vector{T}         用于左乘其它矩阵、向量的临时数组，大小与列数相同\nlmuld::Vector{T}        用于左乘其它矩阵、向量的临时分布式数组，大小与列数相同，默认不分配\nrmul::Vector{T}         用于右乘其它矩阵、向量的临时数组，大小与行数相同\nlmuld::Vector{T}        用于左乘其它矩阵、向量的临时分布式数组，大小与列数相同，默认不分配\n\n\n\n\n\n","category":"type"},{"location":"api/#MoM_Kernels.ZnearChunksStruct-Union{Tuple{Any}, Tuple{T}} where T<:Number","page":"API","title":"MoM_Kernels.ZnearChunksStruct","text":"ZnearChunksStruct{T}(chunks; m, n) where {T<:Number}\n\nZnearChunksStruct 类的初始化函数。\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:*-Union{Tuple{T}, Tuple{AbstractMatrix, T}} where T<:MoM_Kernels.MatrixChunk","page":"API","title":"Base.:*","text":"*(mat::AbstractMatrix, Z::T) where{T<:MatrixChunk}\n\n实现右乘其它矩阵，默认矩阵块较小，不在本阶段并行。\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:*-Union{Tuple{T}, Tuple{AbstractVector, T}} where T<:MoM_Kernels.MatrixChunk","page":"API","title":"Base.:*","text":"*(x::AbstractVector, Z::T) where{T<:MatrixChunk}\n\n实现矩阵块 Z 右乘其它向量，默认矩阵块较小，不在本阶段并行。\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:*-Union{Tuple{T}, Tuple{MoM_Kernels.ZNEARCHUNK{T}, AbstractMatrix}} where T<:Number","page":"API","title":"Base.:*","text":"Base.:*(Z::ZNEARCHUNK{T}, mat::AbstractMatrix) where{T<:Number}\n\n实现左乘其它矩阵\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:*-Union{Tuple{T}, Tuple{T, AbstractMatrix}} where T<:MoM_Kernels.MatrixChunk","page":"API","title":"Base.:*","text":"*(Z::T, mat::AbstractMatrix) where{T<:MatrixChunk}\n\n实现矩阵块 Z 左乘其它矩阵，默认矩阵块较小，不在本阶段并行。\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:*-Union{Tuple{T}, Tuple{T, AbstractVector}} where T<:MoM_Kernels.MatrixChunk","page":"API","title":"Base.:*","text":"Base.:*(Z::T, x::AbstractVector) where{T<:MatrixChunk}\n\n实现左乘其它向量，默认矩阵块较小，因此不在本阶段并行\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:*-Union{Tuple{T}, Tuple{T, AbstractVector}} where T<:MoM_Kernels.ZnearChunksStruct","page":"API","title":"Base.:*","text":"Base.:*(Z::T, x::AbstractVector) where{T<:ZnearChunksStruct}\n\n实现左乘其它向量\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.convert-Union{Tuple{LTo}, Tuple{LTt}, Tuple{FT}, Tuple{Type{MoM_Kernels.OctreeInfo{FT, LTt}}, MoM_Kernels.OctreeInfo{FT, LTo}}} where {FT<:Real, LTt<:MoM_Kernels.AbstractLevel, LTo<:MoM_Kernels.AbstractLevel}","page":"API","title":"Base.convert","text":"实现包含分布式层的\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.eltype-Tuple{IncompleteLU.ILUFactorization}","page":"API","title":"Base.eltype","text":"eltype(opt::ILUFactorization)\n\n提供 ilu 的算子 eltype 函数。\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Union{Tuple{I}, Tuple{PartitionedVector, I}} where I<:Integer","page":"API","title":"Base.getindex","text":"Base.getindex(A::PartitionedVector, i::I) where {I<:Integer}\n\n重载 PartitionedVector 类型的 getindex 函数。\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T<:MoM_Kernels.MatrixChunk","page":"API","title":"Base.getindex","text":"getindex(Z::T, i1::Int, i2::Int) where{T<:MatrixChunk}\n\n重载 getindex 函数。\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T<:MoM_Kernels.ZNEARCHUNK","page":"API","title":"Base.getindex","text":"重载 getindex 函数\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Union{Tuple{T}, Tuple{T, Any, Int64, Int64}} where T<:MoM_Kernels.MatrixChunk","page":"API","title":"Base.setindex!","text":"setindex!(Z::T, x, i1::Int, i2::Int) where{T<:MatrixChunk}\n\n重载 setindex! 函数\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Union{Tuple{T}, Tuple{T, Any, Int64, Int64}} where T<:MoM_Kernels.ZNEARCHUNK","page":"API","title":"Base.setindex!","text":"setindex!(Z::T, x, i1::Int, i2::Int) where{T<:ZNEARCHUNK}\n\n重载 setindex! 函数\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.size-Tuple{T} where T<:IncompleteLU.ILUFactorization","page":"API","title":"Base.size","text":"size(operator::T) where {T<:ILUFactorization}\n\n提供 ilu 的算子 size 函数。\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.ldiv!-Union{Tuple{T}, Tuple{SAIChunkPrec{T}, AbstractVector}} where T","page":"API","title":"LinearAlgebra.ldiv!","text":"ldiv!(M::SAIChunkPrec{T}, x::AbstractVector) where {T}\nldiv!(y::AbstractVector, M::SAIChunkPrec{T}, x::AbstractVector) where {T}\n\n实现 x .= M * x 或 y .= M * x。\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.ldiv!-Union{Tuple{T}, Tuple{SAIPrec{T}, AbstractVector}} where T","page":"API","title":"LinearAlgebra.ldiv!","text":"ldiv!(M::SAIPrec{T}, x::AbstractVector) where {T}\nldiv!(y::AbstractVector, M::SAIPrec{T}, x::AbstractVector) where {T}\n\n实现 x .= M * x 或 y .= M * x。\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.mul!-Tuple{AbstractVector, MLFMAIterator, AbstractVector, Number, Number}","page":"API","title":"LinearAlgebra.mul!","text":"LinearAlgebra.mul!(y, Zopt::MLFMAIterator, x)\n\n重载以实现矩阵向量乘积计算\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.mul!-Tuple{Any, MLFMAIterator, Any}","page":"API","title":"LinearAlgebra.mul!","text":"LinearAlgebra.mul!(y, Zopt::MLFMAIterator, x)\n\n重载以实现矩阵向量乘积计算\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.mul!-Union{Tuple{T}, Tuple{Any, T, AbstractVector}} where T<:MoM_Kernels.MatrixChunk","page":"API","title":"LinearAlgebra.mul!","text":"mul!(y, Z::T, x::AbstractVector) where{T<:MatrixChunk}\n\n实现矩阵块 Z 的矩阵向量乘积计算。\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.mul!-Union{Tuple{V}, Tuple{T}, Tuple{AbstractVector, LinearAlgebra.Adjoint{T, MLFMAIterator{T, V}}, AbstractVector, Number, Number}} where {T, V}","page":"API","title":"LinearAlgebra.mul!","text":"LinearAlgebra.mul!(y, Zopt::MLFMAIterator, x)\n\n重载以实现矩阵向量乘积计算\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.mul!-Union{Tuple{V}, Tuple{T}, Tuple{Any, LinearAlgebra.Adjoint{T, MLFMAIterator{T, V}}, Any}} where {T, V}","page":"API","title":"LinearAlgebra.mul!","text":"LinearAlgebra.mul!(y, Zopt::MLFMAIterator, x)\n\n重载以实现矩阵向量乘积计算\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.CFIEOnNearTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:AbstractFloat}","page":"API","title":"MoM_Kernels.CFIEOnNearTris","text":"计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形不重合但相隔较近的情况，因此输入有两个个三角形信息类型实例 输入 trit， tris     :   TriangleInfo, 场三角形和源三角形\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.CFIEOnTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:AbstractFloat}","page":"API","title":"MoM_Kernels.CFIEOnTris","text":"计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形不重合且相隔较远的情况，因此输入有两个个三角形信息类型实例 输入 trit， tris     :   TriangleInfo, 场三角形和源三角形\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.CFIEOnTris-Union{Tuple{TriangleInfo{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT<:Integer, FT<:AbstractFloat}","page":"API","title":"MoM_Kernels.CFIEOnTris","text":"计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形重合的情况，因此输入只有一个三角形信息类型实例 输入 tri     :   TriangleInfo\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnHexaPWC-Union{Tuple{HexahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.EFIEOnHexaPWC","text":"采用 PWC 基函数 计算六面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体重合的情况，因此输入有一个六面体信息类型实例 输入： hexat   HexahedraInfo, 场六面体和六面体 计算： jkη₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 其中， ∫ₜ∫ₛ∇∇G(R)dV′dV = ∫ₜ∑ᵢn̂ᵢ(∫ᵢR̂(jk + 1/R)G(R)dS′)dV 计算得到结果为并矢:: jη₀/k ∫∫ (k²I + ∇∇)G(R) dV'dV Kᵣⁿ  =   ∫ Rⁿ dV' K̂ᵣⁿ  =   ∫ R̂Rⁿ dV' 注意为与两两作用不同，此处加上了 κ 项，因此后续填充时不需加上。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnHexaPWCSepPV-Union{Tuple{HexahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.EFIEOnHexaPWCSepPV","text":"采用 PWC 基函数 计算六面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体重合的情况，因此输入有一个六面体信息类型实例 输入： hexat   HexahedraInfo, 场六面体和六面体 计算： jkη₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 其中， ∫ₜ∫ₛ∇∇G(R)dV′dV = ∫ₜ∑ᵢn̂ᵢ(∫ᵢR̂(jk + 1/R)G(R)dS′)dV 计算得到结果为并矢:: jη₀/k ∫∫ (k²I + ∇∇)G(R) dV'dV Kᵣⁿ  =   ∫ Rⁿ dV' K̂ᵣⁿ  =   ∫ R̂Rⁿ dV' 注意为与两两作用不同，此处加上了 κ 项，因此后续填充时不需加上。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnHexaRBF-Union{Tuple{HexahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.EFIEOnHexaRBF","text":"计算六面体上相关的 36 个阻抗矩阵元， 此函数方法用于计算场源六面体重合的情况，因此输入有一个六面体信息类型实例 输入 hexat     :   HexahedraInfo, 场六面体和源六面体\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.EFIEOnHexaTetraPWC","text":"采用 PWC 基函数 计算六面体和四面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况，因此输入有两个六面体信息类型实例 输入： hexat::HexahedraInfo,   场六面体 tetras::TetrahedraInfo  源四面体 计算： jk₀η₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.EFIEOnHexaTetraPWC","text":"采用 PWC 基函数 计算六面体和四面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况，因此输入有两个六面体信息类型实例 输入： tetrat::TetrahedraInfo  场四面体 hexas::HexahedraInfo,   源六面体 计算： jk₀η₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnHexasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.EFIEOnHexasPWC","text":"采用 PWC 基函数 计算六面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况，因此输入有两个六面体信息类型实例 输入： hexat  hexas     :   HexahedraInfo, 场六面体和六面体 计算： jk₀η₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnHexasRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.EFIEOnHexasRBF","text":"计算六面体上相关的 36 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况，因此输入有两个六面体信息类型实例 输入 hexat, hexas     :   HexahedraInfo, 场六面体和源六面体\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnNearHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.EFIEOnNearHexaTetraPWC","text":"采用 PWC 基函数 计算六面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较近的情况，因此输入有两个六面体信息类型实例 输入： hexat  hexas     :   HexahedraInfo, 场六面体和六面体 计算： jkη₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 其中， ∫ₜ∫ₛ∇∇G(R)dV′dV = ∫ₜ∑ᵢn̂ᵢ(∫ᵢR̂(jk + 1/R)G(R)dS′)dV 计算得到结果为并矢:: jη₀/k ∫∫ (k²I + ∇∇)G(R) dV'dV Kᵣⁿ  =   ∫ Rⁿ dV' K̂ᵣⁿ  =   ∫ R̂Rⁿ dV' 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnNearHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.EFIEOnNearHexaTetraPWC","text":"采用 PWC 基函数 计算六面体和四面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况，因此输入有两个六面体信息类型实例 输入： tetrat::TetrahedraInfo  场四面体 hexas::HexahedraInfo,   源六面体 计算： jk₀η₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnNearHexasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.EFIEOnNearHexasPWC","text":"采用 PWC 基函数 计算六面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较近的情况，因此输入有两个六面体信息类型实例 输入： hexat  hexas     :   HexahedraInfo, 场六面体和六面体 计算： jkη₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 其中， ∫ₜ∫ₛ∇∇G(R)dV′dV = ∫ₜ∑ᵢn̂ᵢ(∫ᵢR̂(jk + 1/R)G(R)dS′)dV 计算得到结果为并矢:: jη₀/k ∫∫ (k²I + ∇∇)G(R) dV'dV Kᵣⁿ  =   ∫ Rⁿ dV' K̂ᵣⁿ  =   ∫ R̂Rⁿ dV' 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnNearHexasRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.EFIEOnNearHexasRBF","text":"计算六面体上相关的 36 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合但相隔较近的情况，输入有两个六面体信息类型实例 输入 hexat, hexas     :   HexahedraInfo, 场六面体和源六面体\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT<:Integer, FT<:AbstractFloat, VT<:HexahedraInfo}","page":"API","title":"MoM_Kernels.EFIEOnNearRWGPWC","text":"计算三角形和六面体上相关的 9 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较近的情况 输入 trit    ::  TriangleInfo,  场三角形面体 geos    ::  HexahedraInfo, 源六面体\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT<:Integer, FT<:AbstractFloat, VT<:VolumeCellType}","page":"API","title":"MoM_Kernels.EFIEOnNearRWGPWC","text":"计算三角形和四面体上相关的 9 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较近的情况 输入 trit    ::  TriangleInfo,  场三角形面体 geos    ::  TetrahedraInfo, TetrahedraInfo, 源四面体、四面体\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:AbstractFloat, VT<:HexahedraInfo}","page":"API","title":"MoM_Kernels.EFIEOnNearRWGPWC","text":"计算三角形和六面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 geot    ::  HexahedraInfo, 场六面体\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:AbstractFloat, VT<:VolumeCellType}","page":"API","title":"MoM_Kernels.EFIEOnNearRWGPWC","text":"计算三角形和四面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 geot    ::  TetrahedraInfo, TetrahedraInfo, 场四面体、四面体\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnNearRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.EFIEOnNearRWGRBF","text":"计算三角形和六面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 hexat  ::  HexahedraInfo, 场六面体\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnNearRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, HexahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.EFIEOnNearRWGRBF","text":"计算三角形和六面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较近的情况 输入 tris    ::  TriangleInfo,  源三角形面体 hexat  ::  HexahedraInfo, 场六面体\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnNearRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.EFIEOnNearRWGSWG","text":"计算三角形和四面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 tetrat  ::  TetrahedraInfo, 场四面体\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnNearRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TetrahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.EFIEOnNearRWGSWG","text":"计算三角形和四面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较近的情况 输入 tris    ::  TriangleInfo,  源三角形面体 tetrat  ::  TetrahedraInfo, 场四面体\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnNearTetrasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.EFIEOnNearTetrasPWC","text":"采用 PWC 基函数 计算四面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较近的情况，因此输入有两个四面体信息类型实例 输入： tetrat  tetras     :   TetrahedraInfo, 场四面体和四面体 计算： jkη₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 其中， ∫ₜ∫ₛ∇∇G(R)dV′dV = ∫ₜ∑ᵢn̂ᵢ(∫ᵢR̂(jk + 1/R)G(R)dS′)dV 计算得到结果为并矢:: jη₀/k ∫∫ (k²I + ∇∇)G(R) dV'dV Kᵣⁿ  =   ∫ Rⁿ dV' K̂ᵣⁿ  =   ∫ R̂Rⁿ dV' 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnNearTetrasSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.EFIEOnNearTetrasSWG","text":"计算四面体上相关的 16 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合但相隔较近的情况，输入有两个四面体信息类型实例 输入 tetrat, tetras     :   TetrahedraInfo, 场四面体和源四面体\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnNearTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:AbstractFloat}","page":"API","title":"MoM_Kernels.EFIEOnNearTris","text":"计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形不重合但相隔较近的情况，因此输入有两个个三角形信息类型实例 输入 trit， tris     :   TriangleInfo, 场三角形和源三角形\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT<:Integer, FT<:AbstractFloat, VT<:HexahedraInfo}","page":"API","title":"MoM_Kernels.EFIEOnRWGPWC","text":"计算三角形和六面体上相关的 9 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况 输入 trit    ::  TriangleInfo,  场三角形面体 geos    ::  HexahedraInfo, 源六面体\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT<:Integer, FT<:AbstractFloat, VT<:TetrahedraInfo}","page":"API","title":"MoM_Kernels.EFIEOnRWGPWC","text":"计算三角形和四面体上相关的 9 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况 输入 trit    ::  TriangleInfo,  场三角形面体 geos    ::  TetrahedraInfo, 源四面体\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:AbstractFloat, VT<:HexahedraInfo}","page":"API","title":"MoM_Kernels.EFIEOnRWGPWC","text":"计算三角形和六面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 geot    ::  HexahedraInfo, 场六面体\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:AbstractFloat, VT<:VolumeCellType}","page":"API","title":"MoM_Kernels.EFIEOnRWGPWC","text":"计算三角形和四面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 geot    ::  TetrahedraInfo, TetrahedraInfo, 场四面体、四面体\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.EFIEOnRWGRBF","text":"计算三角形和六面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 hexat  ::  HexahedraInfo, 场六面体\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, HexahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.EFIEOnRWGRBF","text":"计算三角形和六面体上相关的 18 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况 输入 trit    ::  TriangleInfo,  场三角形面体 hexas   ::  HexahedraInfo, 源六面体\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.EFIEOnRWGSWG","text":"计算三角形和四面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 tetrat  ::  TetrahedraInfo, 场四面体\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TetrahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.EFIEOnRWGSWG","text":"计算三角形和四面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 tetrat  ::  TetrahedraInfo, 场四面体\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnTetraPWC-Union{Tuple{TetrahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.EFIEOnTetraPWC","text":"采用 PWC 基函数 计算四面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源四面体重合的情况，因此输入有一个四面体信息类型实例 输入： tetrat   TetrahedraInfo, 场四面体和四面体 计算： jkη₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 其中， ∫ₜ∫ₛ∇∇G(R)dV′dV = ∫ₜ∑ᵢn̂ᵢ(∫ᵢR̂(jk + 1/R)G(R)dS′)dV 计算得到结果为并矢:: jη₀/k ∫∫ (k²I + ∇∇)G(R) dV'dV Kᵣⁿ  =   ∫ Rⁿ dV' K̂ᵣⁿ  =   ∫ R̂Rⁿ dV' 注意为与两两作用不同，此处加上了 κ 项，因此后续填充时不需加上。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnTetraPWCSepPV-Union{Tuple{TetrahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.EFIEOnTetraPWCSepPV","text":"采用 PWC 基函数 计算四面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源四面体重合的情况，因此输入有一个四面体信息类型实例 输入： tetrat   TetrahedraInfo, 场四面体和四面体 计算： jkη₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 其中， ∫ₜ∫ₛ∇∇G(R)dV′dV = ∫ₜ∑ᵢn̂ᵢ(∫ᵢR̂(jk + 1/R)G(R)dS′)dV 计算得到结果为并矢:: jη₀/k ∫∫ (k²I + ∇∇)G(R) dV'dV Kᵣⁿ  =   ∫ Rⁿ dV' K̂ᵣⁿ  =   ∫ R̂Rⁿ dV' 注意为与两两作用不同，函数将主值积分分开返回以便它用\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnTetraSWG-Union{Tuple{TetrahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.EFIEOnTetraSWG","text":"计算四面体上相关的 16 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况，因此输入有两个四面体信息类型实例 输入 tetrat, tetras     :   TetrahedraInfo, 场四面体和源四面体\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnTetrasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.EFIEOnTetrasPWC","text":"采用 PWC 基函数 计算四面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况，因此输入有两个四面体信息类型实例 输入： tetrat  tetras     :   TetrahedraInfo, 场四面体和四面体 计算： jk₀η₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnTetrasSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.EFIEOnTetrasSWG","text":"计算四面体上相关的 16 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况，因此输入有两个四面体信息类型实例 输入 tetrat, tetras     :   TetrahedraInfo, 场四面体和源四面体\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:AbstractFloat}","page":"API","title":"MoM_Kernels.EFIEOnTris","text":"计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形不重合且相隔较远的情况，因此输入有两个个三角形信息类型实例 输入 trit， tris     :   TriangleInfo, 场三角形和源三角形\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.EFIEOnTris-Union{Tuple{TriangleInfo{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT<:Integer, FT<:AbstractFloat}","page":"API","title":"MoM_Kernels.EFIEOnTris","text":"计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形重合的情况，因此输入只有一个三角形信息类型实例 输入 tri     :   TriangleInfo\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.MFIEOnNearTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:AbstractFloat}","page":"API","title":"MoM_Kernels.MFIEOnNearTris","text":"计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形不重合但相隔较近的情况，因此输入有两个个三角形信息类型实例 输入 trit， tris     :   TriangleInfo, 场三角形和源三角形\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.MFIEOnTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:AbstractFloat}","page":"API","title":"MoM_Kernels.MFIEOnTris","text":"计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形不重合且相隔较远的情况，因此输入有两个个三角形信息类型实例 输入 trit， tris     :   TriangleInfo, 场三角形和源三角形\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.MFIEOnTris-Union{Tuple{TriangleInfo{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT<:Integer, FT<:AbstractFloat}","page":"API","title":"MoM_Kernels.MFIEOnTris","text":"计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形重合的情况，因此输入只有一个三角形信息类型实例 输入 tri     :   TriangleInfo\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.RCSPlot-Union{Tuple{FT}, Tuple{Any, Any, Matrix{FT}, Matrix{FT}}} where FT<:Real","page":"API","title":"MoM_Kernels.RCSPlot","text":"RCS 绘图\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.ZnearChunkMulIVec!-Tuple{Any, Any, Any}","page":"API","title":"MoM_Kernels.ZnearChunkMulIVec!","text":"ZnearChunkMulIVec!(ZnearChunk, resultChunk, IVec)\n\n计算某一块的矩阵向量乘积\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.adjoint_agg2HighLevel!-Tuple{Any, Any}","page":"API","title":"MoM_Kernels.adjoint_agg2HighLevel!","text":"从子层聚合到本层 tLevel :: 本层 kLevel :: 子层\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.adjoint_agg2Level2!-Tuple{Any, Any}","page":"API","title":"MoM_Kernels.adjoint_agg2Level2!","text":"从叶层聚合到第 '2' 层\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.adjoint_aggOnBF!-Union{Tuple{T}, Tuple{Any, Any, AbstractArray{T}}} where T<:Number","page":"API","title":"MoM_Kernels.adjoint_aggOnBF!","text":"在叶层从基函数向盒子聚合\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.adjoint_disagg2KidLevel!-Tuple{Any, Any}","page":"API","title":"MoM_Kernels.adjoint_disagg2KidLevel!","text":"向低层解聚 tLevel :: 本层 kLevel :: 子层\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.adjoint_disagg2LeafLevel!-Tuple{Any, Any}","page":"API","title":"MoM_Kernels.adjoint_disagg2LeafLevel!","text":"解聚到叶层\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.adjoint_disaggOnBF!-Tuple{Any, Any, Any}","page":"API","title":"MoM_Kernels.adjoint_disaggOnBF!","text":"在叶层往测试基函数解聚\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.adjoint_transOnLevel!-Tuple{Any}","page":"API","title":"MoM_Kernels.adjoint_transOnLevel!","text":"层内转移\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.adjoint_transOnLevels!-Tuple{Any, Any}","page":"API","title":"MoM_Kernels.adjoint_transOnLevels!","text":"各层内转移\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.agg2HighLevel!-Tuple{Any, Any}","page":"API","title":"MoM_Kernels.agg2HighLevel!","text":"从子层聚合到本层 tLevel :: 本层 kLevel :: 子层\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.agg2HighLevel!-Union{Tuple{IPT}, Tuple{FT}, Tuple{IT}, Tuple{Any, MoM_Kernels.LevelInfo{IT, FT, IPT}}} where {IT, FT, IPT<:MoM_Kernels.LagrangeInterpInfo}","page":"API","title":"MoM_Kernels.agg2HighLevel!","text":"从子层聚合到本层 tLevel :: 本层 kLevel :: 子层\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.agg2Level2!-Tuple{Any, Any}","page":"API","title":"MoM_Kernels.agg2Level2!","text":"从叶层聚合到第 '2' 层\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.aggOnBF!-Union{Tuple{T}, Tuple{Any, Any, AbstractArray{T}}} where T<:Number","page":"API","title":"MoM_Kernels.aggOnBF!","text":"在叶层从基函数向盒子聚合\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:PWC}","page":"API","title":"MoM_Kernels.aggSBFOnLevel!","text":"aggSBFOnLevel!(aggSBF, disaggSBF, level, hexasInfo::AbstractVector{HexahedraInfo{IT, FT, CT}}, \n::Type{BFT}; setzero = true) where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:PWC}\n\n计算某层采用 EFIE 时在六面体上的 PWC 基函数的辐射函数 aggSBF 、配置函数 disaggSBF。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:PWC}","page":"API","title":"MoM_Kernels.aggSBFOnLevel!","text":"aggSBFOnLevel!(aggSBF, disaggSBF, level, tetrasInfo::AbstractVector{TetrahedraInfo{IT, FT, CT}}, \n::Type{BFT}; setzero = true) where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:PWC}\n\n计算某层采用 EFIE 时在四面体上的 PWC 基函数的辐射函数 aggSBF 、配置函数 disaggSBF。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:SWG}","page":"API","title":"MoM_Kernels.aggSBFOnLevel!","text":"aggSBFOnLevel!(aggSBF, disaggSBF, level, tetrasInfo::AbstractVector{TetrahedraInfo{IT, FT, CT}}, \n::Type{BFT}; setzero = true) where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:SWG}\n\n计算某层采用 EFIE 时 SWG 基函数的辐射函数 aggSBF 、配置函数 disaggSBF。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{VT}, Tuple{Any, Any, Any, AbstractVector{VT}, Type{BFT}}} where {VT<:HexahedraInfo, BFT<:RBF}","page":"API","title":"MoM_Kernels.aggSBFOnLevel!","text":"aggSBFOnLevel!(aggSBF, disaggSBF, level, hexasInfo::AbstractVector{VT}, \n::Type{BFT}; setzero = true) where {VT<:HexahedraInfo, BFT<:RBF}\n\n计算某层采用 EFIE 时在六面体上的 RBF 基函数的辐射函数 aggSBF 、配置函数 disaggSBF。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.aggSBFOnLevel-Union{Tuple{BFT}, Tuple{VT}, Tuple{LT}, Tuple{LT, AbstractVector{VT}, AbstractVector{BFT}}} where {LT<:MoM_Kernels.LevelInfo, VT<:VolumeCellType, BFT<:BasisFunctionType}","page":"API","title":"MoM_Kernels.aggSBFOnLevel","text":"aggSBFOnLevel(level::LT, geosInfo::AbstractVector{VT}, \nbfsInfo::AbstractVector{BFT}) where {LT<:LevelInfo, VT<:VolumeCellType, BFT<:BasisFunctionType}\n\n计算某层采用 EFIE 时 SWG 基函数的辐射函数 aggSBF 、配置函数 disaggSBF。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.aggSBFOnLevelCFIE!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT<:Integer, FT<:Real, BFT<:RWG}","page":"API","title":"MoM_Kernels.aggSBFOnLevelCFIE!","text":"aggSBFOnLevelCFIE!(aggSBF, disaggSBF, level, trianglesInfo::Vector{TriangleInfo{IT, FT}}, \n::Type{BFT}; setzero = true) where {IT<:Integer, FT<:Real, BFT<:RWG}\n\n计算某层采用 CFIE 时 RWG 基函数的辐射函数 aggSBF 、配置函数 disaggSBF。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.aggSBFOnLevelCFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Any}} where {IT<:Integer, FT<:Real}","page":"API","title":"MoM_Kernels.aggSBFOnLevelCFIE","text":"aggSBFOnLevelCFIE(level, trianglesInfo::Vector{TriangleInfo{IT, FT}}, \nbfsInfo) where {IT<:Integer, FT<:Real}\n\n计算某层采用 CFIE 时 RWG 基函数的辐射函数 aggSBF 、配置函数 disaggSBF ,  输入为层信息 level 、三角形信息 trianglesInfo 和基函数信息 bfsInfo。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.aggSBFOnLevelEFIE!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT<:Integer, FT<:Real, BFT<:RWG}","page":"API","title":"MoM_Kernels.aggSBFOnLevelEFIE!","text":"aggSBFOnLevelEFIE!(aggSBF, disaggSBF, level, trianglesInfo::Vector{TriangleInfo{IT, FT}}, \n::Type{BFT}; setzero = true) where {IT<:Integer, FT<:Real, BFT<:RWG}\n\n计算某层采用 EFIE 时 RWG 基函数的辐射函数 aggSBF 、配置函数 disaggSBF。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.aggSBFOnLevelEFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Any}} where {IT<:Integer, FT<:Real}","page":"API","title":"MoM_Kernels.aggSBFOnLevelEFIE","text":"aggSBFOnLevelEFIE(level, trianglesInfo::Vector{TriangleInfo{IT, FT}}, \nbfsInfo) where {IT<:Integer, FT<:Real}\n\n计算某层采用 EFIE 时 RWG 基函数的辐射函数 aggSBF 、配置函数 disaggSBF ,  输入为层信息 level 、三角形信息 trianglesInfo 和基函数信息 bfsInfo。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.aggSBFOnLevelMFIE!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT<:Integer, FT<:Real, BFT<:RWG}","page":"API","title":"MoM_Kernels.aggSBFOnLevelMFIE!","text":"aggSBFOnLevelMFIE!(aggSBF, disaggSBF, level, trianglesInfo::Vector{TriangleInfo{IT, FT}}, \n::Type{BFT}; setzero = true) where {IT<:Integer, FT<:Real, BFT<:RWG}\n\n计算某层采用 MFIE 时在三角形上的 RWG 基函数的辐射函数 aggSBF 、配置函数 disaggSBF。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.aggSBFOnLevelMFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Array{RWG{IT, FT}, 1}}} where {IT<:Integer, FT<:Real}","page":"API","title":"MoM_Kernels.aggSBFOnLevelMFIE","text":"aggSBFOnLevelMFIE(level, trianglesInfo::Vector{TriangleInfo{IT, FT}}, \nbfsInfo::Vector{RWG{IT, FT}}) where {IT<:Integer, FT<:Real}\n\n计算某层采用 MFIE 时在三角形上的 RWG 基函数的辐射函数 aggSBF 、配置函数 disaggSBF。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.anterpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}","page":"API","title":"MoM_Kernels.anterpolate!","text":"拉格朗日单步反插值\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.anterpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}","page":"API","title":"MoM_Kernels.anterpolate!","text":"拉格朗日分步反插值\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.anterpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}","page":"API","title":"MoM_Kernels.anterpolate","text":"拉格朗日单步反插值\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.anterpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}","page":"API","title":"MoM_Kernels.anterpolate","text":"拉格朗日分步反插值\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.calZfarI!-Union{Tuple{MT}, Tuple{T}, Tuple{ZT}, Tuple{MLFMAIterator{ZT, MT}, AbstractArray{T}}} where {ZT, T<:Number, MT<:(Vector)}","page":"API","title":"MoM_Kernels.calZfarI!","text":"计算远区矩阵向量乘积\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.calZnearCSC!-Union{Tuple{VSCellT}, Tuple{BFT}, Tuple{Any, AbstractVector{VSCellT}, Any}, Tuple{Any, AbstractVector{VSCellT}, Any, Type{BFT}}} where {BFT<:BasisFunctionType, VSCellT<:SurfaceCellType}","page":"API","title":"MoM_Kernels.calZnearCSC!","text":"calZnearCSC!(level, geosInfo::AbstractVector{VSCellT}, \n    Znear, bfT::Type{BFT} = VSBFTypes.sbfType) where {BFT<:BasisFunctionType, VSCellT<:SurfaceCellType}\ncalZnearCSC!(level, geosInfo::AbstractVector{VSCellT}, \n    Znear, bfT::Type{BFT} = VSBFTypes.vbfType) where {BFT<:BasisFunctionType, VSCellT<:VolumeCellType}\ncalZnearCSC!(level, geosInfo::AbstractVector{VT}, \n    Znear) where {VT<:AbstractVector}\n\n根据八叉树层信息 level 和几何信息 geosInfo 、基函数信息 bfsInfo 计算近场阻抗矩阵。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.calZnearCSC-Tuple{Any, Vector, Vector}","page":"API","title":"MoM_Kernels.calZnearCSC","text":"calZnearCSC(level, geosInfo::Vector, bfsInfo::Vector)\n\n根据八叉树层信息 level 和几何信息 geosInfo 、基函数信息 bfsInfo 计算近场阻抗矩阵。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.calZnearCSCCFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:RWG}","page":"API","title":"MoM_Kernels.calZnearCSCCFIE!","text":"calZnearCSCCFIE!(level, trianglesInfo::Vector{TriangleInfo{IT, FT}},\n    Znear::ZnearT{CT}, ::Type{BFT}) where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:RWG}\n\n采用 RWG 基函数计算 CFIE 面积分（SIE）阻抗矩阵近场元并将结果放在 ZnearCSC 稀疏矩阵中。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:ConstBasisFunction}","page":"API","title":"MoM_Kernels.calZnearCSCEFIE!","text":"采用 PWC 基函数计算六面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:LinearBasisFunction}","page":"API","title":"MoM_Kernels.calZnearCSCEFIE!","text":"采用 RBF 基函数计算六面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:ConstBasisFunction}","page":"API","title":"MoM_Kernels.calZnearCSCEFIE!","text":"采用 PWC 基函数计算四面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:LinearBasisFunction}","page":"API","title":"MoM_Kernels.calZnearCSCEFIE!","text":"采用 SWG 基函数计算网格元 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:RBF}","page":"API","title":"MoM_Kernels.calZnearCSCEFIE!","text":"采用 RWG + RBF 基函数计算六面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:SWG}","page":"API","title":"MoM_Kernels.calZnearCSCEFIE!","text":"采用 RWG + SWG 基函数计算 三角形 + 四面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:LinearBasisFunction}","page":"API","title":"MoM_Kernels.calZnearCSCEFIE!","text":"采用 RWG 基函数计算 EFIE 面积分（SIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{VT2}, Tuple{VT1}, Tuple{CT}, Tuple{FT}, Tuple{Any, AbstractVector{VT1}, AbstractVector{VT2}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, AbstractVector{VT1}, AbstractVector{VT2}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {FT<:Real, CT<:Complex{FT}, VT1<:TetrahedraInfo, VT2<:HexahedraInfo, BFT<:PWC}","page":"API","title":"MoM_Kernels.calZnearCSCEFIE!","text":"采用 PWC + PWC 基函数计算 四面体 + 六面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{VT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractVector{VT}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractVector{VT}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, VT<:VolumeCellType, BFT<:PWC}","page":"API","title":"MoM_Kernels.calZnearCSCEFIE!","text":"采用 RWG + PWC 基函数计算 三角形 + 四面体/六面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.calZnearCSCEFIEnew!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:LinearBasisFunction}","page":"API","title":"MoM_Kernels.calZnearCSCEFIEnew!","text":"采用 RBF 基函数计算六面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.calZnearCSCMFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:RWG}","page":"API","title":"MoM_Kernels.calZnearCSCMFIE!","text":"采用 RWG 基函数计算 MFIE 面积分（SIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.caladjZfarI!-Union{Tuple{MT}, Tuple{T}, Tuple{ZT}, Tuple{LinearAlgebra.Adjoint{ZT, MLFMAIterator{ZT, MT}}, AbstractArray{T}}} where {ZT, T<:Number, MT<:(Vector)}","page":"API","title":"MoM_Kernels.caladjZfarI!","text":"计算远区矩阵的伴随矩阵向量乘积\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.calαTransOnLevel!-NTuple{4, Any}","page":"API","title":"MoM_Kernels.calαTransOnLevel!","text":"计算 level 层的转移因子， 转移因子只存在于远亲组，每层远亲组最多有 7^3 - 3^3 = 316种结果\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.coeffgreen-Tuple{Integer}","page":"API","title":"MoM_Kernels.coeffgreen","text":"coeffgreen(n::Integer)\n\n归一化格林函数 (不包括frac14π项) 的展开系数函数，从 0 阶 到 n 阶：\n\nbeginaligned\ng(R)    = frace^-jkRR = sum_n=0^SglrOrdercoeffgreen(n)R^n-1\ncoeffgreen(n)  =   frac-jk^nn\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.convergencePlot-Union{Tuple{Vector{FT}}, Tuple{FT}} where FT<:Real","page":"API","title":"MoM_Kernels.convergencePlot","text":"计算完成后绘制收敛曲线\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.cooraInCoorb-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T<:Number","page":"API","title":"MoM_Kernels.cooraInCoorb","text":"计算一维坐标coora在坐标corrb中的位置\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.disagg2KidLevel!-Tuple{Any, Any}","page":"API","title":"MoM_Kernels.disagg2KidLevel!","text":"向低层解聚 tLevel :: 本层 kLevel :: 子层\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.disagg2KidLevel!-Union{Tuple{IPT}, Tuple{FT}, Tuple{IT}, Tuple{Any, MoM_Kernels.LevelInfo{IT, FT, IPT}}} where {IT, FT, IPT<:MoM_Kernels.LagrangeInterpInfo}","page":"API","title":"MoM_Kernels.disagg2KidLevel!","text":"向低层解聚 tLevel :: 本层 kLevel :: 子层\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.disagg2LeafLevel!-Tuple{Any, Any}","page":"API","title":"MoM_Kernels.disagg2LeafLevel!","text":"解聚到叶层\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.disaggOnBF!-Tuple{Any, Any, Any}","page":"API","title":"MoM_Kernels.disaggOnBF!","text":"在叶层往测试基函数解聚\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.electricJCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{StaticArraysCore.StaticArray{Tuple{3}, FT, 1}, StaticArraysCore.StaticArray{Tuple{3}, CT, 1}, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.electricJCal","text":"计算给定三角形面片位置 r 处的电流 电流基函数公式为：Jₙ = Iₙfₙ 同一个三角形面片上存在三个基函数，因此 Jₜ = ∑ₜₙ₌₁³ Iₜₙfₜₙ 输入： r               ::Vec3D{FT} ICoeff          ::Vec3D{CT}  三角形上的三个基函数的计算得到的电流系数 triangleInfo    ::TriangleInfo{IT, FT}，三角形信息 输出值: Jtrir           ::Complex{FT}, 三角形上加权后的电流\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.electricJCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.electricJCal","text":"计算所有三角形上的高斯求积点电流权重乘积 JₙᵢWᵢ 电流基函数公式为：Jₙ = Iₙfₙ 同一个三角形面片上存在三个基函数，因此 JₙᵢWᵢ = ∑ₜₙ₌₁³ Iₜₙlₜₙ/2Sₜₙ 输入： ICoeff          ::Vector{Complex{FT}}  计算得到的电流系数 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，三角形信息 输出值: Jtri         ::Marrix{Complex{FT}}, 三角形上加权后的电流\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.excitationVectorCFIE!-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}, Any}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real}","page":"API","title":"MoM_Kernels.excitationVectorCFIE!","text":"计算平面波在 RWG 基函数上的激励向量 输入： source          ::ST, 波源 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，保存三角形信息的向量 nbf             ::Integer，基函数数目\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.excitationVectorCFIE-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TriangleInfo{IT, FT}, Type{BFT}}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real, BFT<:RWG}","page":"API","title":"MoM_Kernels.excitationVectorCFIE","text":"计算平面波在给定三角形的三个 半RWG 基函数上的激励向量 输入： source  ::ST, 波源 tri     ::TriangleInfo{IT, FT}，三角形信息\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.excitationVectorCFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, Array{TriangleInfo{IT, FT}, 1}, Integer}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real}","page":"API","title":"MoM_Kernels.excitationVectorCFIE","text":"计算平面波在 RWG 基函数上的激励向量 输入： source          ::ST, 波源 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，保存三角形信息的向量 nbf             ::Integer，基函数数目\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.excitationVectorEFIE!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Any}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.excitationVectorEFIE!","text":"计算平面波在 基函数 上的激励向量 输入： source          ::ST, 平面波源 tetrasInfo      ::Vector{TetrahedraInfo{IT, FT, CT}}，保存四面体信息的向量 nbf             ::Integer，基函数数量  \n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.excitationVectorEFIE!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Vector{CT}, ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}}, Tuple{Vector{CT}, ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Any}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.excitationVectorEFIE!","text":"计算平面波在 基函数 上的激励向量 输入： source          ::ST, 平面波源 hexasInfo       ::Vector{HexahedraInfo{IT, FT, CT}}，保存六面体信息的向量 nbf             ::Integer，基函数数量  \n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.excitationVectorEFIE!-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}, Any}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real}","page":"API","title":"MoM_Kernels.excitationVectorEFIE!","text":"计算平面波在 RWG 基函数上的激励向量 输入： source          ::ST, 波源 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，保存三角形信息的向量 nbf             ::Integer，基函数数目\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.excitationVectorEFIE!-Union{Tuple{VT}, Tuple{ST}, Tuple{AbstractVector, ST, Vector{VT}}} where {ST<:ExcitingSources, VT<:(AbstractVector)}","page":"API","title":"MoM_Kernels.excitationVectorEFIE!","text":"计算平面波在 基函数 上的激励向量 输入： source          ::ST, 平面波源 tetrasInfo      ::Vector{TetrahedraInfo{IT, FT, CT}}，保存六面体信息的向量 nbf             ::Integer，基函数数量  \n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, HexahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:ConstBasisFunction}","page":"API","title":"MoM_Kernels.excitationVectorEFIE","text":"计算平面波在给定四面体的三个 PWC 基函数上的激励向量 输入： source      ::ST, 波源 hexa        ::HexahedraInfo{IT, FT, CT}，六面体信息\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, HexahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:LinearBasisFunction}","page":"API","title":"MoM_Kernels.excitationVectorEFIE","text":"计算平面波在给定六面体的六个 半SWG 基函数上的激励向量 输入： source      ::ST, 波源 hexa        ::HexahedraInfo{IT, FT, CT}，六面体信息\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TetrahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:ConstBasisFunction}","page":"API","title":"MoM_Kernels.excitationVectorEFIE","text":"计算平面波在给定四面体的三个 PWC 基函数上的激励向量 输入： source      ::ST, 波源 tetra       ::TetrahedraInfo{IT, FT, CT}，四面体信息\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TetrahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:LinearBasisFunction}","page":"API","title":"MoM_Kernels.excitationVectorEFIE","text":"计算平面波在给定四面体的四个 半SWG 基函数上的激励向量 输入： source      ::ST, 波源 tetra       ::TetrahedraInfo{IT, FT, CT}，四面体信息\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TriangleInfo{IT, FT}, Type{BFT}}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real, BFT<:RWG}","page":"API","title":"MoM_Kernels.excitationVectorEFIE","text":"计算平面波在给定三角形的三个 半RWG 基函数上的激励向量 输入： source  ::ST, 波源 tri     ::TriangleInfo{IT, FT}，三角形信息\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.excitationVectorEFIE-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer}, Tuple{ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer, Any}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.excitationVectorEFIE","text":"计算平面波在 基函数 上的激励向量 输入： source          ::ST, 平面波源 hexasInfo      ::Vector{HexahedraInfo{IT, FT, CT}}，保存六面体信息的向量 nbf             ::Integer，基函数数量  \n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.excitationVectorEFIE-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer}, Tuple{ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer, Any}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.excitationVectorEFIE","text":"计算平面波在 基函数 上的激励向量 输入： source          ::ST, 平面波源 tetrasInfo      ::Vector{TetrahedraInfo{IT, FT, CT}}，保存四面体信息的向量 nbf             ::Integer，基函数数量  \n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.excitationVectorEFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, Array{TriangleInfo{IT, FT}, 1}, Integer}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real}","page":"API","title":"MoM_Kernels.excitationVectorEFIE","text":"计算平面波在 RWG 基函数上的激励向量 输入： source          ::ST, 波源 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，保存三角形信息的向量 nbf             ::Integer，基函数数目\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.excitationVectorEFIE-Union{Tuple{VT}, Tuple{ST}, Tuple{ST, Vector{VT}, Integer}} where {ST<:ExcitingSources, VT<:(AbstractVector)}","page":"API","title":"MoM_Kernels.excitationVectorEFIE","text":"计算平面波在 基函数 上的激励向量 输入： source          ::ST, 平面波源 tetrasInfo      ::Vector{TetrahedraInfo{IT, FT, CT}}，保存六面体信息的向量 nbf             ::Integer，基函数数量  \n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.excitationVectorMFIE!-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}, Any}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real}","page":"API","title":"MoM_Kernels.excitationVectorMFIE!","text":"计算平面波在 RWG 基函数上的激励向量 输入： source          ::ST, 波源 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，保存三角形信息的向量 nbf             ::Integer，基函数数目\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.excitationVectorMFIE-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TriangleInfo{IT, FT}, Type{BFT}}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real, BFT<:RWG}","page":"API","title":"MoM_Kernels.excitationVectorMFIE","text":"计算平面波在给定三角形的三个 半RWG 基函数上的激励向量 输入： source  ::ST, 波源 tri     ::TriangleInfo{IT, FT}，三角形信息\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.excitationVectorMFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, Array{TriangleInfo{IT, FT}, 1}, Integer}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real}","page":"API","title":"MoM_Kernels.excitationVectorMFIE","text":"计算平面波在 RWG 基函数上的激励向量 输入： source          ::ST, 波源 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，保存三角形信息的向量 nbf             ::Integer，基函数数目\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.faceSingularityIg-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, TriangleInfo{IT, FT}, FT, AbstractVector{FT}}} where {IT<:Integer, FT<:Real}","page":"API","title":"MoM_Kernels.faceSingularityIg","text":"faceSingularityIg(rgt::AbstractVector{FT}, tris::TriangleInfo{IT, FT}, area::FT, facen̂::AbstractVector{FT}) where {IT<:Integer, FT<:Real}\n\n计算场点rgt在源三角形tris上的奇异性，tris的面积为area，外法向量为facen̂。 计算结果为：\n\nbeginaligned\nI_gS  = intg(R)dS\n        = sum_n=0^SglrOrdercoeffgreen(n)I^n-1_RS\nI^n_RS  = intR^ndS\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.faceSingularityIg-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, Tris4Tetra{IT, FT}, FT, AbstractVector{FT}}} where {IT<:Integer, FT<:Real}","page":"API","title":"MoM_Kernels.faceSingularityIg","text":"faceSingularityIg(rgt::AbstractVector{FT}, tris::Tris4Tetra{IT, FT}, area::FT, facen̂::AbstractVector{FT}) where {IT<:Integer, FT<:Real}\n\n计算场点rgt在源三角形tris（该三角形为组成四面体的某一面）上的奇异性，tris的面积为area，外法向量为facen̂。 计算结果为：\n\nbeginaligned\nI_gS  = intg(R)dS\n        = sum_n=0^SglrOrdercoeffgreen(n)I^n-1_RS\nI^n_RS  = intR^ndS\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.faceSingularityIg-Union{Tuple{ST}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, ST, FT, AbstractVector{FT}}} where {IT<:Integer, FT<:Real, ST<:SurfaceCellType{IT, FT}}","page":"API","title":"MoM_Kernels.faceSingularityIg","text":"faceSingularityIg(rgt::AbstractVector{FT}, polys::ST, area::FT, \nfacen̂::AbstractVector{FT}) where {IT<:Integer, FT<:Real, ST<:SurfaceCellType{IT, FT}}\n\n计算场点rgt在多边形polys上的奇异性，polys的面积为area，外法向量为facen̂。 计算结果为：\n\nbeginaligned\nI_gS  = intg(R)dS\n        = sum_n=0^SglrOrdercoeffgreen(n)I^n-1_RS\nI^n_RS  = intR^ndS\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.faceSingularityIgIvecg-Union{Tuple{ST}, Tuple{FT}, Tuple{AbstractVector{FT}, ST, Any, AbstractVector}} where {FT<:Real, ST<:SurfaceCellType}","page":"API","title":"MoM_Kernels.faceSingularityIgIvecg","text":"faceSingularityIgIvecg(rgt::AbstractVector{FT}, polys::ST, area, \n    facen̂::AbstractVector) where {FT<:Real, ST<:SurfaceCellType{IT, FT}}\n\n计算场点rgt在多边形polys上的奇异性，polys的面积为area，外法向量为facen̂。 计算结果为：\n\nbeginaligned\nI_gS  = intg(R)dS\n        = sum_n=0^SglrOrdercoeffgreen(n)I^n-1_RS\nboldsymbolI_gS  = intboldsymbolRg(R)dS\n        = sum_l_jhatbmu_j sum_n=0^SglrOrderfraccoeffgreen(n)n+1I^n-1_lr + dbmnI^n-1_gS\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.faceSingularityIgIvecgI∇gS-Union{Tuple{ST}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, ST, FT, AbstractVector{FT}}} where {IT<:Integer, FT<:Real, ST<:SurfaceCellType{IT, FT}}","page":"API","title":"MoM_Kernels.faceSingularityIgIvecgI∇gS","text":"面上的近奇异性 rgt, 为场三角形的求积点 tris::TriangleInfo{IT, FT}， 源三角形信息 计算得到结果:: IgS     =   ∫ g(R) dS'      =   ∑ₙ₌₀(coeffgreen(n)IR[n-1]) IvecgS  =   ∫ Rvec g(R) dS' =   ∑ₗⱼ ûⱼ ∑ₙ₌₀(coeffgreen(n)/(n+1)Ilᵣ[n-1]) + dn̂IgS I∇gS    =   ∫ ∇g(R) dS'     =   ∑ₙ₌₀VSC₃ⁿ*(-1/(n+2)∑ₗⱼûⱼIlᵣ[n+2] + dn̂IgS )\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.faceSingularityIᵣIᵨ-Union{Tuple{FT}, Tuple{IT}, Tuple{StaticArraysCore.MMatrix{3, 7, FT, 21}, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:Real}","page":"API","title":"MoM_Kernels.faceSingularityIᵣIᵨ","text":"面上的近奇异性 rgts::MMatrix{GQPNTriSglr, 3, Complex{FT}}, 为场三角形的所有高斯求积点 tris::TriangleInfo{IT, FT}， 源三角形信息 计算得到结果:: r0tProj2s::MMatrix{3, GQPNTriSglr, Complex{FT}, 3GQPNTriSglr}, 积分点在源三角形上的投影点 Iᵣ  =   ∫ 1/R dS'   =   ∑₁³(p02ilfᵢ - dtsAbsβᵢ) Iᵨ  =   ∫ ρ/R dS'   =   0.5∑₁³{ûᵢ[(R0^2fᵢ + li⁺R⁺ - li⁻*R⁻)]}\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.farEPlot-Union{Tuple{FT}, Tuple{Any, Any, Matrix{FT}, Matrix{FT}}} where FT<:Real","page":"API","title":"MoM_Kernels.farEPlot","text":"farE 绘图\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.farField-Tuple{Any, Any, Any}","page":"API","title":"MoM_Kernels.farField","text":"在球坐标为r̂θϕ处计算辐射积分，采用RWG基函数时，三角形上没有统一的电流值，每一点上都是三边电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙlₙρₙ/(2Sₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙlₙρₙ/2)exp(jkr̂(θ, ϕ)⋅rₙ) )\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.farField-Union{Tuple{BFT}, Tuple{CT}, Tuple{VT}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Any}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Any, Type{BFT}}} where {VT<:VolumeCellType, CT<:Complex, BFT<:BasisFunctionType}","page":"API","title":"MoM_Kernels.farField","text":"在球坐标为r̂θϕ处计算辐射积分，采用SWG基函数时，四面体上没有统一的电流值，每一点上都是四个SWG基函数电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙsₙρₙ/(3Vₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙsₙρₙ/3)exp(jkr̂(θ, ϕ)⋅rₙ) )\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.farField-Union{Tuple{BFT}, Tuple{ST}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{ST}, Any}, Tuple{Any, Any, Vector{CT}, Vector{ST}, Any, Type{BFT}}} where {CT<:Complex, ST<:TriangleInfo, BFT<:RWG}","page":"API","title":"MoM_Kernels.farField","text":"在球坐标为r̂θϕ处计算辐射积分，采用RWG基函数时，三角形上没有统一的电流值，每一点上都是三边电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙlₙρₙ/(2Sₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙlₙρₙ/2)exp(jkr̂(θ, ϕ)⋅rₙ) )\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.farField-Union{Tuple{VT}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Any}} where {CT<:Complex, VT<:(AbstractVector)}","page":"API","title":"MoM_Kernels.farField","text":"在球坐标为r̂θϕ处计算辐射积分，采用SWG基函数时，四面体上没有统一的电流值，每一点上都是四个SWG基函数电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙsₙρₙ/(3Vₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙsₙρₙ/3)exp(jkr̂(θ, ϕ)⋅rₙ) )\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.func4Cube1stkInterval-Tuple{MoM_Kernels.CubeInfo}","page":"API","title":"MoM_Kernels.func4Cube1stkInterval","text":"func4Cube1stkInterval(cube::CubeInfo)\nfunc4Cube1stkInterval(i::T) where T\nfunc4Cube1stkInterval(interval::T) where T <: UnitRange\nfunc4CubelastkInterval(cube::CubeInfo)\nfunc4CubelastkInterval(i::T) where T\nfunc4CubelastkInterval(interval::T) where T\n\n这六个函数用于寻找盒子的子盒子区间内的比较函数，多重分派以实现不同数据类型的比较。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:PWC}","page":"API","title":"MoM_Kernels.geoElectricJCal","text":"计算六面体上的电流。 分片常数基 PWC 基函数 电流基函数公式为：Jₙ = κₙIₙfₙ 同一个六面体面片上存在 x̂, ŷ, ẑ 方向的三个基函数，因此 Jₜ = κₜ ∑ₜₙ₌₁³Iₜₙfₜₙ 输入： ICoeff          ::Vector{Complex{FT}}  计算得到的电流系数 hexasInfo      ::Vector{HexahedraInfo{IT, FT, CT}},  输出值: Jhexa          ::Marrix{Complex{FT}}, 六面体上的电流\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:RBF}","page":"API","title":"MoM_Kernels.geoElectricJCal","text":"计算六面体上的电流。 分片常数基 RBF 基函数 电流基函数公式为：Jₙ = κₙIₙfₙ 同一个六面体面片上存在 6 或 3 个基函数，因此 Jₜ = ∑ₜₙ₌₁ Iₜₙfₜₙ 输入： ICoeff          ::Vector{Complex{FT}}  计算得到的电流系数 hexasInfo       ::Vector{HexahedraInfo{IT, FT, CT}},  输出值: Jhexa          ::Marrix{Complex{FT}}, 六面体上加权后的电流\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:PWC}","page":"API","title":"MoM_Kernels.geoElectricJCal","text":"计算四面体上的电流。 分片常数基 PWC 基函数 电流基函数公式为：Jₙ = κₙIₙfₙ 同一个四面体面片上存在 x̂, ŷ, ẑ 方向的三个基函数，因此 Jₜ = κₜ ∑ₜₙ₌₁³Iₜₙfₜₙ 输入： ICoeff          ::Vector{Complex{FT}}  计算得到的电流系数 tetrasInfo      ::Vector{TetrahedraInfo{IT, FT, CT}},  输出值: Jtetra          ::Marrix{Complex{FT}}, 四面体上的电流\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:SWG}","page":"API","title":"MoM_Kernels.geoElectricJCal","text":"计算四面体上的电流。 分片常数基 SWG 基函数 电流基函数公式为：Jₙ = κₙIₙfₙ 同一个四面体面片上存在四个基函数，因此 Jₜ = ∑ₜₙ₌₁⁴ Iₜₙfₜₙ 输入： ICoeff          ::Vector{Complex{FT}}  计算得到的电流系数 tetrasInfo      ::Vector{TetrahedraInfo{IT, FT, CT}},  输出值: Jtetra          ::Marrix{Complex{FT}}, 四面体上加权后的电流\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}}, Tuple{Vector{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:RWG}","page":"API","title":"MoM_Kernels.geoElectricJCal","text":"计算三角形面片上的加权电流。 电流基函数公式为：Jₙ = Iₙfₙ 同一个三角形面片上存在三个基函数，因此 Jₜ = ∑ₜₙ₌₁³ Iₜₙfₜₙ 输入： ICoeff          ::Vector{Complex{FT}}  计算得到的电流系数 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，三角形信息 输出值: Jtri         ::Marrix{Complex{FT}}, 三角形上加权后的电流\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.getAggSBFOnLevel-Union{Tuple{BFT}, Tuple{ST}, Tuple{Any, Vector{ST}, Vector{BFT}}} where {ST<:SurfaceCellType, BFT<:BasisFunctionType}","page":"API","title":"MoM_Kernels.getAggSBFOnLevel","text":"根据积分方程类型计算基层聚合项\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.getAggSBFOnLevel-Union{Tuple{BFT}, Tuple{VT}, Tuple{Any, Vector{VT}, Vector{BFT}}} where {VT<:VolumeCellType, BFT<:BasisFunctionType}","page":"API","title":"MoM_Kernels.getAggSBFOnLevel","text":"根据积分方程类型计算基层聚合项\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.getAggSBFOnLevel-Union{Tuple{VT2}, Tuple{VT1}, Tuple{Any, Vector{VT1}, Vector{VT2}}} where {VT1<:(AbstractVector), VT2<:(AbstractVector)}","page":"API","title":"MoM_Kernels.getAggSBFOnLevel","text":"根据积分方程类型计算基层聚合项\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.getBfsCenter-Union{Tuple{Vector{BFT}}, Tuple{BFT}} where BFT<:BasisFunctionType","page":"API","title":"MoM_Kernels.getBfsCenter","text":"计算基函数中心的数组，用于方便混合基函数使用时的情况\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.getBfsCenter-Union{Tuple{Vector{VT}}, Tuple{VT}} where VT<:(AbstractVector)","page":"API","title":"MoM_Kernels.getBfsCenter","text":"计算基函数中心的数组，用于方便混合基函数使用时的情况\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.getCubeIDsWithGeos-Tuple{Any, Any}","page":"API","title":"MoM_Kernels.getCubeIDsWithGeos","text":"找到 geosInfo 所在的所有 cude id\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.getExcitationVector-Union{Tuple{VST}, Tuple{Vector{VST}, Any, Any}} where VST<:SurfaceCellType","page":"API","title":"MoM_Kernels.getExcitationVector","text":"根据几何信息与基函数数量，计算激励向量 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 nbf::       基函数数量 source::    激励源 返回： V::         激励向量\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.getExcitationVector-Union{Tuple{VST}, Tuple{Vector{VST}, Any, Any}} where VST<:VolumeCellType","page":"API","title":"MoM_Kernels.getExcitationVector","text":"根据几何信息与基函数数量，计算激励向量 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 nbf::       基函数数量 source::    激励源 返回： V::         激励向量\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.getExcitationVector-Union{Tuple{VT}, Tuple{Vector{VT}, Any, Any}} where VT<:(AbstractVector)","page":"API","title":"MoM_Kernels.getExcitationVector","text":"根据几何信息与基函数数量，计算激励向量 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 nbf::       基函数数量 source::    激励源 返回： V::         激励向量\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.getGeoIDsInCubeChunk-Tuple{Any, Tuple}","page":"API","title":"MoM_Kernels.getGeoIDsInCubeChunk","text":"getGeoIDsInCubeChunk(cubes, chunkIndice::Tuple)\ngetGeoIDsInCubeChunk(cubes, ckunkIndice::UnitRange)\n\n获取 ckunkIndice 内的所有 cubes 的编号， 返回为 Tuple 形式以适应数组索引相关API\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.getGeosInterval-Tuple{T} where T<:(AbstractVector)","page":"API","title":"MoM_Kernels.getGeosInterval","text":"getGeosInterval(geosInfo::T) where {T<:AbstractVector}\ngetGeosInterval(geosInfo::T) where {T<:OffsetVector}\n\n获取几何信息数组的区间，针对普通 Vector 和 OffsetVector 分别派发。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.getImpedanceMatAndExciteV-Tuple{Any, Integer, Any}","page":"API","title":"MoM_Kernels.getImpedanceMatAndExciteV","text":"根据几何信息与基函数数量，计算阻抗矩阵和激励向量 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 nbf::       基函数数量 source::    激励源 返回： Zmat::      阻抗矩阵 V::         激励向量\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.getImpedanceMatAndExciteV-Tuple{Any, Vector, Any}","page":"API","title":"MoM_Kernels.getImpedanceMatAndExciteV","text":"根据几何信息与基函数数量，计算阻抗矩阵和激励向量 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 bfsInfo::   基函数信息 source::    激励源 返回： Zmat::      阻抗矩阵 V::         激励向量\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.getImpedanceMatrix-Union{Tuple{ST}, Tuple{Vector{ST}, Integer}} where ST<:SurfaceCellType","page":"API","title":"MoM_Kernels.getImpedanceMatrix","text":"根据几何信息与基函数数量，计算阻抗矩阵 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 nbf::       基函数数量 返回： Zmat\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.getImpedanceOpt-Tuple{Any, Any}","page":"API","title":"MoM_Kernels.getImpedanceOpt","text":"根据几何信息与基函数数量，计算阻抗矩阵算子 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 nbf::       基函数数量 source::    激励源 返回： Zopt::      阻抗矩阵算子，由近场稀疏矩阵和远场八叉树聚合、转移、解聚组成 V::         激励向量 Octree::    八叉树 Znear::  阻抗矩阵近场元\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.getImpedanceOptAndExciteVOctree-Tuple{Any, Any, Any}","page":"API","title":"MoM_Kernels.getImpedanceOptAndExciteVOctree","text":"根据几何信息与基函数数量，计算阻抗矩阵算子和激励向量 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 nbf::       基函数数量 source::    激励源 返回： Zopt::      阻抗矩阵算子，由近场稀疏矩阵和远场八叉树聚合、转移、解聚组成 V::         激励向量 Octree::    八叉树 Znear::  阻抗矩阵近场元\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.getLeafCubeL-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:HexahedraInfo","page":"API","title":"MoM_Kernels.getLeafCubeL","text":"六面体从网格平均尺寸设置整体的叶层盒子边长\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.getLeafCubeL-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:TetrahedraInfo","page":"API","title":"MoM_Kernels.getLeafCubeL","text":"四面体从网格平均尺寸设置整体的叶层盒子边长\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.getLeafCubeL-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:TriangleInfo","page":"API","title":"MoM_Kernels.getLeafCubeL","text":"三角形面网格直接设置为的叶层盒子边长\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.getLeafCubeL-Union{Tuple{Vector{T}}, Tuple{T}} where T<:(AbstractVector)","page":"API","title":"MoM_Kernels.getLeafCubeL","text":"混合网格从第2类里的网格平均尺寸设置整体的叶层盒子边长\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.getMeshDataSaveGeosInterval-Tuple{Any}","page":"API","title":"MoM_Kernels.getMeshDataSaveGeosInterval","text":"getMeshDataSaveGeosInterval(filename[; meshUnit=:mm, dir = \"temp/GeosInfo\"])\n\n在获取网格数据 meshData 和介电参数 εᵣs 的同时保存网格数据 meshData 中各类型网格的区间。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.getNeiFarNeighborCubeIDs-Tuple{Any, Tuple}","page":"API","title":"MoM_Kernels.getNeiFarNeighborCubeIDs","text":"getNeiFarNeighborCubeIDs(cubes, chunkIndice::Tuple)\n\n获取 ckunkIndice 内的所有 cubes 的 远亲盒子 序号， 返回为 Tuple 形式以适应数组索引相关 API。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.getNeighborCubeIDs-Tuple{Any, Tuple}","page":"API","title":"MoM_Kernels.getNeighborCubeIDs","text":"getNeighborCubeIDs(cubes, chunkIndice::Tuple)\ngetNeighborCubeIDs(cubes, chunkIndice::AbstractVector)\n\n获取 ckunkIndice 内的所有 cubes 的 邻盒子 编号， 返回为 Tuple 形式以适应数组索引相关API\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.getOctreeAndReOrderBFs!-Tuple{Any, Any}","page":"API","title":"MoM_Kernels.getOctreeAndReOrderBFs!","text":"根据基函数中心位置构建八叉树，并重排基函数信息、将新基函数 ID 赋值给几何元信息数组 返回值： nLevels::   层数 octree::    得到的八叉树 leafCubeEdgel:: 控制叶层盒子大小 isDistribute:: 控制是否为分布式计算\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.get_Interpolation_Method-Tuple{Symbol}","page":"API","title":"MoM_Kernels.get_Interpolation_Method","text":"get_Interpolation_Method(method::Symbol)\nget_Interpolation_Method(method::Union{Val{:Lagrange2Step}, Val{:Lagrange1Step}})\n\n获取插值算法。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.get_chunks_minmax_col-Tuple{Any}","page":"API","title":"MoM_Kernels.get_chunks_minmax_col","text":"get_chunks_minmax_col(matchunks)\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.get_leafCubeSize-Tuple{}","page":"API","title":"MoM_Kernels.get_leafCubeSize","text":"获取叶层盒子边长\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.get_partition-Tuple{Any, Any, Any}","page":"API","title":"MoM_Kernels.get_partition","text":"get_partition(nCubes, sizePoles, np)\n\n根据给定的盒子数 nCubes 、多极子数 sizePoles、进程数 np 返回该层辐射函数的三个维度的划分数量。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.get_partition_map-Tuple{Any, Any}","page":"API","title":"MoM_Kernels.get_partition_map","text":"get_partition_map(partition, kcubeIndices)\n\n根据 partition 计算在盒子方向本层所有 rank 到子层所有 rank 的 map 。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.gq_xsws_on_sphere-Tuple{Any}","page":"API","title":"MoM_Kernels.gq_xsws_on_sphere","text":"gq_xsws_on_sphere(L)\n\n计算单位球面 2(L+1) 阶高斯求积的采样点坐标权重\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.greenfunc_star-Union{Tuple{T}, Tuple{StaticArraysCore.StaticArray{Tuple{3}, T, 1}, StaticArraysCore.StaticArray{Tuple{3}, T, 1}}} where T<:AbstractFloat","page":"API","title":"MoM_Kernels.greenfunc_star","text":"greenfunc_star(pa::Vec3D{T}, pb::Vec3D{T}[; k=Params.K_0, taylorOrder = SglrOrder]) where {T<:AbstractFloat}\n\n归一化格林函数 4πG(R) 泰勒展开后去奇异项：\n\ng^*(R)    = frace^-jkRR - frac1R\n            = sum_n=1^SglrOrderfrac-jk^nnR^n-1\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.iluPrecondition-Tuple{Any, Any}","page":"API","title":"MoM_Kernels.iluPrecondition","text":"iluPrecondition(A, level; τ = 1e-3)\n\n从 (IncompleteLU.jl)[https://github.com/haampie/IncompleteLU.jl.git]  包实现ilu, 再次封装是因为要加入一些判断\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.impedancemat4CFIE4PEC-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{TriangleInfo{IT, FT}, 1}, Integer, Type{BFT}}} where {IT, FT, BFT<:RWG}","page":"API","title":"MoM_Kernels.impedancemat4CFIE4PEC","text":"本函数用于计算PEC的CFIE阻抗矩阵。 输入信息： trianglesInfo:  为包含三角形信息实例的向量 nrwg        :  基函数数目 返回值 Zmat         :  阻抗矩阵\n\n注意，此程序由于采用的对三角形循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.impedancemat4EFIE4PEC!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{Complex{FT}, 2}, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT, FT, BFT<:RWG}","page":"API","title":"MoM_Kernels.impedancemat4EFIE4PEC!","text":"本函数用于在有矩阵的情况下计算PEC的EFIE阻抗矩阵。 输入信息： Zmat trianglesInfo:  为包含三角形信息实例的向量 nrwg        :  基函数数目 返回值 Zmat         :  阻抗矩阵\n\n注意，此程序由于采用的对三角形循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.impedancemat4EFIE4PEC-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{TriangleInfo{IT, FT}, 1}, Integer, Type{BFT}}} where {IT, FT, BFT<:RWG}","page":"API","title":"MoM_Kernels.impedancemat4EFIE4PEC","text":"本函数用于计算PEC的EFIE阻抗矩阵。 输入信息： trianglesInfo:  为包含三角形信息实例的向量 nrwg        :  基函数数目 返回值 Zmat         :  阻抗矩阵\n\n注意，此程序由于采用的对三角形循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.impedancemat4MFIE4PEC-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{TriangleInfo{IT, FT}, 1}, Integer, Type{BFT}}} where {IT, FT, BFT<:RWG}","page":"API","title":"MoM_Kernels.impedancemat4MFIE4PEC","text":"本函数用于计算PEC的MFIE阻抗矩阵。 输入信息： trianglesInfo:  为包含三角形信息实例的向量 nrwg        :  基函数数目 返回值 Zmat         :  阻抗矩阵\n\n注意，此程序由于采用的对三角形循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.impedancemat4RWGPWC!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Any}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.impedancemat4RWGPWC!","text":"RWG + PWC 部分的阻抗矩阵\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.impedancemat4RWGPWC!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Any}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.impedancemat4RWGPWC!","text":"RWG + PWC 部分的阻抗矩阵\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.impedancemat4RWGRBF!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.impedancemat4RWGRBF!","text":"RWG + RBF 部分的阻抗矩阵\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.impedancemat4RWGSWG!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.impedancemat4RWGSWG!","text":"RWG + SWG 部分的阻抗矩阵\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT<:PWC}","page":"API","title":"MoM_Kernels.impedancemat4VIE!","text":"本函数用于计算介质体的 PWC 基函数下的 EFIE 阻抗矩阵。 输入信息： hexasInfo::AbstractVector{HexahedraInfo{IT, FT, CT}},  为包含六面体信息实例的向量 tetrasInfo::AbstractVector{TetrahedraInfo{IT, FT, CT}}, 为包含四面体信息实例的向量 nPWC        :  基函数数目 返回值 Zmat        :  阻抗矩阵\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT<:PWC}","page":"API","title":"MoM_Kernels.impedancemat4VIE!","text":"本函数用于计算介质体的 PWC 基函数下的 EFIE 阻抗矩阵。 输入信息： hexasInfo  :  为包含六面体信息实例的向量 nrwg        :  基函数数目 返回值 Zmat        :  阻抗矩阵\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT<:RBF}","page":"API","title":"MoM_Kernels.impedancemat4VIE!","text":"本函数用于计算介质的EFIE阻抗矩阵。 输入信息： hexasInfo  :  为包含六面体信息实例的向量 nrbf        :  基函数数目 返回值 Zmat         :  阻抗矩阵\n\n注意，此程序由于采用的对六面体循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT<:PWC}","page":"API","title":"MoM_Kernels.impedancemat4VIE!","text":"本函数用于计算介质体的 PWC 基函数下的 EFIE 阻抗矩阵。 输入信息： hexasInfo::AbstractVector{HexahedraInfo{IT, FT, CT}},  为包含六面体信息实例的向量 tetrasInfo::AbstractVector{TetrahedraInfo{IT, FT, CT}}, 为包含四面体信息实例的向量 nPWC        :  基函数数目 返回值 Zmat        :  阻抗矩阵\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT<:PWC}","page":"API","title":"MoM_Kernels.impedancemat4VIE!","text":"本函数用于计算介质体的 PWC 基函数下的 EFIE 阻抗矩阵。 输入信息： tetrasInfo  :  为包含四面体信息实例的向量 nrwg        :  基函数数目 返回值 Zmat        :  阻抗矩阵\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT<:SWG}","page":"API","title":"MoM_Kernels.impedancemat4VIE!","text":"本函数用于计算介质的 EFIE 阻抗矩阵。 输入信息： Zmat       :   已初始化的阻抗矩阵 tetrasInfo  :  为包含四面体信息实例的向量 nswg        :  基函数数目 返回值 Zmat         :  阻抗矩阵\n\n注意，此程序由于采用的对四面体循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT<:PWC}","page":"API","title":"MoM_Kernels.impedancemat4VIE","text":"本函数用于计算介质体的 PWC 基函数下的 EFIE 阻抗矩阵。 输入信息： hexasInfo  :  为包含六面体信息实例的向量 nPWC        :  基函数数目 返回值 Zmat        :  阻抗矩阵\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT<:RBF}","page":"API","title":"MoM_Kernels.impedancemat4VIE","text":"本函数用于计算介质的EFIE阻抗矩阵。 输入信息： hexasInfo  :  为包含六面体信息实例的向量 nrbf        :  基函数数目 返回值 Zmat         :  阻抗矩阵\n\n注意，此程序由于采用的对六面体循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT<:PWC}","page":"API","title":"MoM_Kernels.impedancemat4VIE","text":"本函数用于计算介质体的 PWC 基函数下的 EFIE 阻抗矩阵。 输入信息： tetrasInfo  :  为包含四面体信息实例的向量 nrwg        :  基函数数目 返回值 Zmat        :  阻抗矩阵\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT<:SWG}","page":"API","title":"MoM_Kernels.impedancemat4VIE","text":"本函数用于计算介质的EFIE阻抗矩阵。 输入信息： tetrasInfo  :  为包含四面体信息实例的向量 nswg        :  基函数数目 返回值 Zmat         :  阻抗矩阵\n\n注意，此程序由于采用的对四面体循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{VT}, Tuple{AbstractVector{VT}, Integer, Type{BFT}}} where {VT<:(AbstractVector), BFT<:PWC}","page":"API","title":"MoM_Kernels.impedancemat4VIE","text":"本函数用于计算混合网格（四面体+六面体）下介质体的 PWC 基函数下的 EFIE 阻抗矩阵。 输入信息： geosInfo    :  为包含四面体信息实例的向量 nPWC        :  基函数数目 返回值 Zmat        :  阻抗矩阵\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.impedancemat4VSIE-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT<:(AbstractVector)","page":"API","title":"MoM_Kernels.impedancemat4VSIE","text":"计算VSIE的矩阵\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.impedancemat4VSIERWGPWC-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT<:(AbstractVector)","page":"API","title":"MoM_Kernels.impedancemat4VSIERWGPWC","text":"本函数用于计算金属介质混合体的EFIE阻抗矩阵。 输入信息： geosInfo    :  为包含几何体信息实例的向量 nbf        :  基函数数目 返回值 Zmat         :  阻抗矩阵\n\n注意，此程序由于采用的对网格元（几何体）循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.impedancemat4VSIERWGRBF-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT<:(AbstractVector)","page":"API","title":"MoM_Kernels.impedancemat4VSIERWGRBF","text":"本函数用于计算金属介质混合体的EFIE阻抗矩阵。 输入信息： geosInfo    :  为包含几何体信息实例的向量 nbf        :  基函数数目 返回值 Zmat         :  阻抗矩阵\n\n注意，此程序由于采用的对网格元（几何体）循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.impedancemat4VSIERWGSWG-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT<:(AbstractVector)","page":"API","title":"MoM_Kernels.impedancemat4VSIERWGSWG","text":"本函数用于计算金属介质混合体的EFIE阻抗矩阵。 输入信息： geosInfo    :  为包含几何体信息实例的向量 nbf        :  基函数数目 返回值 Zmat         :  阻抗矩阵\n\n注意，此程序由于采用的对网格元（几何体）循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.initialVMulZchunks!-Tuple{T} where T<:MoM_Kernels.ZnearChunksStruct","page":"API","title":"MoM_Kernels.initialVMulZchunks!","text":"initialVMulZchunks!(Z::T) where{T<:ZnearChunksStruct}\n\n初始化 阻抗矩阵 右乘 向量 乘积的 分布式数组\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.initialZchunksMulV!-Tuple{T} where T<:MoM_Kernels.ZnearChunksStruct","page":"API","title":"MoM_Kernels.initialZchunksMulV!","text":"initialZchunksMulV!(Z::T) where{T<:ZnearChunksStruct}\n\n初始化 阻抗矩阵 左乘 向量 乘积的 分布式数组。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.initialZnearCSC-Tuple{Any, Int64}","page":"API","title":"MoM_Kernels.initialZnearCSC","text":"initialZnearCSC(level, nbf::Int)\n\n根据八叉树层信息 level 初始化近场阻抗矩阵。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.initialZnearCSR-Tuple{Any, Int64}","page":"API","title":"MoM_Kernels.initialZnearCSR","text":"initialZnearCSR(level, nbf::Int)\n\n根据八叉树层信息 level 初始化近场阻抗矩阵，用 transpose 实现 CSR 压缩稀疏行。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.initialZnearChunks-Tuple{Any, AbstractVector}","page":"API","title":"MoM_Kernels.initialZnearChunks","text":"initialZnearChunks(cube, cubes::AbstractVector; CT = Complex{Precision.FT})\n\n根据八叉树某个盒子 cube 信息初始化 cube 对应的近场矩阵元块。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.inputParameters-Tuple{}","page":"API","title":"MoM_Kernels.inputParameters","text":"inputParameters(;args...)\n\n用于输入仿真参数，并修改奇异性处理中频率相关常量。 详见 [MoM_Basics.inputBasicParameters] 和 modiSingularityRelatedConsts!。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.integral1DXW-Union{Tuple{FT}, Tuple{IT}, Tuple{FT, FT, IT, Symbol}} where {IT<:Integer, FT<:Real}","page":"API","title":"MoM_Kernels.integral1DXW","text":"计算分别采用高斯求积、中点求积计算 θ,ϕ 方向的采样点的坐标、权重 lb::FT，  积分区域下界 hb::FT,   积分区域上界 Nsample::IT, 采样点数 mod::Symbol， 模式，接受 :uni, 均值积分 :glq, 高斯-勒让德积分 两种模式\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.interpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}","page":"API","title":"MoM_Kernels.interpolate!","text":"拉格朗日单步插值\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.interpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}","page":"API","title":"MoM_Kernels.interpolate!","text":"拉格朗日分步插值\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.interpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}","page":"API","title":"MoM_Kernels.interpolate","text":"拉格朗日单步插值\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.interpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}","page":"API","title":"MoM_Kernels.interpolate","text":"拉格朗日分步插值\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.interpolationCSCMatCal-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.GLPolesInfo{FT}, MoM_Kernels.GLPolesInfo{FT}, IT}} where {IT<:Integer, FT<:Real}","page":"API","title":"MoM_Kernels.interpolationCSCMatCal","text":"采用局部插值、两步插值法，计算局部坐标到全局坐标的稀疏插值矩阵，Julia数据存储为列主的，因此使用 压缩稀疏列(Compressed Sparse Column, CSC) pLevelPoles::GLPolesInfo{FT}， 父层多极子信息 tLevelPoles::GLPolesInfo{FT}， 本层多极子信息\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.iterSolverSet-Tuple{Symbol}","page":"API","title":"MoM_Kernels.iterSolverSet","text":"迭代求解器选择\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.levelIntegralInfoCal-Union{Tuple{FT}, Tuple{FT, Union{Val{:Lagrange2Step}, Val{:Lagrange1Step}}}} where FT<:Real","page":"API","title":"MoM_Kernels.levelIntegralInfoCal","text":"计算八叉树的积分相关信息，包括截断项、各层积分点和求积权重数据 输入: levelCubeEdgel::FT,  层盒子边长, 一般叶层为0.25λ，其中 λ 为区域局部波长。 返回值 L           ::IT， 层 截断项 levelsPoles ::Vector{GLPolesInfo{FT}}，从叶层到第 “2” 层的角谱空间采样信息\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.loadCurrent-Tuple{Any}","page":"API","title":"MoM_Kernels.loadCurrent","text":"读取电流系数\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.loadGeoInterval-Tuple{Any}","page":"API","title":"MoM_Kernels.loadGeoInterval","text":"set_geosInterval!(fn)\n\n载入文件 fn 读取网格数据区间。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.memoryAllocationOnLevels!-Union{Tuple{LV}, Tuple{IT}, Tuple{Integer, Dict{IT, LV}}} where {IT<:Integer, LV<:MoM_Kernels.LevelInfo}","page":"API","title":"MoM_Kernels.memoryAllocationOnLevels!","text":"预分配各层上的聚合项、解聚项\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.modiSingularityRelatedConsts!-Tuple{}","page":"API","title":"MoM_Kernels.modiSingularityRelatedConsts!","text":"用于输入参数（特指频率）改变时的更改相关常数项\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.octreeXWNCal-Union{Tuple{FT}, Tuple{IT}, Tuple{FT, FT, IT, Symbol}} where {IT<:Integer, FT<:Real}","page":"API","title":"MoM_Kernels.octreeXWNCal","text":"计算各层八叉树求积坐标、求积权重 lb::FT，  积分区域下界 hb::FT,   积分区域上界 nlevels::IT, 八叉树叶层ID mod::Symbol， 模式，接受 :uni, 均值积分(ϕ方向) :glq, 高斯-勒让德积分(θ方向) 两种模式\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.pickCycleVec-Union{Tuple{T}, Tuple{Integer, Vector{T}}} where T<:Real","page":"API","title":"MoM_Kernels.pickCycleVec","text":"根据循环向量 cycleVec 的周期性索引超出上下界的 index 对应的值\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.pickθ-Union{Tuple{T}, Tuple{Integer, Vector{T}}} where T<:Real","page":"API","title":"MoM_Kernels.pickθ","text":"利用 θ 在极点附近的对称性计算索引超出上下界的 θ 值\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.pickϕ-Union{Tuple{TT}, Tuple{Integer, Vector{TT}}} where TT<:Real","page":"API","title":"MoM_Kernels.pickϕ","text":"利用 ϕ 的周期性索引超出上下界的 ϕ 值\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.radarCrossSection-Union{Tuple{BFT}, Tuple{CT}, Tuple{VT}, Tuple{Any, Any, Vector{CT}, Vector{VT}}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Type{BFT}}} where {VT<:VolumeCellType, CT<:Complex, BFT<:BasisFunctionType}","page":"API","title":"MoM_Kernels.radarCrossSection","text":"在球坐标为r̂θϕ处计算辐射积分，采用SWG基函数时，四面体上没有统一的电流值，每一点上都是四个SWG基函数电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙsₙρₙ/(3Vₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙsₙρₙ/3)exp(jkr̂(θ, ϕ)⋅rₙ) )\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.radarCrossSection-Union{Tuple{BFT}, Tuple{ST}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{ST}}, Tuple{Any, Any, Vector{CT}, Vector{ST}, Type{BFT}}} where {CT<:Complex, ST<:TriangleInfo, BFT<:RWG}","page":"API","title":"MoM_Kernels.radarCrossSection","text":"在球坐标为r̂θϕ处计算辐射积分，采用RWG基函数时，三角形上没有统一的电流值，每一点上都是三边电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙlₙρₙ/(2Sₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙlₙρₙ/2)exp(jkr̂(θ, ϕ)⋅rₙ) )\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.radarCrossSection-Union{Tuple{VT}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{VT}}} where {CT<:Complex, VT<:(AbstractVector)}","page":"API","title":"MoM_Kernels.radarCrossSection","text":"在球坐标为r̂θϕ处计算辐射积分，采用SWG基函数时，四面体上没有统一的电流值，每一点上都是四个SWG基函数电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙsₙρₙ/(3Vₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙsₙρₙ/3)exp(jkr̂(θ, ϕ)⋅rₙ) )\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.raditionalIntegralNCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Array{TriangleInfo{IT, FT}, 1}, Array{CT}}} where {IT<:Integer, FT<:Real, CT<:Complex}","page":"API","title":"MoM_Kernels.raditionalIntegralNCal","text":"在设定好的观测角度上的球坐标处计算辐射积分，采用RWG基函数时，三角形上没有统一的电流值，每一点上都是三边电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙlₙρₙ/(2Sₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙlₙρₙ/2)exp(jkr̂(θ, ϕ)⋅rₙ) )\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Matrix{CT}}} where {IT<:Integer, FT<:Real, CT<:Complex}","page":"API","title":"MoM_Kernels.raditionalIntegralNθϕCal","text":"在球坐标为r̂θϕ处计算辐射积分，采用 RBF 基函数时，六面体上没有统一的电流值 N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dV)\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Matrix{CT}}} where {IT<:Integer, FT<:Real, CT<:Complex}","page":"API","title":"MoM_Kernels.raditionalIntegralNθϕCal","text":"在球坐标为r̂θϕ处计算辐射积分，采用 SWG 基函数时，四面体上没有统一的电流值，每一点上都是四面电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dV)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁⁴ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dV)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁⁴ IₙSₙρₙ/(3Vₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁⁴ IₙSₙρₙ/3)exp(jkr̂(θ, ϕ)⋅rₙ) )\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, Array{TriangleInfo{IT, FT}, 1}, Array{CT, 3}}} where {IT<:Integer, FT<:Real, CT<:Complex}","page":"API","title":"MoM_Kernels.raditionalIntegralNθϕCal","text":"在球坐标为r̂θϕ处计算辐射积分，采用RWG基函数时，三角形上没有统一的电流值，每一点上都是三边电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙlₙρₙ/(2Sₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙlₙρₙ/2)exp(jkr̂(θ, ϕ)⋅rₙ) )\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, Array{TriangleInfo{IT, FT}, 1}, Matrix{CT}}} where {IT<:Integer, FT<:Real, CT<:Complex}","page":"API","title":"MoM_Kernels.raditionalIntegralNθϕCal","text":"在球坐标为r̂θϕ处计算辐射积分，采用RWG基函数时，三角形上没有统一的电流值，每一点上都是三边电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙlₙρₙ/(2Sₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙlₙρₙ/2)exp(jkr̂(θ, ϕ)⋅rₙ) )\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.reOrderBasisFunctionAndGeoInfo!-Union{Tuple{VCellT}, Tuple{BFT}, Tuple{IT}, Tuple{Vector{IT}, Vector{VCellT}, Vector{BFT}}} where {IT<:Integer, BFT<:BasisFunctionType, VCellT<:VSCellType}","page":"API","title":"MoM_Kernels.reOrderBasisFunctionAndGeoInfo!","text":"根据按八叉树重新排序的id重排基函数信息\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.reOrderBasisFunctionAndGeoInfo!-Union{Tuple{VCellT}, Tuple{IT}, Tuple{Vector{IT}, Vector{VCellT}, Val{:PWC}}} where {IT<:Integer, VCellT<:VSCellType}","page":"API","title":"MoM_Kernels.reOrderBasisFunctionAndGeoInfo!","text":"根据按八叉树重新排序的id重排基函数信息，此函数适用于 PWC 基函数的情况\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.reOrderBasisFunctionAndGeoInfo!-Union{Tuple{VT2}, Tuple{VT1}, Tuple{IT}, Tuple{Vector{IT}, Vector{VT1}, Vector{VT2}}} where {IT<:Integer, VT1<:(AbstractVector), VT2<:(AbstractVector)}","page":"API","title":"MoM_Kernels.reOrderBasisFunctionAndGeoInfo!","text":"根据按八叉树重新排序的id重排基函数信息\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.reOrderCubeID!-Union{Tuple{LV}, Tuple{Integer, Dict{Int64, LV}, Dict{Int64, Vector{Int64}}}} where LV<:MoM_Kernels.AbstractLevel","page":"API","title":"MoM_Kernels.reOrderCubeID!","text":"根据排序后的新id重新排列子层盒子以及盒子的邻盒子信息，以将同一个父盒子层的盒子相邻排列，这样有利于计算 更新的量：父层盒子的kidsInterval， 本层的盒子顺序，本层盒子的邻盒子id\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.record_memorys-Tuple{Any}","page":"API","title":"MoM_Kernels.record_memorys","text":"展示\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.restore_infos-Tuple{}","page":"API","title":"MoM_Kernels.restore_infos","text":"restore_infos()\n记录各部分内存和各阶段计算时间。\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.saveCubes-Tuple{Any, Any}","page":"API","title":"MoM_Kernels.saveCubes","text":"saveCubes(cubes[, nchunk = ParallelParams.nprocs; name, dir=\"\", kcubeIndices = nothing])\n\n将盒子 cubes 分为 nchunk 块以 name 为名保存在 dir中。kcubeIndices 同于计算不同分区间重复的部分。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.saveCurrent-Tuple{Any}","page":"API","title":"MoM_Kernels.saveCurrent","text":"保存电流系数\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.saveGeoInterval-Tuple{Any}","page":"API","title":"MoM_Kernels.saveGeoInterval","text":"saveGeoInterval(meshData[; dir = \"temp/GeosInfo\"])\n\n保存网格数据 meshData 中各类型网格的区间。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.saveGeosInfoChunks-Tuple{AbstractVector, Any, AbstractString, Int64}","page":"API","title":"MoM_Kernels.saveGeosInfoChunks","text":"saveGeosInfoChunks(geos::AbstractVector, cubes, name::AbstractString, nchunk::Int[; dir = \"\", cubes_ChunksIndices = sizeChunks2idxs(length(cubes), nchunk)])\n\n将几何信息 geos 根据分块数量 nchunk 和在 cubes 中的分布进行分块并保存。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.saveLevel","page":"API","title":"MoM_Kernels.saveLevel","text":"saveLevel(level[, np = ParallelParams.nprocs; dir=\"\", kcubeIndices = nothing])\n\n将层 level 信息保存，其中的盒子信息由 get_partition 计算的分块信息部分保存。\n\n\n\n\n\n","category":"function"},{"location":"api/#MoM_Kernels.saveOctree-Tuple{Any}","page":"API","title":"MoM_Kernels.saveOctree","text":"saveOctree(octree[; dir=\"\"])\n\n将八叉树 octree 保存在 dir 中。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.saveVec2Chunks-Tuple{AbstractVector, AbstractString, Any}","page":"API","title":"MoM_Kernels.saveVec2Chunks","text":"saveVec2Chunks(y::AbstractVector, name::AbstractString, indices[; dir = \"\", showpmeter = false, message = \"\"])\n\n把向量 y 以 name 按索引 indices 块保存在 dir 文件夹中。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.saveVec2Chunks-Tuple{AbstractVector, AbstractString, Int64}","page":"API","title":"MoM_Kernels.saveVec2Chunks","text":"saveVec2Chunks(y::AbstractVector, name::AbstractString, nchunk::Int[; dir = \"\"])\n\n把向量 y 以 name 分为 nchunk 块保存在 dir 文件夹中。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.searchNearCubes-Union{Tuple{IT}, Tuple{Matrix{IT}, Integer}} where IT<:Integer","page":"API","title":"MoM_Kernels.searchNearCubes","text":"用于寻找邻盒子的函数 输入 cubesID3D::Matrix{Int}，(n×3)盒子在本层的三维坐标 levelID::Integer       层编号，（定义大盒子为（“0” 层），叶层为第“n”层\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.setBFInterval!-Union{Tuple{LV}, Tuple{Integer, Dict{Int64, LV}}} where LV<:MoM_Kernels.AbstractLevel","page":"API","title":"MoM_Kernels.setBFInterval!","text":"根据已经排序好的层的盒子信息，从叶层到顶层更新盒子包含的基函数区间\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.setBigCube-Union{Tuple{FT}, Tuple{Matrix{FT}, FT}} where FT<:Real","page":"API","title":"MoM_Kernels.setBigCube","text":"计算包围目标的大盒子信息 输入： nodes::Matrix{FT}，大小为 (3, n) 的用于分割成八叉树的空间点，如基函数的中心坐标，或者为构成网格的所有点 leafCubeEdgel::FT，叶层盒子边长，用于计算总层数和大盒子的坐标信息\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.setGeoIDsInLeafCubes!-Union{Tuple{CBF}, Tuple{Any, Vector{CBF}}} where CBF<:ConstBasisFunction","page":"API","title":"MoM_Kernels.setGeoIDsInLeafCubes!","text":"用于设置给定层的盒子中包含的几何体，采用常数基函数时，同一个盒子不会出现重复值。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.setGeoIDsInLeafCubes!-Union{Tuple{LBF}, Tuple{Any, Vector{LBF}}} where LBF<:LinearBasisFunction","page":"API","title":"MoM_Kernels.setGeoIDsInLeafCubes!","text":"用于设置给定层的盒子中包含的几何体，采用 RWG、SWG、RBF 基函数时，八叉树分组依据为基函数， 同一个几何体会被分在不同的基函数上会被分入入不同的盒子，因此邻盒子中的几何体 id 大概率出现重复值。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.setGeoIDsInLeafCubes!-Union{Tuple{VT}, Tuple{Any, Vector{VT}}} where VT<:(AbstractVector)","page":"API","title":"MoM_Kernels.setGeoIDsInLeafCubes!","text":"用于设置给定层的盒子中包含的几何体，采用 RWG、SWG、RBF 基函数时，八叉树分组依据为基函数， 同一个几何体会被分在不同的基函数上会被分入入不同的盒子，因此邻盒子中的几何体 id 大概率出现重复值。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.setKidLevelFarNeighbors!-Tuple{Any, Any}","page":"API","title":"MoM_Kernels.setKidLevelFarNeighbors!","text":"寻找子层的远亲盒子 输入:: thisLevel::LevelInfo{IT, FT, IPT}, 本层信息 kidLevel::LevelInfo{IT, FT, IPT}， 子层信息\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.setLevelInfo!-Union{Tuple{FT}, Tuple{Integer, Any, FT, StaticArraysCore.StaticArray{Tuple{3}, FT, 1}}} where FT<:Real","page":"API","title":"MoM_Kernels.setLevelInfo!","text":"非叶层LevelInfo的构造函数，输入为空间三维坐标数组 levelID::计算层的id leafnodes::Matrix{FT},大小为 (3, n) 的用于分割成八叉树的空间点，如基函数的中心坐标 cubeEdgel::FT，本层盒子边长\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.setLevelInfo!-Union{Tuple{FT}, Tuple{Integer, Matrix{FT}, FT, StaticArraysCore.StaticArray{Tuple{3}, FT, 1}}} where FT<:Real","page":"API","title":"MoM_Kernels.setLevelInfo!","text":"setLevelInfo!(nLevels::Integer, leafnodes::Matrix{FT},cubeEdgel::FT, bigCubeLowerCoor::Vec3D{FT}[; \n                IPT = get_Interpolation_Method(MLFMAParams.InterpolationMethod), LT = LevelInfo]) where{FT<:Real}\n\n叶层 LevelInfo 的构造函数，输入信息：\n\nnLevels::IT                 层数，亦为叶层层ID\nleafnodes::Matrix{FT}       大小为 (3, n) 的用于分割成八叉树的空间点，如基函数的中心坐标\ncubeEdgel::FT               叶层盒子边长\nbigCubeLowerCoor::Vec3D{FT} 大盒子的角坐标\nIPT                         插值算法类型\nLT = LevelInfo              层类\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.setLevelTransFactor!-Union{Tuple{LV}, Tuple{Int64, Dict{Int64, LV}}} where LV<:MoM_Kernels.AbstractLevel","page":"API","title":"MoM_Kernels.setLevelTransFactor!","text":"计算 第“2”层 到 叶 层的转移因子， 转移因子只存在于远亲组，每层远亲组最多有 7^3 - 3^3 = 316种结果\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.setLevelsCubesKidsIn8!-Union{Tuple{LV}, Tuple{Integer, Dict{Int64, LV}}} where LV<:MoM_Kernels.AbstractLevel","page":"API","title":"MoM_Kernels.setLevelsCubesKidsIn8!","text":"计算（nLevel-1）-2 层每层的非空盒子的非空子盒子在其8个子盒子中的位置\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.setLevelsShiftFactor!-Union{Tuple{LV}, Tuple{Int64, Dict{Int64, LV}}} where LV<:MoM_Kernels.AbstractLevel","page":"API","title":"MoM_Kernels.setLevelsShiftFactor!","text":"本函数用于给输入的本(level)层的盒子与其子盒子之间计算相移因子， 由盒子排列的规律性和相移因子的对称性，可知： 只需要计算8个相移因子，即可用于所有盒子到其子盒子的相移， 且这八个盒子关于原点对称的两两之间的相移因子为共轭关系 计算完成直接保存在 level 不再返回\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.setVSC₁₂₃ⁿ!-Tuple{}","page":"API","title":"MoM_Kernels.setVSC₁₂₃ⁿ!","text":"setVSC₁₂₃ⁿ!()\n\n计算体奇异性三个系数。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.set_Interpolation_Method!-Tuple{Any}","page":"API","title":"MoM_Kernels.set_Interpolation_Method!","text":"设置插值算法\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.set_geosInterval!-Tuple{Any}","page":"API","title":"MoM_Kernels.set_geosInterval!","text":"set_geosInterval!(fn)\n\n通过文件 fn 设置网格数据区间。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.set_leafCubeSize!-Union{Tuple{}, Tuple{FT}} where FT<:AbstractFloat","page":"API","title":"MoM_Kernels.set_leafCubeSize!","text":"设置叶层盒子边长\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.set_nprocs!-Tuple{}","page":"API","title":"MoM_Kernels.set_nprocs!","text":"set_nprocs!([;nprocs=1, np=nprocs])\n\n设置并行核心数量为 nprocs 。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.singularF1-Union{Tuple{FT}, NTuple{4, FT}} where FT<:AbstractFloat","page":"API","title":"MoM_Kernels.singularF1","text":"singularF1(a::FT, b::FT, c::FT, d::FT) where{FT<:AbstractFloat}\n\n计算边长为a, b, c, d的四边形重合时的奇异性F1项，即 intintfrac1RdS 的解析值。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.singularF1-Union{Tuple{FT}, Tuple{FT, FT, FT}} where FT<:AbstractFloat","page":"API","title":"MoM_Kernels.singularF1","text":"singularF1(a::FT, b::FT, c::FT) where{FT<:AbstractFloat}\n\n计算边长为a, b, c的三角形重合时的奇异性F1项，即 intintfrac1RdS 的解析值。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.singularF21-Union{Tuple{FT}, NTuple{4, FT}} where FT<:AbstractFloat","page":"API","title":"MoM_Kernels.singularF21","text":"singularF21(a::FT, b::FT, c::FT, area2::FT) where{FT<:AbstractFloat}\n\n计算边长为a, b, c，面积平方为area2的三角形重合时的奇异性F2项，即 intintfracboldsymbolrho_mcdotboldsymbolrho_nRdS 的解析值，该函数处理 m==n 即基函数自作用的情况。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.singularF22-Union{Tuple{FT}, NTuple{4, FT}} where FT<:AbstractFloat","page":"API","title":"MoM_Kernels.singularF22","text":"singularF21(a::FT, b::FT, c::FT, area2::FT) where{FT<:AbstractFloat}\n\n计算边长为a, b, c，面积平方为area2的三角形重合时的奇异性F2项，即 intintfracboldsymbolrho_mcdotboldsymbolrho_nRdS 的解析值，该函数处理 m!=n 即同一三角形的不同基函数作用的情况。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.sizeChunks2cuts-Tuple{Any, Any}","page":"API","title":"MoM_Kernels.sizeChunks2cuts","text":"sizeChunks2cuts(Asize, chunks)\nsizeChunks2cuts(Asize::Int, chunks)\nsizeChunks2cuts(Asize, chunks::Int)\nsizeChunks2cuts(Asize::Int, chunks::Int)\n\n将数组大小 Asize 按 chunks 进行分块。 从 MPIArray4MoMs 借的！ 为的是避免提前引入 MPI 导致在集群上的 bug。因此该函数的修改必须与  MPIArray4MoMs 同步。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.sizeChunks2idxs-Tuple{Any, Any}","page":"API","title":"MoM_Kernels.sizeChunks2idxs","text":"sizeChunks2idxs(Asize, nchunk)\n\nBorrowed form DistributedArray.jl, get the slice of matrix size Asize on each dimension with nchunk. 从 MPIArray4MoMs 借的！ 为的是避免提前引入 MPI 导致在集群上的 bug。因此该函数的修改必须与  MPIArray4MoMs 同步。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.sizeChunksCuts2indices-Tuple{Any, Any, Tuple}","page":"API","title":"MoM_Kernels.sizeChunksCuts2indices","text":"sizeChunksCuts2indices(Asize, nchunk, cuts::Tuple)\nsizeChunksCuts2indices(Asize, nchunk, cuts::Vector{I}) where{I<:Integer}\n\n根据数组大小 Asize 分块数量 nchunk 以及各块索引区间 cuts 计算各块的索引。 从 MPIArray4MoMs 借的！ 为的是避免提前引入 MPI 导致在集群上的 bug。因此该函数的修改必须与  MPIArray4MoMs 同步。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.slicedim2bounds-Tuple{Int64, Int64}","page":"API","title":"MoM_Kernels.slicedim2bounds","text":"slicedim2bounds(sz::Int, nc::Int)\n\n将区间 1:sz 划分为 nc 个区间并返回区间上下界。 从 MPIArray4MoMs 借的！ 为的是避免提前引入 MPI 导致在集群上的 bug。因此该函数的修改必须与  MPIArray4MoMs 同步。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.slicedim2partition-Tuple{Any, Int64}","page":"API","title":"MoM_Kernels.slicedim2partition","text":"slicedim2bounds(dims, nc::Int)\n\n将区间 dims 划分为 nc 个区间并返回区间上下界。 从 MPIArray4MoMs 借的！ 为的是避免提前引入 MPI 导致在集群上的 bug。因此该函数的修改必须与  MPIArray4MoMs 同步。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.solve!-Union{Tuple{T}, Tuple{Union{LinearMaps.LinearMap{T}, MLFMAIterator{T, VT}, AbstractMatrix{T}} where VT, AbstractVector{T}, AbstractVector{T}}} where T<:Number","page":"API","title":"MoM_Kernels.solve!","text":"矩阵方程 Ax=b 复合求解函数 输入值： A::LinearMapType{T}, b::Vector{T} solverT::Symbol  求解器类型\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.solve-Union{Tuple{T}, Tuple{Union{LinearMaps.LinearMap{T}, MLFMAIterator{T, VT}, AbstractMatrix{T}} where VT, AbstractVector{T}}} where T<:Number","page":"API","title":"MoM_Kernels.solve","text":"矩阵方程 Ax=b 复合求解函数 输入值： A::LinearMapType{T}, b::Vector{T} solverT::Symbol  求解器类型\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.sparseApproximateInversePl-Union{Tuple{CT}, Tuple{FT}, Tuple{MoM_Kernels.ZnearChunksStruct{CT}, Any}} where {FT<:Real, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.sparseApproximateInversePl","text":"sparseApproximateInversePl(ZnearChunks::ZnearChunksStruct{CT}, level; nbf = 0) where {FT<:Real, CT<:Complex{FT}}\n\n根据块状近场阻抗矩阵 ZnearChunks 和计算阻抗矩阵层的盒子信息 cubes 计算左稀疏近似逆 (Sparse Approximate Inverse (SAI)) 。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.sparseApproximateInversePl-Union{Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, AbstractVector}} where {FT<:Real, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.sparseApproximateInversePl","text":"sparseApproximateInversePl(Znear::ZnearT{CT}, cubes::AbstractVector) where {FT<:Real, CT<:Complex{FT}}\n\n根据近场阻抗矩阵 Znear 和计算阻抗矩阵层的盒子信息 cubes 计算左稀疏近似逆 (Sparse Approximate Inverse (SAI)) 。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.sparseApproximateInversePl-Union{Tuple{LT}, Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, MoM_Kernels.OctreeInfo{FT, LT}}} where {FT<:Real, CT<:Complex{FT}, LT}","page":"API","title":"MoM_Kernels.sparseApproximateInversePl","text":"sparseApproximateInversePl(Znear::ZnearT{CT}, octree::OctreeInfo{FT, LT}) where { FT<:Real, CT<:Complex{FT}, LT}\n\n根据近场阻抗矩阵 Znear 和八叉树 octree 叶层计算左稀疏近似逆 (Sparse Approximate Inverse (SAI)) 。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.sparseApproximateInversePl-Union{Tuple{LT}, Tuple{CT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, LT}} where {CT<:Complex, LT<:MoM_Kernels.AbstractLevel}","page":"API","title":"MoM_Kernels.sparseApproximateInversePl","text":"sparseApproximateInversePl(Znear::ZnearT{CT}, level::LT) where { CT<:Complex, LT <: AbstractLevel}\n\n根据近场阻抗矩阵 Znear 和计算阻抗矩阵层信息 level 计算左稀疏近似逆 (Sparse Approximate Inverse (SAI)) 。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.sparseApproximateInversePr-Union{Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, AbstractVector}} where {FT<:Real, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.sparseApproximateInversePr","text":"sparseApproximateInversePr(Znear::ZnearT{CT}, cubes::AbstractVector) where {FT<:Real, CT<:Complex{FT}}\n\n根据近场阻抗矩阵 Znear 和计算阻抗矩阵层的盒子信息 cubes 计算右稀疏近似逆 (Sparse Approximate Inverse (SAI)) 。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.sparseApproximateInversePr-Union{Tuple{LT}, Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, MoM_Kernels.OctreeInfo{FT, LT}}} where {FT<:Real, CT<:Complex{FT}, LT}","page":"API","title":"MoM_Kernels.sparseApproximateInversePr","text":"sparseApproximateInversePr(Znear::ZnearT{CT}, octree::OctreeInfo{FT, LT}) where { FT<:Real, CT<:Complex{FT}, LT}\n\n根据近场阻抗矩阵 Znear 和八叉树 octree 叶层计算右稀疏近似逆 (Sparse Approximate Inverse (SAI)) 。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.sparseApproximateInversePr-Union{Tuple{LT}, Tuple{CT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, LT}} where {CT<:Complex, LT<:MoM_Kernels.AbstractLevel}","page":"API","title":"MoM_Kernels.sparseApproximateInversePr","text":"sparseApproximateInversePr(Znear::ZnearT{CT}, level::LT) where { CT<:Complex, LT <: AbstractLevel}\n\n根据近场阻抗矩阵 Znear 和计算阻抗矩阵层信息 level 计算右稀疏近似逆 (Sparse Approximate Inverse (SAI)) 。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.spherical_h1l-Tuple{Integer, Real}","page":"API","title":"MoM_Kernels.spherical_h1l","text":"第一类球汉克尔函数，使用GSL.jl(GNU Scientific Library)，适用于 l 为整数，x 为浮点数时算的更快\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.spherical_h1l-Union{Tuple{T}, Tuple{Any, T}} where T","page":"API","title":"MoM_Kernels.spherical_h1l","text":"第一类球汉克尔函数，使用 SpecialFunctions.jl， 适用于非整数阶、复数变量，算的较慢，只在计算有耗介质（复数波矢）时调用\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.spherical_h1l_array-Union{Tuple{T}, Tuple{Any, T}} where T","page":"API","title":"MoM_Kernels.spherical_h1l_array","text":"一次计算 0:lmax 的多阶第一类球汉克尔函数， 保存在数组里\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.spherical_h1l_array-Union{Tuple{T}, Tuple{Integer, T}} where T<:Real","page":"API","title":"MoM_Kernels.spherical_h1l_array","text":"一次计算 0:lmax 的多阶第一类球汉克尔函数， 保存在数组里\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.spherical_h2l-Tuple{Integer, Real}","page":"API","title":"MoM_Kernels.spherical_h2l","text":"第二类球汉克尔函数，使用GSL.jl(GNU Scientific Library)，，适用于 l 为整数，x 为浮点数时算的更快\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.spherical_h2l-Union{Tuple{T}, Tuple{Any, T}} where T","page":"API","title":"MoM_Kernels.spherical_h2l","text":"第二类球汉克尔函数，使用 SpecialFunctions.jl， 适用于非整数阶、复数变量，算的较慢，只在计算有耗介质（复数波矢）时调用\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.spherical_h2l_array-Union{Tuple{T}, Tuple{Any, T}} where T","page":"API","title":"MoM_Kernels.spherical_h2l_array","text":"一次计算 0:lmax 的多阶第二类球汉克尔函数， 保存在数组里\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.spherical_h2l_array-Union{Tuple{T}, Tuple{Integer, T}} where T<:Real","page":"API","title":"MoM_Kernels.spherical_h2l_array","text":"一次计算 0:lmax 的多阶第二类球汉克尔函数， 保存在数组里\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.transOnLevel!-Tuple{Any}","page":"API","title":"MoM_Kernels.transOnLevel!","text":"层内转移\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.transOnLevels!-Tuple{Any, Any}","page":"API","title":"MoM_Kernels.transOnLevels!","text":"各层内转移\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.truncationLCal-Tuple{FT} where FT<:Real","page":"API","title":"MoM_Kernels.truncationLCal","text":"该函数计算八叉树各层截断项数 输入为本层最小盒子的边长\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.truncationLCal-Tuple{}","page":"API","title":"MoM_Kernels.truncationLCal","text":"truncationLCal(;rel_l) where {FT<:Real}\n\n该函数计算八叉树各层截断项数 输入为相对波长\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.use_CSR-Tuple{}","page":"API","title":"MoM_Kernels.use_CSR","text":"use_CSR()\nuse_CSC()\n\n设置近场阻抗矩阵是否采用CSR（CSC转置）。\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.volumeSingularityIg-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, HexahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.volumeSingularityIg","text":"volumeSingularityIg(rtveclc::AbstractVector{FT}, volumeCell::HexahedraInfo{IT, FT, CT}) where {IT<:Integer, FT<:Real, CT<:Complex{FT}}\n\n计算场点rgt在体网格volumeCell上的奇异性。 计算结果为：\n\nbeginaligned\nI_gV  = intg(R)dV\n        = -sum_S_id_isum_n^SglrOrderfraccoeffgreen(n)n+2I_RS^n-1\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.volumeSingularityIgIvecg-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, TetrahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.volumeSingularityIgIvecg","text":"volumeSingularityIgIvecg(rtveclc::AbstractVector{FT}, volumeCell::TetrahedraInfo{IT, FT, CT}) where {IT<:Integer, FT<:Real, CT<:Complex{FT}}\nvolumeSingularityIgIvecg(rtveclc::AbstractVector{FT}, volumeCell::HexahedraInfo{IT, FT, CT}) where {IT<:Integer, FT<:Real, CT<:Complex{FT}}\n\n计算场点rgt在体网格volumeCell上的奇异性。 计算结果为：\n\nbeginaligned\nI_gV  = intg(R)dV\n        = -sum_S_id_isum_n^SglrOrderfraccoeffgreen(n)n+2I_RS^n-1\nboldsymbolI_gV  = intboldsymbolRg(R)dV\n        = -sum_S_ihatbmn_i sum_n=0^SglrOrderfraccoeffgreen(n)n+1I^n+1_RS\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.volumeSingularityLOpDyad-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, TetrahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}}","page":"API","title":"MoM_Kernels.volumeSingularityLOpDyad","text":"volumeSingularityLOpDyad(rtveclc::AbstractVector{FT}, volumeCell::TetrahedraInfo{IT, FT, CT}) where {IT<:Integer, FT<:Real, CT<:Complex{FT}}\nvolumeSingularityLOpDyad(rtveclc::AbstractVector{FT}, volumeCell::HexahedraInfo{IT, FT, CT}) where {IT<:Integer, FT<:Real, CT<:Complex{FT}}\n\n计算场点rtveclc在体网格volumeCell上的并矢格林函数奇异性。 计算结果为：\n\nbeginaligned\noverlineI_V  = int(k^2 I + )G(R) dV\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"api/#MoM_Kernels.writeZtt!-Union{Tuple{GT}, Tuple{T}, Tuple{Any, Any, T, GT, Bool}} where {T<:Number, GT<:VolumeCellType}","page":"API","title":"MoM_Kernels.writeZtt!","text":"为适应类型变化而将写入部分单独封装\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = quote\n    using MoM_Kernels\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: MoM)","category":"page"},{"location":"#MoM_Kernels","page":"Home","title":"MoM_Kernels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: star)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Size) (Image: Downloads) (Image: License)","category":"page"},{"location":"#介绍","page":"Home","title":"介绍","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"提供 CEM_MoMs ((Image: github), (Image: gitee)) 包的核心算法，包括各类基函数的矩阵元计算、多层快速多极子（MLFMA）各种类型和函数、求解器、后处理（RCS、远场计算等功能），但不包含绘图函数。 CEM_MoMs 本身被拆分为几个独立的包以方便开发时快速编译，同时避免在无图形化界面使用时调入绘图相关包而导致报错。","category":"page"},{"location":"#安装与测试","page":"Home","title":"安装与测试","text":"","category":"section"},{"location":"#安装","page":"Home","title":"安装","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"可直接在 Julia REPL 的包管理模式中安装：","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Pkg.add(\"MoM_Kernels\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"或","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add MoM_Kernels","category":"page"},{"location":"#测试","page":"Home","title":"测试","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"同样可直接在 Julia REPL 的包管理模式中测试包：","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Pkg.test(\"MoM_Kernels\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"或","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add MoM_Kernels","category":"page"}]
}
