var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = MoM_Kernels","category":"page"},{"location":"#MoM_Kernels","page":"Home","title":"MoM_Kernels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MoM_Kernels.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [MoM_Kernels]","category":"page"},{"location":"#MoM_Kernels.MLFMAParams","page":"Home","title":"MoM_Kernels.MLFMAParams","text":"多层快速多极子的可调参数\n\n\n\n\n\n","category":"constant"},{"location":"#MoM_Kernels.SSCg","page":"Home","title":"MoM_Kernels.SSCg","text":"计算面奇异性时用的两个系数。\n\n\n\n\n\n","category":"constant"},{"location":"#MoM_Kernels.SSCgdivnp2","page":"Home","title":"MoM_Kernels.SSCgdivnp2","text":"计算体奇异性时用到的一些系数。\n\n\n\n\n\n","category":"constant"},{"location":"#MoM_Kernels.VSC₃ⁿ","page":"Home","title":"MoM_Kernels.VSC₃ⁿ","text":"这一项面、体奇异性都用到了，处理对格林函数梯度求积时的奇异性时用到的。\n\n\n\n\n\n","category":"constant"},{"location":"#MoM_Kernels.CubeInfo","page":"Home","title":"MoM_Kernels.CubeInfo","text":"盒子信息，包括 子层盒子id的区间、 包含的基函数区间、 非空子盒子在8个子盒子中的id等、 包含的网格如三角形、四面体的id，以基函数进行分，因此边界上的同一个网格可能被分到不同的盒子内。 邻盒子的id、远亲盒子的id、本盒子在本层的三维整数坐标、本盒子在本层的三维全局坐标\n\n\n\n\n\n","category":"type"},{"location":"#MoM_Kernels.GLPolesInfo","page":"Home","title":"MoM_Kernels.GLPolesInfo","text":"多极子的极信息，即角谱空间采样信息 Xθs::Vector{FT}，θ方向的采样点坐标（rad单位），高斯-勒让德求积 Xϕs::Vector{FT}，ϕ方向的采样点坐标（rad单位），均值求积 Wθϕs::Vector{FT}，采样点权重，用于积分时使用，在MLFMA中直接乘在转移项\n\n\n\n\n\n","category":"type"},{"location":"#MoM_Kernels.LagrangeInterp1StepInfo","page":"Home","title":"MoM_Kernels.LagrangeInterp1StepInfo","text":"保存总的 稀疏插值矩阵，用于单步插值，根据稀疏度决定保存稀疏阵或是稠密阵 θϕCSC       ::AbstractMatrix{FT} 稀疏矩阵, θ 方向插值矩阵的转置，用于左乘本层多极子矩阵，在 θ 方向反插值 θϕCSCT      ::AbstractMatrix{FT} 稀疏矩阵, ϕ 方向插值矩阵的转置，用于左乘本层多极子矩阵，在 ϕ 方向反插值\n\n\n\n\n\n","category":"type"},{"location":"#MoM_Kernels.LagrangeInterp1StepInfo-Union{Tuple{IT}, Tuple{FT}, Tuple{SparseArrays.SparseMatrixCSC{FT, IT}, SparseArrays.SparseMatrixCSC{FT, IT}}} where {FT<:Real, IT}","page":"Home","title":"MoM_Kernels.LagrangeInterp1StepInfo","text":"带参数的构造函数\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.LagrangeInterpInfo","page":"Home","title":"MoM_Kernels.LagrangeInterpInfo","text":"保存 θ, ϕ 两个方向的稀疏插值矩阵， θ方向为 (npXθs, ntXθs) 稀疏矩阵, 用于左乘本层多极子矩阵，在 θ 方向插值 ϕ方向为 (ntXϕs, ntXϕs) 稀疏矩阵, 用于右乘本层多极子矩阵，在 ϕ 方向插值 θCSCT   ::SparseMatrixCSC{FT} 稀疏矩阵, θ 方向插值矩阵的转置，用于左乘本层多极子矩阵，在 θ 方向反插值 ϕCSCT   ::SparseMatrixCSC{FT} 稀疏矩阵, ϕ 方向插值矩阵的转置，用于左乘本层多极子矩阵，在 ϕ 方向反插值\n\n\n\n\n\n","category":"type"},{"location":"#MoM_Kernels.LagrangeInterpInfo-Union{Tuple{IT}, Tuple{FT}, Tuple{SparseArrays.SparseMatrixCSC{FT, IT}, SparseArrays.SparseMatrixCSC{FT, IT}}} where {FT<:Real, IT}","page":"Home","title":"MoM_Kernels.LagrangeInterpInfo","text":"带参数的构造函数\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.LevelInfo","page":"Home","title":"MoM_Kernels.LevelInfo","text":"层信息 ID          ::IT，层序号 L           ::IT, 本层截断项数 cubes       ::Vector{CubeInfo{IT, FT}} 包含每一个盒子信息的向量 cubeEdgel   ::FT，本层盒子的边长 poles       ::PolesInfo{IT, FT}, 多极子采样信息 interpWθϕ   ::InterpInfo{IT, FT}, 插值信息 aggS        ::Array{Complex{FT}, 3}， 聚合项 disaggG     ::Array{Complex{FT}, 3}， 解聚项 phaseShift2Kids  ::Array{Complex{FT}, 3}，本层盒子到子层盒子的相移因子  αTrans      ::Array{Complex{FT}, 3}， 本层盒子远亲组之间的转移因子，根据相对位置共有 7^3 - 3^3 = 316 个 αTransIndex ::Array{IT, 2}, 远亲盒子的相对位置到其转移因子在所有转移因子数组的索引\n\n\n\n\n\n","category":"type"},{"location":"#MoM_Kernels.MLFMAParamsType","page":"Home","title":"MoM_Kernels.MLFMAParamsType","text":"创建可变参数类型以在频率更改时对应更改 MLFMA 的相关参数\n\n\n\n\n\n","category":"type"},{"location":"#MoM_Kernels.MLMFAIterator","page":"Home","title":"MoM_Kernels.MLMFAIterator","text":"保存 MLFMA 相关信息的结构体\n\n\n\n\n\n","category":"type"},{"location":"#MoM_Kernels.MLMFAIterator-Union{Tuple{LT}, Tuple{FT}, Tuple{Any, MoM_Kernels.OctreeInfo{FT, LT}, Vector, Vector}} where {FT<:Real, LT<:MoM_Kernels.LevelInfo}","page":"Home","title":"MoM_Kernels.MLMFAIterator","text":"实现矩阵向量乘积，并封装为线性算子\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.MatrixChunk","page":"Home","title":"MoM_Kernels.MatrixChunk","text":"创建近场矩阵块结构体，所包含的数据为某一盒子内的近场矩阵元\n\nm::Int，行数\nn::Int，列数\nmat::Matrix{T}，矩阵\nrowIndices::AbstractVector{Int}，行索引\ncolIndices::AbstractVector{Int}，列索引\nlmul::AbstractVector{T}，用于左乘其它矩阵、向量的临时数组，大小与列数相同\nrmul::AbstractVector{T}，用于右乘其它矩阵、向量的临时数组，大小与行数相同\n\n\n\n\n\n","category":"type"},{"location":"#MoM_Kernels.OctreeInfo","page":"Home","title":"MoM_Kernels.OctreeInfo","text":"八叉树类 nLevels ::Integer, 叶层ID（定义大盒子为（“0” 层），叶层为第“n”层，nLevels取“n”的值） leafCubeEdgel::FT，叶层盒子边长 bigCubeLowerCoor::MVec3D{FT}，第0层盒子的角坐标 levels  ::Dict{Int, LevelInfo}，保存各层信息的字典\n\n\n\n\n\n","category":"type"},{"location":"#MoM_Kernels.OctreeInfo-Union{Tuple{LT}, Tuple{FT}, Tuple{Matrix{FT}, FT}} where {FT<:Real, LT<:MoM_Kernels.AbstractLevel}","page":"Home","title":"MoM_Kernels.OctreeInfo","text":"构建八叉树类\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.PartitionedVector","page":"Home","title":"MoM_Kernels.PartitionedVector","text":"struct PartitionedVector{T} <: AbstractVector{T}     length::Int     data::OffsetVector{T, Vector{T}}     indices::UnitRange{Int}     ghostdata::SparseVector{T, Int}     ghostindices::Vector{T, Int} end\n\n用于保存向量块，同时在块内保存一些其他块的数据。\n\n\n\n\n\n","category":"type"},{"location":"#MoM_Kernels.ZnearChunksStruct","page":"Home","title":"MoM_Kernels.ZnearChunksStruct","text":"创建近场矩阵结构体，所包含的数据为所有盒子内的近场矩阵元，多线程版本\n\nm::Int，行数\nn::Int，列数\nnChunks::Int，矩阵块儿数\nchunks::Vector{ZnearChunksStruct{T}}，矩阵\nlmul::Vector{T}，用于左乘其它矩阵、向量的临时数组，大小与列数相同\nlmuld::Vector{T}，用于左乘其它矩阵、向量的临时分布式数组，大小与列数相同，默认不分配\nrmul::Vector{T}，用于右乘其它矩阵、向量的临时数组，大小与行数相同\nlmuld::Vector{T}，用于左乘其它矩阵、向量的临时分布式数组，大小与列数相同，默认不分配\n\n\n\n\n\n","category":"type"},{"location":"#MoM_Kernels.ZnearChunksStruct-Union{Tuple{Any}, Tuple{T}} where T<:Number","page":"Home","title":"MoM_Kernels.ZnearChunksStruct","text":"ZnearChunksStruct 类的初始化函数，将 lumld 和 rmuld 初始化为\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.mmulvStruct","page":"Home","title":"MoM_Kernels.mmulvStruct","text":"存储分布式矩阵向量乘积结果的数组\n\n\n\n\n\n","category":"type"},{"location":"#Base.:*-Union{Tuple{T}, Tuple{AbstractMatrix, T}} where T<:MoM_Kernels.MatrixChunk","page":"Home","title":"Base.:*","text":"实现右乘其它矩阵，默认矩阵块较小，不在本阶段并行\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Union{Tuple{T}, Tuple{AbstractVector, T}} where T<:MoM_Kernels.MatrixChunk","page":"Home","title":"Base.:*","text":"实现右乘其它向量，默认矩阵块较小，不在本阶段并行\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Union{Tuple{T}, Tuple{MoM_Kernels.ZNEARCHUNK{T}, AbstractMatrix}} where T<:Number","page":"Home","title":"Base.:*","text":"实现左乘其它矩阵\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Union{Tuple{T}, Tuple{T, AbstractMatrix}} where T<:MoM_Kernels.MatrixChunk","page":"Home","title":"Base.:*","text":"实现左乘其它矩阵，默认矩阵块较小，不在本阶段并行\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Union{Tuple{T}, Tuple{T, AbstractVector}} where T<:MoM_Kernels.MatrixChunk","page":"Home","title":"Base.:*","text":"实现左乘其它向量，默认矩阵块较小，不在本阶段并行\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Union{Tuple{T}, Tuple{T, AbstractVector}} where T<:MoM_Kernels.ZnearChunksStruct","page":"Home","title":"Base.:*","text":"实现左乘其它向量\n\n\n\n\n\n","category":"method"},{"location":"#Base.convert-Union{Tuple{LTo}, Tuple{LTt}, Tuple{FT}, Tuple{Type{MoM_Kernels.OctreeInfo{FT, LTt}}, MoM_Kernels.OctreeInfo{FT, LTo}}} where {FT<:Real, LTt<:MoM_Kernels.AbstractLevel, LTo<:MoM_Kernels.AbstractLevel}","page":"Home","title":"Base.convert","text":"实现包含分布式层的\n\n\n\n\n\n","category":"method"},{"location":"#Base.eltype-Tuple{IncompleteLU.ILUFactorization}","page":"Home","title":"Base.eltype","text":"提供 ilu 的算子 eltype 函数\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Union{Tuple{I}, Tuple{PartitionedVector, I}} where I<:Integer","page":"Home","title":"Base.getindex","text":"Base.getindex(A::PartitionedVector, i::I) where {I<:Integer}\n\n重载 getindex.\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T<:MoM_Kernels.MatrixChunk","page":"Home","title":"Base.getindex","text":"重载 getindex 函数\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T<:MoM_Kernels.ZNEARCHUNK","page":"Home","title":"Base.getindex","text":"重载 getindex 函数\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Union{Tuple{T}, Tuple{T, Int64}} where T<:MoM_Kernels.mmulvStruct","page":"Home","title":"Base.getindex","text":"重载 getindex 函数\n\n\n\n\n\n","category":"method"},{"location":"#Base.setindex!-Union{Tuple{T}, Tuple{T, Any, Int64, Int64}} where T<:MoM_Kernels.MatrixChunk","page":"Home","title":"Base.setindex!","text":"重载 setindex! 函数\n\n\n\n\n\n","category":"method"},{"location":"#Base.setindex!-Union{Tuple{T}, Tuple{T, Any, Int64, Int64}} where T<:MoM_Kernels.ZNEARCHUNK","page":"Home","title":"Base.setindex!","text":"重载 setindex! 函数\n\n\n\n\n\n","category":"method"},{"location":"#Base.setindex!-Union{Tuple{T}, Tuple{T, Any, Int64}} where T<:MoM_Kernels.mmulvStruct","page":"Home","title":"Base.setindex!","text":"重载 setindex! 函数\n\n\n\n\n\n","category":"method"},{"location":"#Base.size-Tuple{T} where T<:IncompleteLU.ILUFactorization","page":"Home","title":"Base.size","text":"提供 ilu 的算子 size 函数\n\n\n\n\n\n","category":"method"},{"location":"#Base.size-Union{Tuple{I}, Tuple{T}, Tuple{T, I}} where {T<:IncompleteLU.ILUFactorization, I<:Integer}","page":"Home","title":"Base.size","text":"提供 ilu 的算子 size 函数\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.ldiv!-Union{Tuple{T}, Tuple{AbstractVector, SAIChunkPrec{T}, AbstractVector}} where T","page":"Home","title":"LinearAlgebra.ldiv!","text":"y .= M * x\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.ldiv!-Union{Tuple{T}, Tuple{AbstractVector, SAIPrec{T}, AbstractVector}} where T","page":"Home","title":"LinearAlgebra.ldiv!","text":"y .= M * x\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.ldiv!-Union{Tuple{T}, Tuple{SAIChunkPrec{T}, AbstractVector}} where T","page":"Home","title":"LinearAlgebra.ldiv!","text":"x .= M * x\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.ldiv!-Union{Tuple{T}, Tuple{SAIPrec{T}, AbstractVector}} where T","page":"Home","title":"LinearAlgebra.ldiv!","text":"x .= M * x\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.mul!-Tuple{AbstractVector, MLMFAIterator, AbstractVector, Number, Number}","page":"Home","title":"LinearAlgebra.mul!","text":"LinearAlgebra.mul!(y, Zopt::MLMFAIterator, x)\n\n重载以实现矩阵向量乘积计算\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.mul!-Tuple{Any, MLMFAIterator, Any}","page":"Home","title":"LinearAlgebra.mul!","text":"LinearAlgebra.mul!(y, Zopt::MLMFAIterator, x)\n\n重载以实现矩阵向量乘积计算\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.mul!-Union{Tuple{V}, Tuple{T}, Tuple{AbstractVector, LinearAlgebra.Adjoint{T, MLMFAIterator{T, V}}, AbstractVector, Number, Number}} where {T, V}","page":"Home","title":"LinearAlgebra.mul!","text":"LinearAlgebra.mul!(y, Zopt::MLMFAIterator, x)\n\n重载以实现矩阵向量乘积计算\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.mul!-Union{Tuple{V}, Tuple{T}, Tuple{Any, LinearAlgebra.Adjoint{T, MLMFAIterator{T, V}}, Any}} where {T, V}","page":"Home","title":"LinearAlgebra.mul!","text":"LinearAlgebra.mul!(y, Zopt::MLMFAIterator, x)\n\n重载以实现矩阵向量乘积计算\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.CFIEOnNearTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:AbstractFloat}","page":"Home","title":"MoM_Kernels.CFIEOnNearTris","text":"计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形不重合但相隔较近的情况，因此输入有两个个三角形信息类型实例 输入 trit， tris     :   TriangleInfo, 场三角形和源三角形\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.CFIEOnTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:AbstractFloat}","page":"Home","title":"MoM_Kernels.CFIEOnTris","text":"计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形不重合且相隔较远的情况，因此输入有两个个三角形信息类型实例 输入 trit， tris     :   TriangleInfo, 场三角形和源三角形\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.CFIEOnTris-Union{Tuple{TriangleInfo{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT<:Integer, FT<:AbstractFloat}","page":"Home","title":"MoM_Kernels.CFIEOnTris","text":"计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形重合的情况，因此输入只有一个三角形信息类型实例 输入 tri     :   TriangleInfo\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnHexaPWC-Union{Tuple{HexahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.EFIEOnHexaPWC","text":"采用 PWC 基函数 计算六面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体重合的情况，因此输入有一个六面体信息类型实例 输入： hexat   HexahedraInfo, 场六面体和六面体 计算： jkη₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 其中， ∫ₜ∫ₛ∇∇G(R)dV′dV = ∫ₜ∑ᵢn̂ᵢ(∫ᵢR̂(jk + 1/R)G(R)dS′)dV 计算得到结果为并矢:: jη₀/k ∫∫ (k²I + ∇∇)G(R) dV'dV Kᵣⁿ  =   ∫ Rⁿ dV' K̂ᵣⁿ  =   ∫ R̂Rⁿ dV' 注意为与两两作用不同，此处加上了 κ 项，因此后续填充时不需加上。\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnHexaPWCSepPV-Union{Tuple{HexahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.EFIEOnHexaPWCSepPV","text":"采用 PWC 基函数 计算六面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体重合的情况，因此输入有一个六面体信息类型实例 输入： hexat   HexahedraInfo, 场六面体和六面体 计算： jkη₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 其中， ∫ₜ∫ₛ∇∇G(R)dV′dV = ∫ₜ∑ᵢn̂ᵢ(∫ᵢR̂(jk + 1/R)G(R)dS′)dV 计算得到结果为并矢:: jη₀/k ∫∫ (k²I + ∇∇)G(R) dV'dV Kᵣⁿ  =   ∫ Rⁿ dV' K̂ᵣⁿ  =   ∫ R̂Rⁿ dV' 注意为与两两作用不同，此处加上了 κ 项，因此后续填充时不需加上。\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnHexaRBF-Union{Tuple{HexahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.EFIEOnHexaRBF","text":"计算六面体上相关的 36 个阻抗矩阵元， 此函数方法用于计算场源六面体重合的情况，因此输入有一个六面体信息类型实例 输入 hexat     :   HexahedraInfo, 场六面体和源六面体\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.EFIEOnHexaTetraPWC","text":"采用 PWC 基函数 计算六面体和四面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况，因此输入有两个六面体信息类型实例 输入： hexat::HexahedraInfo,   场六面体 tetras::TetrahedraInfo  源四面体 计算： jk₀η₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.EFIEOnHexaTetraPWC","text":"采用 PWC 基函数 计算六面体和四面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况，因此输入有两个六面体信息类型实例 输入： tetrat::TetrahedraInfo  场四面体 hexas::HexahedraInfo,   源六面体 计算： jk₀η₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnHexasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.EFIEOnHexasPWC","text":"采用 PWC 基函数 计算六面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况，因此输入有两个六面体信息类型实例 输入： hexat  hexas     :   HexahedraInfo, 场六面体和六面体 计算： jk₀η₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnHexasRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.EFIEOnHexasRBF","text":"计算六面体上相关的 36 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况，因此输入有两个六面体信息类型实例 输入 hexat, hexas     :   HexahedraInfo, 场六面体和源六面体\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnNearHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.EFIEOnNearHexaTetraPWC","text":"采用 PWC 基函数 计算六面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较近的情况，因此输入有两个六面体信息类型实例 输入： hexat  hexas     :   HexahedraInfo, 场六面体和六面体 计算： jkη₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 其中， ∫ₜ∫ₛ∇∇G(R)dV′dV = ∫ₜ∑ᵢn̂ᵢ(∫ᵢR̂(jk + 1/R)G(R)dS′)dV 计算得到结果为并矢:: jη₀/k ∫∫ (k²I + ∇∇)G(R) dV'dV Kᵣⁿ  =   ∫ Rⁿ dV' K̂ᵣⁿ  =   ∫ R̂Rⁿ dV' 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnNearHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.EFIEOnNearHexaTetraPWC","text":"采用 PWC 基函数 计算六面体和四面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况，因此输入有两个六面体信息类型实例 输入： tetrat::TetrahedraInfo  场四面体 hexas::HexahedraInfo,   源六面体 计算： jk₀η₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnNearHexasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.EFIEOnNearHexasPWC","text":"采用 PWC 基函数 计算六面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较近的情况，因此输入有两个六面体信息类型实例 输入： hexat  hexas     :   HexahedraInfo, 场六面体和六面体 计算： jkη₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 其中， ∫ₜ∫ₛ∇∇G(R)dV′dV = ∫ₜ∑ᵢn̂ᵢ(∫ᵢR̂(jk + 1/R)G(R)dS′)dV 计算得到结果为并矢:: jη₀/k ∫∫ (k²I + ∇∇)G(R) dV'dV Kᵣⁿ  =   ∫ Rⁿ dV' K̂ᵣⁿ  =   ∫ R̂Rⁿ dV' 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnNearHexasRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.EFIEOnNearHexasRBF","text":"计算六面体上相关的 36 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合但相隔较近的情况，输入有两个六面体信息类型实例 输入 hexat, hexas     :   HexahedraInfo, 场六面体和源六面体\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT<:Integer, FT<:AbstractFloat, VT<:HexahedraInfo}","page":"Home","title":"MoM_Kernels.EFIEOnNearRWGPWC","text":"计算三角形和六面体上相关的 9 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较近的情况 输入 trit    ::  TriangleInfo,  场三角形面体 geos    ::  HexahedraInfo, 源六面体\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT<:Integer, FT<:AbstractFloat, VT<:VolumeCellType}","page":"Home","title":"MoM_Kernels.EFIEOnNearRWGPWC","text":"计算三角形和四面体上相关的 9 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较近的情况 输入 trit    ::  TriangleInfo,  场三角形面体 geos    ::  TetrahedraInfo, TetrahedraInfo, 源四面体、四面体\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:AbstractFloat, VT<:HexahedraInfo}","page":"Home","title":"MoM_Kernels.EFIEOnNearRWGPWC","text":"计算三角形和六面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 geot    ::  HexahedraInfo, 场六面体\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:AbstractFloat, VT<:VolumeCellType}","page":"Home","title":"MoM_Kernels.EFIEOnNearRWGPWC","text":"计算三角形和四面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 geot    ::  TetrahedraInfo, TetrahedraInfo, 场四面体、四面体\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnNearRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.EFIEOnNearRWGRBF","text":"计算三角形和六面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 hexat  ::  HexahedraInfo, 场六面体\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnNearRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, HexahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.EFIEOnNearRWGRBF","text":"计算三角形和六面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较近的情况 输入 tris    ::  TriangleInfo,  源三角形面体 hexat  ::  HexahedraInfo, 场六面体\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnNearRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.EFIEOnNearRWGSWG","text":"计算三角形和四面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 tetrat  ::  TetrahedraInfo, 场四面体\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnNearRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TetrahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.EFIEOnNearRWGSWG","text":"计算三角形和四面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较近的情况 输入 tris    ::  TriangleInfo,  源三角形面体 tetrat  ::  TetrahedraInfo, 场四面体\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnNearTetrasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.EFIEOnNearTetrasPWC","text":"采用 PWC 基函数 计算四面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较近的情况，因此输入有两个四面体信息类型实例 输入： tetrat  tetras     :   TetrahedraInfo, 场四面体和四面体 计算： jkη₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 其中， ∫ₜ∫ₛ∇∇G(R)dV′dV = ∫ₜ∑ᵢn̂ᵢ(∫ᵢR̂(jk + 1/R)G(R)dS′)dV 计算得到结果为并矢:: jη₀/k ∫∫ (k²I + ∇∇)G(R) dV'dV Kᵣⁿ  =   ∫ Rⁿ dV' K̂ᵣⁿ  =   ∫ R̂Rⁿ dV' 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnNearTetrasSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.EFIEOnNearTetrasSWG","text":"计算四面体上相关的 16 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合但相隔较近的情况，输入有两个四面体信息类型实例 输入 tetrat, tetras     :   TetrahedraInfo, 场四面体和源四面体\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnNearTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:AbstractFloat}","page":"Home","title":"MoM_Kernels.EFIEOnNearTris","text":"计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形不重合但相隔较近的情况，因此输入有两个个三角形信息类型实例 输入 trit， tris     :   TriangleInfo, 场三角形和源三角形\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT<:Integer, FT<:AbstractFloat, VT<:HexahedraInfo}","page":"Home","title":"MoM_Kernels.EFIEOnRWGPWC","text":"计算三角形和六面体上相关的 9 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况 输入 trit    ::  TriangleInfo,  场三角形面体 geos    ::  HexahedraInfo, 源六面体\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT<:Integer, FT<:AbstractFloat, VT<:TetrahedraInfo}","page":"Home","title":"MoM_Kernels.EFIEOnRWGPWC","text":"计算三角形和四面体上相关的 9 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况 输入 trit    ::  TriangleInfo,  场三角形面体 geos    ::  TetrahedraInfo, 源四面体\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:AbstractFloat, VT<:HexahedraInfo}","page":"Home","title":"MoM_Kernels.EFIEOnRWGPWC","text":"计算三角形和六面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 geot    ::  HexahedraInfo, 场六面体\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:AbstractFloat, VT<:VolumeCellType}","page":"Home","title":"MoM_Kernels.EFIEOnRWGPWC","text":"计算三角形和四面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 geot    ::  TetrahedraInfo, TetrahedraInfo, 场四面体、四面体\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.EFIEOnRWGRBF","text":"计算三角形和六面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 hexat  ::  HexahedraInfo, 场六面体\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, HexahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.EFIEOnRWGRBF","text":"计算三角形和六面体上相关的 18 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况 输入 trit    ::  TriangleInfo,  场三角形面体 hexas   ::  HexahedraInfo, 源六面体\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.EFIEOnRWGSWG","text":"计算三角形和四面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 tetrat  ::  TetrahedraInfo, 场四面体\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TetrahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.EFIEOnRWGSWG","text":"计算三角形和四面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 tetrat  ::  TetrahedraInfo, 场四面体\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnTetraPWC-Union{Tuple{TetrahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.EFIEOnTetraPWC","text":"采用 PWC 基函数 计算四面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源四面体重合的情况，因此输入有一个四面体信息类型实例 输入： tetrat   TetrahedraInfo, 场四面体和四面体 计算： jkη₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 其中， ∫ₜ∫ₛ∇∇G(R)dV′dV = ∫ₜ∑ᵢn̂ᵢ(∫ᵢR̂(jk + 1/R)G(R)dS′)dV 计算得到结果为并矢:: jη₀/k ∫∫ (k²I + ∇∇)G(R) dV'dV Kᵣⁿ  =   ∫ Rⁿ dV' K̂ᵣⁿ  =   ∫ R̂Rⁿ dV' 注意为与两两作用不同，此处加上了 κ 项，因此后续填充时不需加上。\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnTetraPWCSepPV-Union{Tuple{TetrahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.EFIEOnTetraPWCSepPV","text":"采用 PWC 基函数 计算四面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源四面体重合的情况，因此输入有一个四面体信息类型实例 输入： tetrat   TetrahedraInfo, 场四面体和四面体 计算： jkη₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 其中， ∫ₜ∫ₛ∇∇G(R)dV′dV = ∫ₜ∑ᵢn̂ᵢ(∫ᵢR̂(jk + 1/R)G(R)dS′)dV 计算得到结果为并矢:: jη₀/k ∫∫ (k²I + ∇∇)G(R) dV'dV Kᵣⁿ  =   ∫ Rⁿ dV' K̂ᵣⁿ  =   ∫ R̂Rⁿ dV' 注意为与两两作用不同，函数将主值积分分开返回以便它用\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnTetraSWG-Union{Tuple{TetrahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.EFIEOnTetraSWG","text":"计算四面体上相关的 16 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况，因此输入有两个四面体信息类型实例 输入 tetrat, tetras     :   TetrahedraInfo, 场四面体和源四面体\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnTetrasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.EFIEOnTetrasPWC","text":"采用 PWC 基函数 计算四面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况，因此输入有两个四面体信息类型实例 输入： tetrat  tetras     :   TetrahedraInfo, 场四面体和四面体 计算： jk₀η₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnTetrasSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.EFIEOnTetrasSWG","text":"计算四面体上相关的 16 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况，因此输入有两个四面体信息类型实例 输入 tetrat, tetras     :   TetrahedraInfo, 场四面体和源四面体\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:AbstractFloat}","page":"Home","title":"MoM_Kernels.EFIEOnTris","text":"计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形不重合且相隔较远的情况，因此输入有两个个三角形信息类型实例 输入 trit， tris     :   TriangleInfo, 场三角形和源三角形\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.EFIEOnTris-Union{Tuple{TriangleInfo{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT<:Integer, FT<:AbstractFloat}","page":"Home","title":"MoM_Kernels.EFIEOnTris","text":"计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形重合的情况，因此输入只有一个三角形信息类型实例 输入 tri     :   TriangleInfo\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.MFIEOnNearTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:AbstractFloat}","page":"Home","title":"MoM_Kernels.MFIEOnNearTris","text":"计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形不重合但相隔较近的情况，因此输入有两个个三角形信息类型实例 输入 trit， tris     :   TriangleInfo, 场三角形和源三角形\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.MFIEOnTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:AbstractFloat}","page":"Home","title":"MoM_Kernels.MFIEOnTris","text":"计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形不重合且相隔较远的情况，因此输入有两个个三角形信息类型实例 输入 trit， tris     :   TriangleInfo, 场三角形和源三角形\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.MFIEOnTris-Union{Tuple{TriangleInfo{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT<:Integer, FT<:AbstractFloat}","page":"Home","title":"MoM_Kernels.MFIEOnTris","text":"计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形重合的情况，因此输入只有一个三角形信息类型实例 输入 tri     :   TriangleInfo\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.RCSPlot-Union{Tuple{FT}, Tuple{Any, Any, Matrix{FT}, Matrix{FT}}} where FT<:Real","page":"Home","title":"MoM_Kernels.RCSPlot","text":"RCS 绘图\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.ZnearChunkMulIVec!-Tuple{Any, Any, Any}","page":"Home","title":"MoM_Kernels.ZnearChunkMulIVec!","text":"计算某一块的矩阵向量乘积\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.adjoint_agg2HighLevel!-Tuple{Any, Any}","page":"Home","title":"MoM_Kernels.adjoint_agg2HighLevel!","text":"从子层聚合到本层 tLevel :: 本层 kLevel :: 子层\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.adjoint_agg2Level2!-Tuple{Any, Any}","page":"Home","title":"MoM_Kernels.adjoint_agg2Level2!","text":"从叶层聚合到第 '2' 层\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.adjoint_aggOnBF!-Union{Tuple{T}, Tuple{Any, Any, AbstractArray{T}}} where T<:Number","page":"Home","title":"MoM_Kernels.adjoint_aggOnBF!","text":"在叶层从基函数向盒子聚合\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.adjoint_disagg2KidLevel!-Tuple{Any, Any}","page":"Home","title":"MoM_Kernels.adjoint_disagg2KidLevel!","text":"向低层解聚 tLevel :: 本层 kLevel :: 子层\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.adjoint_disagg2LeafLevel!-Tuple{Any, Any}","page":"Home","title":"MoM_Kernels.adjoint_disagg2LeafLevel!","text":"解聚到叶层\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.adjoint_disaggOnBF!-Tuple{Any, Any, Any}","page":"Home","title":"MoM_Kernels.adjoint_disaggOnBF!","text":"在叶层往测试基函数解聚\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.adjoint_transOnLevel!-Tuple{Any}","page":"Home","title":"MoM_Kernels.adjoint_transOnLevel!","text":"层内转移\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.adjoint_transOnLevels!-Tuple{Any, Any}","page":"Home","title":"MoM_Kernels.adjoint_transOnLevels!","text":"各层内转移\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.agg2HighLevel!-Tuple{Any, Any}","page":"Home","title":"MoM_Kernels.agg2HighLevel!","text":"从子层聚合到本层 tLevel :: 本层 kLevel :: 子层\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.agg2HighLevel!-Union{Tuple{IPT}, Tuple{FT}, Tuple{IT}, Tuple{Any, MoM_Kernels.LevelInfo{IT, FT, IPT}}} where {IT, FT, IPT<:MoM_Kernels.LagrangeInterpInfo}","page":"Home","title":"MoM_Kernels.agg2HighLevel!","text":"从子层聚合到本层 tLevel :: 本层 kLevel :: 子层\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.agg2Level2!-Tuple{Any, Any}","page":"Home","title":"MoM_Kernels.agg2Level2!","text":"从叶层聚合到第 '2' 层\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.aggOnBF!-Union{Tuple{T}, Tuple{Any, Any, AbstractArray{T}}} where T<:Number","page":"Home","title":"MoM_Kernels.aggOnBF!","text":"在叶层从基函数向盒子聚合\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:PWC}","page":"Home","title":"MoM_Kernels.aggSBFOnLevel!","text":"计算某层聚合项, 输入为六面体信息和 PWC 基函数信息\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:PWC}","page":"Home","title":"MoM_Kernels.aggSBFOnLevel!","text":"计算某层聚合项, 输入为四面体信息和 PWC 基函数信息\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:SWG}","page":"Home","title":"MoM_Kernels.aggSBFOnLevel!","text":"计算某层聚合项, 输入为四面体信息和 SWG 基函数信息\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{VT}, Tuple{Any, Any, Any, AbstractVector{VT}, Type{BFT}}} where {VT<:HexahedraInfo, BFT<:RBF}","page":"Home","title":"MoM_Kernels.aggSBFOnLevel!","text":"计算某层聚合项, 输入为六面体信息和 RBF 基函数信息\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.aggSBFOnLevel-Union{Tuple{BFT}, Tuple{VT}, Tuple{LT}, Tuple{LT, AbstractVector{VT}, AbstractVector{BFT}}} where {LT<:MoM_Kernels.LevelInfo, VT<:VolumeCellType, BFT<:BasisFunctionType}","page":"Home","title":"MoM_Kernels.aggSBFOnLevel","text":"计算某层聚合项, 输入为四面体信息和 SWG 基函数信息\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.aggSBFOnLevelCFIE!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT<:Integer, FT<:Real, BFT<:RWG}","page":"Home","title":"MoM_Kernels.aggSBFOnLevelCFIE!","text":"计算某层聚合项, 输入为三角形信息和 RWG 基函数信息\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.aggSBFOnLevelCFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Any}} where {IT<:Integer, FT<:Real}","page":"Home","title":"MoM_Kernels.aggSBFOnLevelCFIE","text":"计算某层聚合项, 输入为三角形信息和 RWG 基函数信息\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.aggSBFOnLevelEFIE!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT<:Integer, FT<:Real, BFT<:RWG}","page":"Home","title":"MoM_Kernels.aggSBFOnLevelEFIE!","text":"计算某层聚合项, 输入为三角形信息和 RWG 基函数信息\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.aggSBFOnLevelEFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Any}} where {IT<:Integer, FT<:Real}","page":"Home","title":"MoM_Kernels.aggSBFOnLevelEFIE","text":"计算某层聚合项, 输入为三角形信息和 RWG 基函数信息\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.aggSBFOnLevelMFIE!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT<:Integer, FT<:Real, BFT<:RWG}","page":"Home","title":"MoM_Kernels.aggSBFOnLevelMFIE!","text":"计算某层聚合项, 输入为三角形信息和 RWG 基函数信息\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.aggSBFOnLevelMFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Array{RWG{IT, FT}, 1}}} where {IT<:Integer, FT<:Real}","page":"Home","title":"MoM_Kernels.aggSBFOnLevelMFIE","text":"计算某层聚合项, 输入为三角形信息和 RWG 基函数信息\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.anterpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}","page":"Home","title":"MoM_Kernels.anterpolate!","text":"拉格朗日单步反插值\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.anterpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}","page":"Home","title":"MoM_Kernels.anterpolate!","text":"拉格朗日分步反插值\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.anterpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}","page":"Home","title":"MoM_Kernels.anterpolate","text":"拉格朗日单步反插值\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.anterpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}","page":"Home","title":"MoM_Kernels.anterpolate","text":"拉格朗日分步反插值\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.calZfarI!-Union{Tuple{MT}, Tuple{T}, Tuple{ZT}, Tuple{MLMFAIterator{ZT, MT}, AbstractArray{T}}} where {ZT, T<:Number, MT<:(Vector)}","page":"Home","title":"MoM_Kernels.calZfarI!","text":"计算远区矩阵向量乘积\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.calZnearCSC!-Union{Tuple{VSCellT}, Tuple{BFT}, Tuple{Any, AbstractVector{VSCellT}, Any}, Tuple{Any, AbstractVector{VSCellT}, Any, Type{BFT}}} where {BFT<:BasisFunctionType, VSCellT<:SurfaceCellType}","page":"Home","title":"MoM_Kernels.calZnearCSC!","text":"根据积分方程类型选择相应\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.calZnearCSC-Tuple{Any, Vector, Vector}","page":"Home","title":"MoM_Kernels.calZnearCSC","text":"给出参数计算矩阵近场元并保存在CSC矩阵中\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.calZnearCSCCFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:RWG}","page":"Home","title":"MoM_Kernels.calZnearCSCCFIE!","text":"采用 RWG 基函数计算 CFIE 面积分（SIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:ConstBasisFunction}","page":"Home","title":"MoM_Kernels.calZnearCSCEFIE!","text":"采用 PWC 基函数计算六面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:LinearBasisFunction}","page":"Home","title":"MoM_Kernels.calZnearCSCEFIE!","text":"采用 RBF 基函数计算六面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:ConstBasisFunction}","page":"Home","title":"MoM_Kernels.calZnearCSCEFIE!","text":"采用 PWC 基函数计算四面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:LinearBasisFunction}","page":"Home","title":"MoM_Kernels.calZnearCSCEFIE!","text":"采用 SWG 基函数计算网格元 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:RBF}","page":"Home","title":"MoM_Kernels.calZnearCSCEFIE!","text":"采用 RWG + RBF 基函数计算六面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:SWG}","page":"Home","title":"MoM_Kernels.calZnearCSCEFIE!","text":"采用 RWG + SWG 基函数计算 三角形 + 四面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:LinearBasisFunction}","page":"Home","title":"MoM_Kernels.calZnearCSCEFIE!","text":"采用 RWG 基函数计算 EFIE 面积分（SIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{VT2}, Tuple{VT1}, Tuple{CT}, Tuple{FT}, Tuple{Any, AbstractVector{VT1}, AbstractVector{VT2}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, AbstractVector{VT1}, AbstractVector{VT2}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {FT<:Real, CT<:Complex{FT}, VT1<:TetrahedraInfo, VT2<:HexahedraInfo, BFT<:PWC}","page":"Home","title":"MoM_Kernels.calZnearCSCEFIE!","text":"采用 PWC + PWC 基函数计算 四面体 + 六面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{VT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractVector{VT}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractVector{VT}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, VT<:VolumeCellType, BFT<:PWC}","page":"Home","title":"MoM_Kernels.calZnearCSCEFIE!","text":"采用 RWG + PWC 基函数计算 三角形 + 四面体/六面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.calZnearCSCEFIEnew!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:LinearBasisFunction}","page":"Home","title":"MoM_Kernels.calZnearCSCEFIEnew!","text":"采用 RBF 基函数计算六面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.calZnearCSCMFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:RWG}","page":"Home","title":"MoM_Kernels.calZnearCSCMFIE!","text":"采用 RWG 基函数计算 MFIE 面积分（SIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.caladjZfarI!-Union{Tuple{MT}, Tuple{T}, Tuple{ZT}, Tuple{LinearAlgebra.Adjoint{ZT, MLMFAIterator{ZT, MT}}, AbstractArray{T}}} where {ZT, T<:Number, MT<:(Vector)}","page":"Home","title":"MoM_Kernels.caladjZfarI!","text":"计算远区矩阵的伴随矩阵向量乘积\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.calαTransOnLevel!-NTuple{4, Any}","page":"Home","title":"MoM_Kernels.calαTransOnLevel!","text":"计算 level 层的转移因子， 转移因子只存在于远亲组，每层远亲组最多有 7^3 - 3^3 = 316种结果\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.coeffgreen-Tuple{Integer}","page":"Home","title":"MoM_Kernels.coeffgreen","text":"coeffgreen(n::Integer)\n\n归一化格林函数 (不包括frac14π项) 的展开系数函数，从 0 阶 到 n 阶：\n\nbeginaligned\ng(R)    = frace^-jkRR = sum_n=0^SglrOrdercoeffgreen(n)R^n-1\ncoeffgreen(n)  =   frac-jk^nn\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.convergencePlot-Union{Tuple{Vector{FT}}, Tuple{FT}} where FT<:Real","page":"Home","title":"MoM_Kernels.convergencePlot","text":"计算完成后绘制收敛曲线\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.cooraInCoorb-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T<:Number","page":"Home","title":"MoM_Kernels.cooraInCoorb","text":"计算一维坐标coora在坐标corrb中的位置\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.disagg2KidLevel!-Tuple{Any, Any}","page":"Home","title":"MoM_Kernels.disagg2KidLevel!","text":"向低层解聚 tLevel :: 本层 kLevel :: 子层\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.disagg2KidLevel!-Union{Tuple{IPT}, Tuple{FT}, Tuple{IT}, Tuple{Any, MoM_Kernels.LevelInfo{IT, FT, IPT}}} where {IT, FT, IPT<:MoM_Kernels.LagrangeInterpInfo}","page":"Home","title":"MoM_Kernels.disagg2KidLevel!","text":"向低层解聚 tLevel :: 本层 kLevel :: 子层\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.disagg2LeafLevel!-Tuple{Any, Any}","page":"Home","title":"MoM_Kernels.disagg2LeafLevel!","text":"解聚到叶层\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.disaggOnBF!-Tuple{Any, Any, Any}","page":"Home","title":"MoM_Kernels.disaggOnBF!","text":"在叶层往测试基函数解聚\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.electricJCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{StaticArraysCore.StaticArray{Tuple{3}, FT, 1}, StaticArraysCore.StaticArray{Tuple{3}, CT, 1}, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.electricJCal","text":"计算给定三角形面片位置 r 处的电流 电流基函数公式为：Jₙ = Iₙfₙ 同一个三角形面片上存在三个基函数，因此 Jₜ = ∑ₜₙ₌₁³ Iₜₙfₜₙ 输入： r               ::Vec3D{FT} ICoeff          ::Vec3D{CT}  三角形上的三个基函数的计算得到的电流系数 triangleInfo    ::TriangleInfo{IT, FT}，三角形信息 输出值: Jtrir           ::Complex{FT}, 三角形上加权后的电流\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.electricJCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.electricJCal","text":"计算所有三角形上的高斯求积点电流权重乘积 JₙᵢWᵢ 电流基函数公式为：Jₙ = Iₙfₙ 同一个三角形面片上存在三个基函数，因此 JₙᵢWᵢ = ∑ₜₙ₌₁³ Iₜₙlₜₙ/2Sₜₙ 输入： ICoeff          ::Vector{Complex{FT}}  计算得到的电流系数 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，三角形信息 输出值: Jtri         ::Marrix{Complex{FT}}, 三角形上加权后的电流\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.excitationVectorCFIE!-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}, Any}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real}","page":"Home","title":"MoM_Kernels.excitationVectorCFIE!","text":"计算平面波在 RWG 基函数上的激励向量 输入： source          ::ST, 波源 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，保存三角形信息的向量 nbf             ::Integer，基函数数目\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.excitationVectorCFIE-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TriangleInfo{IT, FT}, Type{BFT}}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real, BFT<:RWG}","page":"Home","title":"MoM_Kernels.excitationVectorCFIE","text":"计算平面波在给定三角形的三个 半RWG 基函数上的激励向量 输入： source  ::ST, 波源 tri     ::TriangleInfo{IT, FT}，三角形信息\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.excitationVectorCFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, Array{TriangleInfo{IT, FT}, 1}, Integer}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real}","page":"Home","title":"MoM_Kernels.excitationVectorCFIE","text":"计算平面波在 RWG 基函数上的激励向量 输入： source          ::ST, 波源 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，保存三角形信息的向量 nbf             ::Integer，基函数数目\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.excitationVectorEFIE!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Any}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.excitationVectorEFIE!","text":"计算平面波在 基函数 上的激励向量 输入： source          ::ST, 平面波源 tetrasInfo      ::Vector{TetrahedraInfo{IT, FT, CT}}，保存四面体信息的向量 nbf             ::Integer，基函数数量  \n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.excitationVectorEFIE!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Vector{CT}, ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}}, Tuple{Vector{CT}, ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Any}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.excitationVectorEFIE!","text":"计算平面波在 基函数 上的激励向量 输入： source          ::ST, 平面波源 hexasInfo       ::Vector{HexahedraInfo{IT, FT, CT}}，保存六面体信息的向量 nbf             ::Integer，基函数数量  \n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.excitationVectorEFIE!-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}, Any}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real}","page":"Home","title":"MoM_Kernels.excitationVectorEFIE!","text":"计算平面波在 RWG 基函数上的激励向量 输入： source          ::ST, 波源 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，保存三角形信息的向量 nbf             ::Integer，基函数数目\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.excitationVectorEFIE!-Union{Tuple{VT}, Tuple{ST}, Tuple{AbstractVector, ST, Vector{VT}}} where {ST<:ExcitingSources, VT<:(AbstractVector)}","page":"Home","title":"MoM_Kernels.excitationVectorEFIE!","text":"计算平面波在 基函数 上的激励向量 输入： source          ::ST, 平面波源 tetrasInfo      ::Vector{TetrahedraInfo{IT, FT, CT}}，保存六面体信息的向量 nbf             ::Integer，基函数数量  \n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, HexahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:ConstBasisFunction}","page":"Home","title":"MoM_Kernels.excitationVectorEFIE","text":"计算平面波在给定四面体的三个 PWC 基函数上的激励向量 输入： source      ::ST, 波源 hexa        ::HexahedraInfo{IT, FT, CT}，六面体信息\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, HexahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:LinearBasisFunction}","page":"Home","title":"MoM_Kernels.excitationVectorEFIE","text":"计算平面波在给定六面体的六个 半SWG 基函数上的激励向量 输入： source      ::ST, 波源 hexa        ::HexahedraInfo{IT, FT, CT}，六面体信息\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TetrahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:ConstBasisFunction}","page":"Home","title":"MoM_Kernels.excitationVectorEFIE","text":"计算平面波在给定四面体的三个 PWC 基函数上的激励向量 输入： source      ::ST, 波源 tetra       ::TetrahedraInfo{IT, FT, CT}，四面体信息\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TetrahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:LinearBasisFunction}","page":"Home","title":"MoM_Kernels.excitationVectorEFIE","text":"计算平面波在给定四面体的四个 半SWG 基函数上的激励向量 输入： source      ::ST, 波源 tetra       ::TetrahedraInfo{IT, FT, CT}，四面体信息\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TriangleInfo{IT, FT}, Type{BFT}}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real, BFT<:RWG}","page":"Home","title":"MoM_Kernels.excitationVectorEFIE","text":"计算平面波在给定三角形的三个 半RWG 基函数上的激励向量 输入： source  ::ST, 波源 tri     ::TriangleInfo{IT, FT}，三角形信息\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.excitationVectorEFIE-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer}, Tuple{ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer, Any}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.excitationVectorEFIE","text":"计算平面波在 基函数 上的激励向量 输入： source          ::ST, 平面波源 hexasInfo      ::Vector{HexahedraInfo{IT, FT, CT}}，保存六面体信息的向量 nbf             ::Integer，基函数数量  \n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.excitationVectorEFIE-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer}, Tuple{ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer, Any}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.excitationVectorEFIE","text":"计算平面波在 基函数 上的激励向量 输入： source          ::ST, 平面波源 tetrasInfo      ::Vector{TetrahedraInfo{IT, FT, CT}}，保存四面体信息的向量 nbf             ::Integer，基函数数量  \n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.excitationVectorEFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, Array{TriangleInfo{IT, FT}, 1}, Integer}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real}","page":"Home","title":"MoM_Kernels.excitationVectorEFIE","text":"计算平面波在 RWG 基函数上的激励向量 输入： source          ::ST, 波源 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，保存三角形信息的向量 nbf             ::Integer，基函数数目\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.excitationVectorEFIE-Union{Tuple{VT}, Tuple{ST}, Tuple{ST, Vector{VT}, Integer}} where {ST<:ExcitingSources, VT<:(AbstractVector)}","page":"Home","title":"MoM_Kernels.excitationVectorEFIE","text":"计算平面波在 基函数 上的激励向量 输入： source          ::ST, 平面波源 tetrasInfo      ::Vector{TetrahedraInfo{IT, FT, CT}}，保存六面体信息的向量 nbf             ::Integer，基函数数量  \n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.excitationVectorMFIE!-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}, Any}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real}","page":"Home","title":"MoM_Kernels.excitationVectorMFIE!","text":"计算平面波在 RWG 基函数上的激励向量 输入： source          ::ST, 波源 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，保存三角形信息的向量 nbf             ::Integer，基函数数目\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.excitationVectorMFIE-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TriangleInfo{IT, FT}, Type{BFT}}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real, BFT<:RWG}","page":"Home","title":"MoM_Kernels.excitationVectorMFIE","text":"计算平面波在给定三角形的三个 半RWG 基函数上的激励向量 输入： source  ::ST, 波源 tri     ::TriangleInfo{IT, FT}，三角形信息\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.excitationVectorMFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, Array{TriangleInfo{IT, FT}, 1}, Integer}} where {ST<:ExcitingSources, IT<:Integer, FT<:Real}","page":"Home","title":"MoM_Kernels.excitationVectorMFIE","text":"计算平面波在 RWG 基函数上的激励向量 输入： source          ::ST, 波源 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，保存三角形信息的向量 nbf             ::Integer，基函数数目\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.faceSingularityIg-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, TriangleInfo{IT, FT}, FT, AbstractVector{FT}}} where {IT<:Integer, FT<:Real}","page":"Home","title":"MoM_Kernels.faceSingularityIg","text":"faceSingularityIg(rgt::AbstractVector{FT}, tris::TriangleInfo{IT, FT}, area::FT, facen̂::AbstractVector{FT}) where {IT<:Integer, FT<:Real}\n\n计算场点rgt在源三角形tris上的奇异性，tris的面积为area，外法向量为facen̂。 计算结果为：\n\nbeginaligned\nI_gS  = intg(R)dS\n        = sum_n=0^SglrOrdercoeffgreen(n)I^n-1_RS\nI^n_RS  = intR^ndS\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.faceSingularityIg-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, Tris4Tetra{IT, FT}, FT, AbstractVector{FT}}} where {IT<:Integer, FT<:Real}","page":"Home","title":"MoM_Kernels.faceSingularityIg","text":"faceSingularityIg(rgt::AbstractVector{FT}, tris::Tris4Tetra{IT, FT}, area::FT, facen̂::AbstractVector{FT}) where {IT<:Integer, FT<:Real}\n\n计算场点rgt在源三角形tris（该三角形为组成四面体的某一面）上的奇异性，tris的面积为area，外法向量为facen̂。 计算结果为：\n\nbeginaligned\nI_gS  = intg(R)dS\n        = sum_n=0^SglrOrdercoeffgreen(n)I^n-1_RS\nI^n_RS  = intR^ndS\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.faceSingularityIg-Union{Tuple{ST}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, ST, FT, AbstractVector{FT}}} where {IT<:Integer, FT<:Real, ST<:SurfaceCellType{IT, FT}}","page":"Home","title":"MoM_Kernels.faceSingularityIg","text":"faceSingularityIg(rgt::AbstractVector{FT}, polys::ST, area::FT, \nfacen̂::AbstractVector{FT}) where {IT<:Integer, FT<:Real, ST<:SurfaceCellType{IT, FT}}\n\n计算场点rgt在多边形polys上的奇异性，polys的面积为area，外法向量为facen̂。 计算结果为：\n\nbeginaligned\nI_gS  = intg(R)dS\n        = sum_n=0^SglrOrdercoeffgreen(n)I^n-1_RS\nI^n_RS  = intR^ndS\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.faceSingularityIgIvecg-Union{Tuple{ST}, Tuple{FT}, Tuple{AbstractVector{FT}, ST, Any, AbstractVector}} where {FT<:Real, ST<:SurfaceCellType}","page":"Home","title":"MoM_Kernels.faceSingularityIgIvecg","text":"faceSingularityIgIvecg(rgt::AbstractVector{FT}, polys::ST, area, \n    facen̂::AbstractVector) where {FT<:Real, ST<:SurfaceCellType{IT, FT}}\n\n计算场点rgt在多边形polys上的奇异性，polys的面积为area，外法向量为facen̂。 计算结果为：\n\nbeginaligned\nI_gS  = intg(R)dS\n        = sum_n=0^SglrOrdercoeffgreen(n)I^n-1_RS\nboldsymbolI_gS  = intboldsymbolRg(R)dS\n        = sum_l_jhatbmu_j sum_n=0^SglrOrderfraccoeffgreen(n)n+1I^n-1_lr + dbmnI^n-1_gS\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.faceSingularityIgIvecgI∇gS-Union{Tuple{ST}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, ST, FT, AbstractVector{FT}}} where {IT<:Integer, FT<:Real, ST<:SurfaceCellType{IT, FT}}","page":"Home","title":"MoM_Kernels.faceSingularityIgIvecgI∇gS","text":"面上的近奇异性 rgt, 为场三角形的求积点 tris::TriangleInfo{IT, FT}， 源三角形信息 计算得到结果:: IgS     =   ∫ g(R) dS'      =   ∑ₙ₌₀(coeffgreen(n)IR[n-1]) IvecgS  =   ∫ Rvec g(R) dS' =   ∑ₗⱼ ûⱼ ∑ₙ₌₀(coeffgreen(n)/(n+1)Ilᵣ[n-1]) + dn̂IgS I∇gS    =   ∫ ∇g(R) dS'     =   ∑ₙ₌₀VSC₃ⁿ*(-1/(n+2)∑ₗⱼûⱼIlᵣ[n+2] + dn̂IgS )\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.faceSingularityIᵣIᵨ-Union{Tuple{FT}, Tuple{IT}, Tuple{StaticArraysCore.MMatrix{3, 7, FT, 21}, TriangleInfo{IT, FT}}} where {IT<:Integer, FT<:Real}","page":"Home","title":"MoM_Kernels.faceSingularityIᵣIᵨ","text":"面上的近奇异性 rgts::MMatrix{GQPNTriSglr, 3, Complex{FT}}, 为场三角形的所有高斯求积点 tris::TriangleInfo{IT, FT}， 源三角形信息 计算得到结果:: r0tProj2s::MMatrix{3, GQPNTriSglr, Complex{FT}, 3GQPNTriSglr}, 积分点在源三角形上的投影点 Iᵣ  =   ∫ 1/R dS'   =   ∑₁³(p02ilfᵢ - dtsAbsβᵢ) Iᵨ  =   ∫ ρ/R dS'   =   0.5∑₁³{ûᵢ[(R0^2fᵢ + li⁺R⁺ - li⁻*R⁻)]}\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.farEPlot-Union{Tuple{FT}, Tuple{Any, Any, Matrix{FT}, Matrix{FT}}} where FT<:Real","page":"Home","title":"MoM_Kernels.farEPlot","text":"farE 绘图\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.farField-Tuple{Any, Any, Any}","page":"Home","title":"MoM_Kernels.farField","text":"在球坐标为r̂θϕ处计算辐射积分，采用RWG基函数时，三角形上没有统一的电流值，每一点上都是三边电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙlₙρₙ/(2Sₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙlₙρₙ/2)exp(jkr̂(θ, ϕ)⋅rₙ) )\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.farField-Union{Tuple{BFT}, Tuple{CT}, Tuple{VT}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Any}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Any, Type{BFT}}} where {VT<:VolumeCellType, CT<:Complex, BFT<:BasisFunctionType}","page":"Home","title":"MoM_Kernels.farField","text":"在球坐标为r̂θϕ处计算辐射积分，采用SWG基函数时，四面体上没有统一的电流值，每一点上都是四个SWG基函数电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙsₙρₙ/(3Vₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙsₙρₙ/3)exp(jkr̂(θ, ϕ)⋅rₙ) )\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.farField-Union{Tuple{BFT}, Tuple{ST}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{ST}, Any}, Tuple{Any, Any, Vector{CT}, Vector{ST}, Any, Type{BFT}}} where {CT<:Complex, ST<:TriangleInfo, BFT<:RWG}","page":"Home","title":"MoM_Kernels.farField","text":"在球坐标为r̂θϕ处计算辐射积分，采用RWG基函数时，三角形上没有统一的电流值，每一点上都是三边电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙlₙρₙ/(2Sₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙlₙρₙ/2)exp(jkr̂(θ, ϕ)⋅rₙ) )\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.farField-Union{Tuple{VT}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Any}} where {CT<:Complex, VT<:(AbstractVector)}","page":"Home","title":"MoM_Kernels.farField","text":"在球坐标为r̂θϕ处计算辐射积分，采用SWG基函数时，四面体上没有统一的电流值，每一点上都是四个SWG基函数电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙsₙρₙ/(3Vₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙsₙρₙ/3)exp(jkr̂(θ, ϕ)⋅rₙ) )\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.func4Cube1stkInterval-Tuple{MoM_Kernels.CubeInfo}","page":"Home","title":"MoM_Kernels.func4Cube1stkInterval","text":"这六个函数用于寻找盒子的子盒子区间内的比较函数，多重分派以实现\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:PWC}","page":"Home","title":"MoM_Kernels.geoElectricJCal","text":"计算六面体上的电流。 分片常数基 PWC 基函数 电流基函数公式为：Jₙ = κₙIₙfₙ 同一个六面体面片上存在 x̂, ŷ, ẑ 方向的三个基函数，因此 Jₜ = κₜ ∑ₜₙ₌₁³Iₜₙfₜₙ 输入： ICoeff          ::Vector{Complex{FT}}  计算得到的电流系数 hexasInfo      ::Vector{HexahedraInfo{IT, FT, CT}},  输出值: Jhexa          ::Marrix{Complex{FT}}, 六面体上的电流\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:RBF}","page":"Home","title":"MoM_Kernels.geoElectricJCal","text":"计算六面体上的电流。 分片常数基 RBF 基函数 电流基函数公式为：Jₙ = κₙIₙfₙ 同一个六面体面片上存在 6 或 3 个基函数，因此 Jₜ = ∑ₜₙ₌₁ Iₜₙfₜₙ 输入： ICoeff          ::Vector{Complex{FT}}  计算得到的电流系数 hexasInfo       ::Vector{HexahedraInfo{IT, FT, CT}},  输出值: Jhexa          ::Marrix{Complex{FT}}, 六面体上加权后的电流\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:PWC}","page":"Home","title":"MoM_Kernels.geoElectricJCal","text":"计算四面体上的电流。 分片常数基 PWC 基函数 电流基函数公式为：Jₙ = κₙIₙfₙ 同一个四面体面片上存在 x̂, ŷ, ẑ 方向的三个基函数，因此 Jₜ = κₜ ∑ₜₙ₌₁³Iₜₙfₜₙ 输入： ICoeff          ::Vector{Complex{FT}}  计算得到的电流系数 tetrasInfo      ::Vector{TetrahedraInfo{IT, FT, CT}},  输出值: Jtetra          ::Marrix{Complex{FT}}, 四面体上的电流\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:SWG}","page":"Home","title":"MoM_Kernels.geoElectricJCal","text":"计算四面体上的电流。 分片常数基 SWG 基函数 电流基函数公式为：Jₙ = κₙIₙfₙ 同一个四面体面片上存在四个基函数，因此 Jₜ = ∑ₜₙ₌₁⁴ Iₜₙfₜₙ 输入： ICoeff          ::Vector{Complex{FT}}  计算得到的电流系数 tetrasInfo      ::Vector{TetrahedraInfo{IT, FT, CT}},  输出值: Jtetra          ::Marrix{Complex{FT}}, 四面体上加权后的电流\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}}, Tuple{Vector{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}, BFT<:RWG}","page":"Home","title":"MoM_Kernels.geoElectricJCal","text":"计算三角形面片上的加权电流。 电流基函数公式为：Jₙ = Iₙfₙ 同一个三角形面片上存在三个基函数，因此 Jₜ = ∑ₜₙ₌₁³ Iₜₙfₜₙ 输入： ICoeff          ::Vector{Complex{FT}}  计算得到的电流系数 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，三角形信息 输出值: Jtri         ::Marrix{Complex{FT}}, 三角形上加权后的电流\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.getAggSBFOnLevel-Union{Tuple{BFT}, Tuple{ST}, Tuple{Any, Vector{ST}, Vector{BFT}}} where {ST<:SurfaceCellType, BFT<:BasisFunctionType}","page":"Home","title":"MoM_Kernels.getAggSBFOnLevel","text":"根据积分方程类型计算基层聚合项\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.getAggSBFOnLevel-Union{Tuple{BFT}, Tuple{VT}, Tuple{Any, Vector{VT}, Vector{BFT}}} where {VT<:VolumeCellType, BFT<:BasisFunctionType}","page":"Home","title":"MoM_Kernels.getAggSBFOnLevel","text":"根据积分方程类型计算基层聚合项\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.getAggSBFOnLevel-Union{Tuple{VT2}, Tuple{VT1}, Tuple{Any, Vector{VT1}, Vector{VT2}}} where {VT1<:(AbstractVector), VT2<:(AbstractVector)}","page":"Home","title":"MoM_Kernels.getAggSBFOnLevel","text":"根据积分方程类型计算基层聚合项\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.getBfsCenter-Union{Tuple{Vector{BFT}}, Tuple{BFT}} where BFT<:BasisFunctionType","page":"Home","title":"MoM_Kernels.getBfsCenter","text":"计算基函数中心的数组，用于方便混合基函数使用时的情况\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.getBfsCenter-Union{Tuple{Vector{VT}}, Tuple{VT}} where VT<:(AbstractVector)","page":"Home","title":"MoM_Kernels.getBfsCenter","text":"计算基函数中心的数组，用于方便混合基函数使用时的情况\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.getCubeIDsWithGeos-Tuple{Any, Any}","page":"Home","title":"MoM_Kernels.getCubeIDsWithGeos","text":"找到 geosInfo 所在的所有 cude id\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.getExcitationVector-Union{Tuple{VST}, Tuple{Vector{VST}, Any, Any}} where VST<:SurfaceCellType","page":"Home","title":"MoM_Kernels.getExcitationVector","text":"根据几何信息与基函数数量，计算激励向量 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 nbf::       基函数数量 source::    激励源 返回： V::         激励向量\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.getExcitationVector-Union{Tuple{VST}, Tuple{Vector{VST}, Any, Any}} where VST<:VolumeCellType","page":"Home","title":"MoM_Kernels.getExcitationVector","text":"根据几何信息与基函数数量，计算激励向量 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 nbf::       基函数数量 source::    激励源 返回： V::         激励向量\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.getExcitationVector-Union{Tuple{VT}, Tuple{Vector{VT}, Any, Any}} where VT<:(AbstractVector)","page":"Home","title":"MoM_Kernels.getExcitationVector","text":"根据几何信息与基函数数量，计算激励向量 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 nbf::       基函数数量 source::    激励源 返回： V::         激励向量\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.getGeoIDsInCubeChunk-Tuple{Any, Tuple}","page":"Home","title":"MoM_Kernels.getGeoIDsInCubeChunk","text":"getGeoIDsInCubeChunk(cubes, ckunkIndice)\n\n获取 ckunkIndice 内的所有 cube 的 geo ID ， 返回为 Tuple 形式以适应数组索引相关API\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.getGeoIDsInCubeChunk-Tuple{Any, UnitRange}","page":"Home","title":"MoM_Kernels.getGeoIDsInCubeChunk","text":"getGeoIDsInCubeChunk(cubes, ckunkIndice)\n\n获取 ckunkIndice 内的所有 cube 的 geo ID ， 返回为 Tuple 形式以适应数组索引相关API\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.getGeosInterval-Tuple{T} where T<:(AbstractVector)","page":"Home","title":"MoM_Kernels.getGeosInterval","text":"获取几何信息数组的区间，针对普通 Vector 和 OffsetVector 分别派发\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.getGeosInterval-Tuple{T} where T<:(OffsetArrays.OffsetVector{T} where T)","page":"Home","title":"MoM_Kernels.getGeosInterval","text":"获取几何信息数组的区间，针对普通 Vector 和 OffsetVector 分别派发\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.getImpedanceMatAndExciteV-Tuple{Any, Integer, Any}","page":"Home","title":"MoM_Kernels.getImpedanceMatAndExciteV","text":"根据几何信息与基函数数量，计算阻抗矩阵和激励向量 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 nbf::       基函数数量 source::    激励源 返回： Zmat::      阻抗矩阵 V::         激励向量\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.getImpedanceMatAndExciteV-Tuple{Any, Vector, Any}","page":"Home","title":"MoM_Kernels.getImpedanceMatAndExciteV","text":"根据几何信息与基函数数量，计算阻抗矩阵和激励向量 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 bfsInfo::   基函数信息 source::    激励源 返回： Zmat::      阻抗矩阵 V::         激励向量\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.getImpedanceMatrix-Union{Tuple{ST}, Tuple{Vector{ST}, Integer}} where ST<:SurfaceCellType","page":"Home","title":"MoM_Kernels.getImpedanceMatrix","text":"根据几何信息与基函数数量，计算阻抗矩阵 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 nbf::       基函数数量 返回： Zmat\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.getImpedanceOpt-Tuple{Any, Any}","page":"Home","title":"MoM_Kernels.getImpedanceOpt","text":"根据几何信息与基函数数量，计算阻抗矩阵算子 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 nbf::       基函数数量 source::    激励源 返回： Zopt::      阻抗矩阵算子，由近场稀疏矩阵和远场八叉树聚合、转移、解聚组成 V::         激励向量 Octree::    八叉树 ZnearCSC::  阻抗矩阵近场元\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.getImpedanceOptAndExciteVOctree-Tuple{Any, Any, Any}","page":"Home","title":"MoM_Kernels.getImpedanceOptAndExciteVOctree","text":"根据几何信息与基函数数量，计算阻抗矩阵算子和激励向量 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 nbf::       基函数数量 source::    激励源 返回： Zopt::      阻抗矩阵算子，由近场稀疏矩阵和远场八叉树聚合、转移、解聚组成 V::         激励向量 Octree::    八叉树 ZnearCSC::  阻抗矩阵近场元\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.getLeafCubeL-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:HexahedraInfo","page":"Home","title":"MoM_Kernels.getLeafCubeL","text":"六面体从网格平均尺寸设置整体的叶层盒子边长\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.getLeafCubeL-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:TetrahedraInfo","page":"Home","title":"MoM_Kernels.getLeafCubeL","text":"四面体从网格平均尺寸设置整体的叶层盒子边长\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.getLeafCubeL-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:TriangleInfo","page":"Home","title":"MoM_Kernels.getLeafCubeL","text":"三角形面网格直接设置为的叶层盒子边长\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.getLeafCubeL-Union{Tuple{Vector{T}}, Tuple{T}} where T<:(AbstractVector)","page":"Home","title":"MoM_Kernels.getLeafCubeL","text":"混合网格从第2类里的网格平均尺寸设置整体的叶层盒子边长\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.getNeiFarNeighborCubeIDs-Tuple{Any, Tuple}","page":"Home","title":"MoM_Kernels.getNeiFarNeighborCubeIDs","text":"getNeiFarNeighborCubeIDs(cubes, chunkIndice::Tuple)\n\n\ngetFarNeighborCubeIDs(cubes, chunkIndice)\n\n获取 ckunkIndice 内的所有 cube 的 远亲盒子ID， 返回为 Tuple 形式以适应数组索引相关API\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.getNeighborCubeIDs-Tuple{Any, Tuple}","page":"Home","title":"MoM_Kernels.getNeighborCubeIDs","text":"getNeighborCubeIDs(cubes, chunkIndice)\n\n获取 ckunkIndice 内的所有 cube 的 邻盒子ID， 返回为 Tuple 形式以适应数组索引相关API\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.getOctreeAndReOrderBFs!-Tuple{Any, Any}","page":"Home","title":"MoM_Kernels.getOctreeAndReOrderBFs!","text":"根据基函数中心位置构建八叉树，并重排基函数信息、将新基函数 ID 赋值给几何元信息数组 返回值： nLevels::   层数 octree::    得到的八叉树 leafCubeEdgel:: 控制叶层盒子大小 isDistribute:: 控制是否为分布式计算\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.get_Interpolation_Method-Tuple{Symbol}","page":"Home","title":"MoM_Kernels.get_Interpolation_Method","text":"获取插值算法\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.get_chunks_minmax_col-Tuple{Any}","page":"Home","title":"MoM_Kernels.get_chunks_minmax_col","text":"get_chunks_minmax_col(matchunks)\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.get_leafCubeSize-Tuple{}","page":"Home","title":"MoM_Kernels.get_leafCubeSize","text":"获取叶层盒子边长\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.get_partition-Tuple{Any, Any, Any}","page":"Home","title":"MoM_Kernels.get_partition","text":"get_partition(nCubes, sizePoles, np)\n\n根据给定的盒子数、多极子数、进程数返回该层 pattern 的三个维度的划分数量。\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.get_partition_map-Tuple{Any, Any}","page":"Home","title":"MoM_Kernels.get_partition_map","text":"根据 partition 计算在盒子方向本层所有 rank 到子层所有 rank 的 map。\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.gq_xsws_on_sphere-Tuple{Any}","page":"Home","title":"MoM_Kernels.gq_xsws_on_sphere","text":"gq_xsws_on_sphere(L)\n\n计算单位球面 2(L+1) 阶高斯求积的采样点坐标权重\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.greenfunc_star-Union{Tuple{T}, Tuple{StaticArraysCore.StaticArray{Tuple{3}, T, 1}, StaticArraysCore.StaticArray{Tuple{3}, T, 1}}} where T<:AbstractFloat","page":"Home","title":"MoM_Kernels.greenfunc_star","text":"greenfunc_star(pa::Vec3D{T}, pb::Vec3D{T}[; k=Params.K_0, taylorOrder = SglrOrder]) where {T<:AbstractFloat}\n\n归一化格林函数 4πG(R) 泰勒展开后去奇异项：\n\ng^*(R)    = frace^-jkRR - frac1R\n            = sum_n=1^SglrOrderfrac-jk^nnR^n-1\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.iluPrecondition-Tuple{Any, Any}","page":"Home","title":"MoM_Kernels.iluPrecondition","text":"从 IncompleteLU.jl[https://github.com/haampie/IncompleteLU.jl.git]  包实现ilu, 再次封装是因为要加入一些判断\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.impedancemat4CFIE4PEC-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{TriangleInfo{IT, FT}, 1}, Integer, Type{BFT}}} where {IT, FT, BFT<:RWG}","page":"Home","title":"MoM_Kernels.impedancemat4CFIE4PEC","text":"本函数用于计算PEC的CFIE阻抗矩阵。 输入信息： trianglesInfo:  为包含三角形信息实例的向量 nrwg        :  基函数数目 返回值 Zmat         :  阻抗矩阵\n\n注意，此程序由于采用的对三角形循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.impedancemat4EFIE4PEC!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{Complex{FT}, 2}, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT, FT, BFT<:RWG}","page":"Home","title":"MoM_Kernels.impedancemat4EFIE4PEC!","text":"本函数用于在有矩阵的情况下计算PEC的EFIE阻抗矩阵。 输入信息： Zmat trianglesInfo:  为包含三角形信息实例的向量 nrwg        :  基函数数目 返回值 Zmat         :  阻抗矩阵\n\n注意，此程序由于采用的对三角形循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.impedancemat4EFIE4PEC-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{TriangleInfo{IT, FT}, 1}, Integer, Type{BFT}}} where {IT, FT, BFT<:RWG}","page":"Home","title":"MoM_Kernels.impedancemat4EFIE4PEC","text":"本函数用于计算PEC的EFIE阻抗矩阵。 输入信息： trianglesInfo:  为包含三角形信息实例的向量 nrwg        :  基函数数目 返回值 Zmat         :  阻抗矩阵\n\n注意，此程序由于采用的对三角形循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.impedancemat4MFIE4PEC-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{TriangleInfo{IT, FT}, 1}, Integer, Type{BFT}}} where {IT, FT, BFT<:RWG}","page":"Home","title":"MoM_Kernels.impedancemat4MFIE4PEC","text":"本函数用于计算PEC的MFIE阻抗矩阵。 输入信息： trianglesInfo:  为包含三角形信息实例的向量 nrwg        :  基函数数目 返回值 Zmat         :  阻抗矩阵\n\n注意，此程序由于采用的对三角形循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.impedancemat4RWGPWC!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Any}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.impedancemat4RWGPWC!","text":"RWG + PWC 部分的阻抗矩阵\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.impedancemat4RWGPWC!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Any}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.impedancemat4RWGPWC!","text":"RWG + PWC 部分的阻抗矩阵\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.impedancemat4RWGRBF!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.impedancemat4RWGRBF!","text":"RWG + RBF 部分的阻抗矩阵\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.impedancemat4RWGSWG!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}}} where {IT<:Integer, FT<:AbstractFloat, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.impedancemat4RWGSWG!","text":"RWG + SWG 部分的阻抗矩阵\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT<:PWC}","page":"Home","title":"MoM_Kernels.impedancemat4VIE!","text":"本函数用于计算介质体的 PWC 基函数下的 EFIE 阻抗矩阵。 输入信息： hexasInfo::AbstractVector{HexahedraInfo{IT, FT, CT}},  为包含六面体信息实例的向量 tetrasInfo::AbstractVector{TetrahedraInfo{IT, FT, CT}}, 为包含四面体信息实例的向量 nPWC        :  基函数数目 返回值 Zmat        :  阻抗矩阵\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT<:PWC}","page":"Home","title":"MoM_Kernels.impedancemat4VIE!","text":"本函数用于计算介质体的 PWC 基函数下的 EFIE 阻抗矩阵。 输入信息： hexasInfo  :  为包含六面体信息实例的向量 nrwg        :  基函数数目 返回值 Zmat        :  阻抗矩阵\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT<:RBF}","page":"Home","title":"MoM_Kernels.impedancemat4VIE!","text":"本函数用于计算介质的EFIE阻抗矩阵。 输入信息： hexasInfo  :  为包含六面体信息实例的向量 nrbf        :  基函数数目 返回值 Zmat         :  阻抗矩阵\n\n注意，此程序由于采用的对六面体循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT<:PWC}","page":"Home","title":"MoM_Kernels.impedancemat4VIE!","text":"本函数用于计算介质体的 PWC 基函数下的 EFIE 阻抗矩阵。 输入信息： hexasInfo::AbstractVector{HexahedraInfo{IT, FT, CT}},  为包含六面体信息实例的向量 tetrasInfo::AbstractVector{TetrahedraInfo{IT, FT, CT}}, 为包含四面体信息实例的向量 nPWC        :  基函数数目 返回值 Zmat        :  阻抗矩阵\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT<:PWC}","page":"Home","title":"MoM_Kernels.impedancemat4VIE!","text":"本函数用于计算介质体的 PWC 基函数下的 EFIE 阻抗矩阵。 输入信息： tetrasInfo  :  为包含四面体信息实例的向量 nrwg        :  基函数数目 返回值 Zmat        :  阻抗矩阵\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT<:SWG}","page":"Home","title":"MoM_Kernels.impedancemat4VIE!","text":"本函数用于计算介质的 EFIE 阻抗矩阵。 输入信息： Zmat       :   已初始化的阻抗矩阵 tetrasInfo  :  为包含四面体信息实例的向量 nswg        :  基函数数目 返回值 Zmat         :  阻抗矩阵\n\n注意，此程序由于采用的对四面体循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT<:PWC}","page":"Home","title":"MoM_Kernels.impedancemat4VIE","text":"本函数用于计算介质体的 PWC 基函数下的 EFIE 阻抗矩阵。 输入信息： hexasInfo  :  为包含六面体信息实例的向量 nPWC        :  基函数数目 返回值 Zmat        :  阻抗矩阵\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT<:RBF}","page":"Home","title":"MoM_Kernels.impedancemat4VIE","text":"本函数用于计算介质的EFIE阻抗矩阵。 输入信息： hexasInfo  :  为包含六面体信息实例的向量 nrbf        :  基函数数目 返回值 Zmat         :  阻抗矩阵\n\n注意，此程序由于采用的对六面体循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT<:PWC}","page":"Home","title":"MoM_Kernels.impedancemat4VIE","text":"本函数用于计算介质体的 PWC 基函数下的 EFIE 阻抗矩阵。 输入信息： tetrasInfo  :  为包含四面体信息实例的向量 nrwg        :  基函数数目 返回值 Zmat        :  阻抗矩阵\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT<:SWG}","page":"Home","title":"MoM_Kernels.impedancemat4VIE","text":"本函数用于计算介质的EFIE阻抗矩阵。 输入信息： tetrasInfo  :  为包含四面体信息实例的向量 nswg        :  基函数数目 返回值 Zmat         :  阻抗矩阵\n\n注意，此程序由于采用的对四面体循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{VT}, Tuple{AbstractVector{VT}, Integer, Type{BFT}}} where {VT<:(AbstractVector), BFT<:PWC}","page":"Home","title":"MoM_Kernels.impedancemat4VIE","text":"本函数用于计算混合网格（四面体+六面体）下介质体的 PWC 基函数下的 EFIE 阻抗矩阵。 输入信息： geosInfo    :  为包含四面体信息实例的向量 nPWC        :  基函数数目 返回值 Zmat        :  阻抗矩阵\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.impedancemat4VSIE-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT<:(AbstractVector)","page":"Home","title":"MoM_Kernels.impedancemat4VSIE","text":"计算VSIE的矩阵\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.impedancemat4VSIERWGPWC-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT<:(AbstractVector)","page":"Home","title":"MoM_Kernels.impedancemat4VSIERWGPWC","text":"本函数用于计算金属介质混合体的EFIE阻抗矩阵。 输入信息： geosInfo    :  为包含几何体信息实例的向量 nbf        :  基函数数目 返回值 Zmat         :  阻抗矩阵\n\n注意，此程序由于采用的对网格元（几何体）循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.impedancemat4VSIERWGRBF-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT<:(AbstractVector)","page":"Home","title":"MoM_Kernels.impedancemat4VSIERWGRBF","text":"本函数用于计算金属介质混合体的EFIE阻抗矩阵。 输入信息： geosInfo    :  为包含几何体信息实例的向量 nbf        :  基函数数目 返回值 Zmat         :  阻抗矩阵\n\n注意，此程序由于采用的对网格元（几何体）循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.impedancemat4VSIERWGSWG-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT<:(AbstractVector)","page":"Home","title":"MoM_Kernels.impedancemat4VSIERWGSWG","text":"本函数用于计算金属介质混合体的EFIE阻抗矩阵。 输入信息： geosInfo    :  为包含几何体信息实例的向量 nbf        :  基函数数目 返回值 Zmat         :  阻抗矩阵\n\n注意，此程序由于采用的对网格元（几何体）循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.initialVMulZchunks!-Tuple{T} where T<:MoM_Kernels.ZnearChunksStruct","page":"Home","title":"MoM_Kernels.initialVMulZchunks!","text":"初始化 阻抗矩阵 右乘 向量 乘积的 分布式数组\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.initialZchunksMulV!-Tuple{T} where T<:MoM_Kernels.ZnearChunksStruct","page":"Home","title":"MoM_Kernels.initialZchunksMulV!","text":"初始化 阻抗矩阵 左乘 向量 乘积的 分布式数组\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.initialZnearCSC-Tuple{Any, Int64}","page":"Home","title":"MoM_Kernels.initialZnearCSC","text":"根据八叉树层信息初始化近场矩阵元\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.initialZnearCSR-Tuple{Any, Int64}","page":"Home","title":"MoM_Kernels.initialZnearCSR","text":"根据八叉树层信息初始化 CSR 压缩稀疏行 (用 transpose 实现) 近场矩阵元\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.initialZnearChunks-Tuple{Any, AbstractVector}","page":"Home","title":"MoM_Kernels.initialZnearChunks","text":"根据八叉树盒子信息初始化 cube 对应的近场矩阵元块儿\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.initialmmulvStruct-Tuple{Any}","page":"Home","title":"MoM_Kernels.initialmmulvStruct","text":"根据八叉树盒子信息初始化 cube 对应的近场矩阵元块儿\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.initialvmulmStruct-Tuple{Any}","page":"Home","title":"MoM_Kernels.initialvmulmStruct","text":"根据八叉树盒子信息初始化 cube 对应的近场矩阵元块儿\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.inputParameters-Tuple{}","page":"Home","title":"MoM_Kernels.inputParameters","text":"inputParameters(;args...)\n\n用于输入仿真参数，并修改奇异性处理中频率相关常量。 详见 inputBasicParameters 和 modiSingularityRelatedConsts!。\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.integral1DXW-Union{Tuple{FT}, Tuple{IT}, Tuple{FT, FT, IT, Symbol}} where {IT<:Integer, FT<:Real}","page":"Home","title":"MoM_Kernels.integral1DXW","text":"计算分别采用高斯求积、中点求积计算 θ,ϕ 方向的采样点的坐标、权重 lb::FT，  积分区域下界 hb::FT,   积分区域上界 Nsample::IT, 采样点数 mod::Symbol， 模式，接受 :uni, 均值积分 :glq, 高斯-勒让德积分 两种模式\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.interpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}","page":"Home","title":"MoM_Kernels.interpolate!","text":"拉格朗日单步插值\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.interpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}","page":"Home","title":"MoM_Kernels.interpolate!","text":"拉格朗日分步插值\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.interpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}","page":"Home","title":"MoM_Kernels.interpolate","text":"拉格朗日单步插值\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.interpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}","page":"Home","title":"MoM_Kernels.interpolate","text":"拉格朗日分步插值\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.interpolationCSCMatCal-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.GLPolesInfo{FT}, MoM_Kernels.GLPolesInfo{FT}, IT}} where {IT<:Integer, FT<:Real}","page":"Home","title":"MoM_Kernels.interpolationCSCMatCal","text":"采用局部插值、两步插值法，计算局部坐标到全局坐标的稀疏插值矩阵，Julia数据存储为列主的，因此使用 压缩稀疏列(Compressed Sparse Column, CSC) pLevelPoles::GLPolesInfo{FT}， 父层多极子信息 tLevelPoles::GLPolesInfo{FT}， 本层多极子信息\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.iterSolverSet-Tuple{Symbol}","page":"Home","title":"MoM_Kernels.iterSolverSet","text":"迭代求解器选择\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.levelIntegralInfoCal-Union{Tuple{FT}, Tuple{FT, Union{Val{:Lagrange2Step}, Val{:Lagrange1Step}}}} where FT<:Real","page":"Home","title":"MoM_Kernels.levelIntegralInfoCal","text":"计算八叉树的积分相关信息，包括截断项、各层积分点和求积权重数据 输入: levelCubeEdgel::FT,  层盒子边长, 一般叶层为0.25λ，其中 λ 为区域局部波长。 返回值 L           ::IT， 层 截断项 levelsPoles ::Vector{GLPolesInfo{FT}}，从叶层到第 “2” 层的角谱空间采样信息\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.loadCurrent-Tuple{Any}","page":"Home","title":"MoM_Kernels.loadCurrent","text":"读取电流系数\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.memoryAllocationOnLevels!-Union{Tuple{LV}, Tuple{IT}, Tuple{Integer, Dict{IT, LV}}} where {IT<:Integer, LV<:MoM_Kernels.LevelInfo}","page":"Home","title":"MoM_Kernels.memoryAllocationOnLevels!","text":"预分配各层上的聚合项、解聚项\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.modiSingularityRelatedConsts!-Tuple{}","page":"Home","title":"MoM_Kernels.modiSingularityRelatedConsts!","text":"用于输入参数（特指频率）改变时的更改相关常数项\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.octreeXWNCal-Union{Tuple{FT}, Tuple{IT}, Tuple{FT, FT, IT, Symbol}} where {IT<:Integer, FT<:Real}","page":"Home","title":"MoM_Kernels.octreeXWNCal","text":"计算各层八叉树求积坐标、求积权重 lb::FT，  积分区域下界 hb::FT,   积分区域上界 nlevels::IT, 八叉树叶层ID mod::Symbol， 模式，接受 :uni, 均值积分(ϕ方向) :glq, 高斯-勒让德积分(θ方向) 两种模式\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.pickCycleVec-Union{Tuple{T}, Tuple{Integer, Vector{T}}} where T<:Real","page":"Home","title":"MoM_Kernels.pickCycleVec","text":"根据循环向量 cycleVec 的周期性索引超出上下界的 index 对应的值\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.pickθ-Union{Tuple{T}, Tuple{Integer, Vector{T}}} where T<:Real","page":"Home","title":"MoM_Kernels.pickθ","text":"利用 θ 在极点附近的对称性计算索引超出上下界的 θ 值\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.pickϕ-Union{Tuple{TT}, Tuple{Integer, Vector{TT}}} where TT<:Real","page":"Home","title":"MoM_Kernels.pickϕ","text":"利用 ϕ 的周期性索引超出上下界的 ϕ 值\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.radarCrossSection-Union{Tuple{BFT}, Tuple{CT}, Tuple{VT}, Tuple{Any, Any, Vector{CT}, Vector{VT}}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Type{BFT}}} where {VT<:VolumeCellType, CT<:Complex, BFT<:BasisFunctionType}","page":"Home","title":"MoM_Kernels.radarCrossSection","text":"在球坐标为r̂θϕ处计算辐射积分，采用SWG基函数时，四面体上没有统一的电流值，每一点上都是四个SWG基函数电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙsₙρₙ/(3Vₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙsₙρₙ/3)exp(jkr̂(θ, ϕ)⋅rₙ) )\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.radarCrossSection-Union{Tuple{BFT}, Tuple{ST}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{ST}}, Tuple{Any, Any, Vector{CT}, Vector{ST}, Type{BFT}}} where {CT<:Complex, ST<:TriangleInfo, BFT<:RWG}","page":"Home","title":"MoM_Kernels.radarCrossSection","text":"在球坐标为r̂θϕ处计算辐射积分，采用RWG基函数时，三角形上没有统一的电流值，每一点上都是三边电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙlₙρₙ/(2Sₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙlₙρₙ/2)exp(jkr̂(θ, ϕ)⋅rₙ) )\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.radarCrossSection-Union{Tuple{VT}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{VT}}} where {CT<:Complex, VT<:(AbstractVector)}","page":"Home","title":"MoM_Kernels.radarCrossSection","text":"在球坐标为r̂θϕ处计算辐射积分，采用SWG基函数时，四面体上没有统一的电流值，每一点上都是四个SWG基函数电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙsₙρₙ/(3Vₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙsₙρₙ/3)exp(jkr̂(θ, ϕ)⋅rₙ) )\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.raditionalIntegralNCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Array{TriangleInfo{IT, FT}, 1}, Array{CT}}} where {IT<:Integer, FT<:Real, CT<:Complex}","page":"Home","title":"MoM_Kernels.raditionalIntegralNCal","text":"在设定好的观测角度上的球坐标处计算辐射积分，采用RWG基函数时，三角形上没有统一的电流值，每一点上都是三边电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙlₙρₙ/(2Sₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙlₙρₙ/2)exp(jkr̂(θ, ϕ)⋅rₙ) )\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Matrix{CT}}} where {IT<:Integer, FT<:Real, CT<:Complex}","page":"Home","title":"MoM_Kernels.raditionalIntegralNθϕCal","text":"在球坐标为r̂θϕ处计算辐射积分，采用 RBF 基函数时，六面体上没有统一的电流值 N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dV)\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Matrix{CT}}} where {IT<:Integer, FT<:Real, CT<:Complex}","page":"Home","title":"MoM_Kernels.raditionalIntegralNθϕCal","text":"在球坐标为r̂θϕ处计算辐射积分，采用 SWG 基函数时，四面体上没有统一的电流值，每一点上都是四面电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dV)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁⁴ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dV)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁⁴ IₙSₙρₙ/(3Vₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁⁴ IₙSₙρₙ/3)exp(jkr̂(θ, ϕ)⋅rₙ) )\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, Array{TriangleInfo{IT, FT}, 1}, Array{CT, 3}}} where {IT<:Integer, FT<:Real, CT<:Complex}","page":"Home","title":"MoM_Kernels.raditionalIntegralNθϕCal","text":"在球坐标为r̂θϕ处计算辐射积分，采用RWG基函数时，三角形上没有统一的电流值，每一点上都是三边电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙlₙρₙ/(2Sₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙlₙρₙ/2)exp(jkr̂(θ, ϕ)⋅rₙ) )\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, Array{TriangleInfo{IT, FT}, 1}, Matrix{CT}}} where {IT<:Integer, FT<:Real, CT<:Complex}","page":"Home","title":"MoM_Kernels.raditionalIntegralNθϕCal","text":"在球坐标为r̂θϕ处计算辐射积分，采用RWG基函数时，三角形上没有统一的电流值，每一点上都是三边电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙlₙρₙ/(2Sₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙlₙρₙ/2)exp(jkr̂(θ, ϕ)⋅rₙ) )\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.reOrderBasisFunctionAndGeoInfo!-Union{Tuple{VCellT}, Tuple{BFT}, Tuple{IT}, Tuple{Vector{IT}, Vector{VCellT}, Vector{BFT}}} where {IT<:Integer, BFT<:BasisFunctionType, VCellT<:VSCellType}","page":"Home","title":"MoM_Kernels.reOrderBasisFunctionAndGeoInfo!","text":"根据按八叉树重新排序的id重排基函数信息\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.reOrderBasisFunctionAndGeoInfo!-Union{Tuple{VCellT}, Tuple{IT}, Tuple{Vector{IT}, Vector{VCellT}, Val{:PWC}}} where {IT<:Integer, VCellT<:VSCellType}","page":"Home","title":"MoM_Kernels.reOrderBasisFunctionAndGeoInfo!","text":"根据按八叉树重新排序的id重排基函数信息，此函数适用于 PWC 基函数的情况\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.reOrderBasisFunctionAndGeoInfo!-Union{Tuple{VT2}, Tuple{VT1}, Tuple{IT}, Tuple{Vector{IT}, Vector{VT1}, Vector{VT2}}} where {IT<:Integer, VT1<:(AbstractVector), VT2<:(AbstractVector)}","page":"Home","title":"MoM_Kernels.reOrderBasisFunctionAndGeoInfo!","text":"根据按八叉树重新排序的id重排基函数信息\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.reOrderCubeID!-Union{Tuple{LV}, Tuple{Integer, Dict{Int64, LV}, Dict{Int64, Vector{Int64}}}} where LV<:MoM_Kernels.AbstractLevel","page":"Home","title":"MoM_Kernels.reOrderCubeID!","text":"根据排序后的新id重新排列子层盒子以及盒子的邻盒子信息，以将同一个父盒子层的盒子相邻排列，这样有利于计算 更新的量：父层盒子的kidsInterval， 本层的盒子顺序，本层盒子的邻盒子id\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.record_memorys-Tuple{Any}","page":"Home","title":"MoM_Kernels.record_memorys","text":"展示\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.restore_infos-Tuple{}","page":"Home","title":"MoM_Kernels.restore_infos","text":"restore_infos()\n记录各部分内存和各阶段计算时间。\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.saveCubes-Tuple{Any, Any}","page":"Home","title":"MoM_Kernels.saveCubes","text":"saveCubes(cubes, nchunk = ParallelParams.nprocs; name, dir=\"\", kcubeIndices = nothing)\n\n保存盒子。\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.saveCurrent-Tuple{Any}","page":"Home","title":"MoM_Kernels.saveCurrent","text":"保存电流系数\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.saveGeosInfoChunks-Tuple{AbstractVector, Any, AbstractString, Int64}","page":"Home","title":"MoM_Kernels.saveGeosInfoChunks","text":"saveGeosInfoChunks(geos::AbstractVector, cubes, name::AbstractString, nchunk::Int; dir = \"\")\n\n将几何信息保存在 TBW\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.saveLevel","page":"Home","title":"MoM_Kernels.saveLevel","text":"saveLevel(level, np = ParallelParams.nprocs; dir=\"\", kcubeIndices = nothing)\n\n保存层信息。\n\nTBW\n\n\n\n\n\n","category":"function"},{"location":"#MoM_Kernels.saveOctree-Tuple{Any}","page":"Home","title":"MoM_Kernels.saveOctree","text":"saveOctree(octree; dir=\"\")\n\n保存八叉树。\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.saveVec2Chunks-Tuple{AbstractVector, AbstractString, Any}","page":"Home","title":"MoM_Kernels.saveVec2Chunks","text":"saveVec2Chunks(y::AbstractVector, name::AbstractString, indices; dir = \"\")\n\n把向量分块保存。\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.saveVec2Chunks-Tuple{AbstractVector, AbstractString, Int64}","page":"Home","title":"MoM_Kernels.saveVec2Chunks","text":"saveVec2Chunks(y::AbstractVector, name::AbstractString, nchunk::Int; dir = \"\")\n\n把向量分块保存。\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.searchNearCubes-Union{Tuple{IT}, Tuple{Matrix{IT}, Integer}} where IT<:Integer","page":"Home","title":"MoM_Kernels.searchNearCubes","text":"用于寻找邻盒子的函数 输入 cubesID3D::Matrix{Int}，(n×3)盒子在本层的三维坐标 levelID::Integer       层编号，（定义大盒子为（“0” 层），叶层为第“n”层\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.setBFInterval!-Union{Tuple{LV}, Tuple{Integer, Dict{Int64, LV}}} where LV<:MoM_Kernels.AbstractLevel","page":"Home","title":"MoM_Kernels.setBFInterval!","text":"根据已经排序好的层的盒子信息，从叶层到顶层更新盒子包含的基函数区间\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.setBigCube-Union{Tuple{FT}, Tuple{Matrix{FT}, FT}} where FT<:Real","page":"Home","title":"MoM_Kernels.setBigCube","text":"计算包围目标的大盒子信息 输入： nodes::Matrix{FT}，大小为 (3, n) 的用于分割成八叉树的空间点，如基函数的中心坐标，或者为构成网格的所有点 leafCubeEdgel::FT，叶层盒子边长，用于计算总层数和大盒子的坐标信息\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.setGeoIDsInLeafCubes!-Union{Tuple{CBF}, Tuple{Any, Vector{CBF}}} where CBF<:ConstBasisFunction","page":"Home","title":"MoM_Kernels.setGeoIDsInLeafCubes!","text":"用于设置给定层的盒子中包含的几何体，采用常数基函数时，同一个盒子不会出现重复值。\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.setGeoIDsInLeafCubes!-Union{Tuple{LBF}, Tuple{Any, Vector{LBF}}} where LBF<:LinearBasisFunction","page":"Home","title":"MoM_Kernels.setGeoIDsInLeafCubes!","text":"用于设置给定层的盒子中包含的几何体，采用 RWG、SWG、RBF 基函数时，八叉树分组依据为基函数， 同一个几何体会被分在不同的基函数上会被分入入不同的盒子，因此邻盒子中的几何体 id 大概率出现重复值。\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.setGeoIDsInLeafCubes!-Union{Tuple{VT}, Tuple{Any, Vector{VT}}} where VT<:(AbstractVector)","page":"Home","title":"MoM_Kernels.setGeoIDsInLeafCubes!","text":"用于设置给定层的盒子中包含的几何体，采用 RWG、SWG、RBF 基函数时，八叉树分组依据为基函数， 同一个几何体会被分在不同的基函数上会被分入入不同的盒子，因此邻盒子中的几何体 id 大概率出现重复值。\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.setKidLevelFarNeighbors!-Tuple{Any, Any}","page":"Home","title":"MoM_Kernels.setKidLevelFarNeighbors!","text":"寻找子层的远亲盒子 输入:: thisLevel::LevelInfo{IT, FT, IPT}, 本层信息 kidLevel::LevelInfo{IT, FT, IPT}， 子层信息\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.setLevelInfo!-Union{Tuple{FT}, Tuple{Integer, Any, FT, StaticArraysCore.StaticArray{Tuple{3}, FT, 1}}} where FT<:Real","page":"Home","title":"MoM_Kernels.setLevelInfo!","text":"非叶层LevelInfo的构造函数，输入为空间三维坐标数组 levelID::计算层的id leafnodes::Matrix{FT},大小为 (3, n) 的用于分割成八叉树的空间点，如基函数的中心坐标 cubeEdgel::FT，本层盒子边长\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.setLevelInfo!-Union{Tuple{FT}, Tuple{Integer, Matrix{FT}, FT, StaticArraysCore.StaticArray{Tuple{3}, FT, 1}}} where FT<:Real","page":"Home","title":"MoM_Kernels.setLevelInfo!","text":"叶层LevelInfo的构造函数，输入为空间三维坐标数组 nLevels::IT，层 数，亦为叶层层ID leafnodes::Matrix{FT},大小为 (3, n) 的用于分割成八叉树的空间点，如基函数的中心坐标 cubeEdgel::FT，叶层盒子边长 bigCubeLowerCoor::Vec3D{FT}， 大盒子的角坐标\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.setLevelTransFactor!-Union{Tuple{LV}, Tuple{Int64, Dict{Int64, LV}}} where LV<:MoM_Kernels.AbstractLevel","page":"Home","title":"MoM_Kernels.setLevelTransFactor!","text":"计算 第“2”层 到 叶 层的转移因子， 转移因子只存在于远亲组，每层远亲组最多有 7^3 - 3^3 = 316种结果\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.setLevelsCubesKidsIn8!-Union{Tuple{LV}, Tuple{Integer, Dict{Int64, LV}}} where LV<:MoM_Kernels.AbstractLevel","page":"Home","title":"MoM_Kernels.setLevelsCubesKidsIn8!","text":"计算（nLevel-1）-2 层每层的非空盒子的非空子盒子在其8个子盒子中的位置\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.setLevelsShiftFactor!-Union{Tuple{LV}, Tuple{Int64, Dict{Int64, LV}}} where LV<:MoM_Kernels.AbstractLevel","page":"Home","title":"MoM_Kernels.setLevelsShiftFactor!","text":"本函数用于给输入的本(level)层的盒子与其子盒子之间计算相移因子， 由盒子排列的规律性和相移因子的对称性，可知： 只需要计算8个相移因子，即可用于所有盒子到其子盒子的相移， 且这八个盒子关于原点对称的两两之间的相移因子为共轭关系 计算完成直接保存在 level 不再返回\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.setVSC₁₂₃ⁿ!-Tuple{}","page":"Home","title":"MoM_Kernels.setVSC₁₂₃ⁿ!","text":"setVSC₁₂₃ⁿ!()\n\n计算体奇异性三个系数。\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.set_Interpolation_Method!-Tuple{Any}","page":"Home","title":"MoM_Kernels.set_Interpolation_Method!","text":"设置插值算法\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.set_leafCubeSize!-Union{Tuple{}, Tuple{FT}} where FT<:AbstractFloat","page":"Home","title":"MoM_Kernels.set_leafCubeSize!","text":"设置叶层盒子边长\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.singularF1-Union{Tuple{FT}, NTuple{4, FT}} where FT<:AbstractFloat","page":"Home","title":"MoM_Kernels.singularF1","text":"singularF1(a::FT, b::FT, c::FT, d::FT) where{FT<:AbstractFloat}\n\n计算边长为a, b, c, d的四边形重合时的奇异性F1项，即 intintfrac1RdS 的解析值。\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.singularF1-Union{Tuple{FT}, Tuple{FT, FT, FT}} where FT<:AbstractFloat","page":"Home","title":"MoM_Kernels.singularF1","text":"singularF1(a::FT, b::FT, c::FT) where{FT<:AbstractFloat}\n\n计算边长为a, b, c的三角形重合时的奇异性F1项，即 intintfrac1RdS 的解析值。\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.singularF21-Union{Tuple{FT}, NTuple{4, FT}} where FT<:AbstractFloat","page":"Home","title":"MoM_Kernels.singularF21","text":"singularF21(a::FT, b::FT, c::FT, area2::FT) where{FT<:AbstractFloat}\n\n计算边长为a, b, c，面积平方为area2的三角形重合时的奇异性F2项，即 intintfracboldsymbolrho_mcdotboldsymbolrho_nRdS 的解析值，该函数处理 m==n 即基函数自作用的情况。\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.singularF22-Union{Tuple{FT}, NTuple{4, FT}} where FT<:AbstractFloat","page":"Home","title":"MoM_Kernels.singularF22","text":"singularF21(a::FT, b::FT, c::FT, area2::FT) where{FT<:AbstractFloat}\n\n计算边长为a, b, c，面积平方为area2的三角形重合时的奇异性F2项，即 intintfracboldsymbolrho_mcdotboldsymbolrho_nRdS 的解析值，该函数处理 m!=n 即同一三角形的不同基函数作用的情况。\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.sizeChunks2idxs-Tuple{Any, Any}","page":"Home","title":"MoM_Kernels.sizeChunks2idxs","text":"sizeChunks2idxs(Asize, chunks)\n\nBorrowed form DistributedArray.jl, get the slice of matrix\nsize Asize on each dimension with chunks.\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.slicedim2mpi-Tuple{Any, Int64}","page":"Home","title":"MoM_Kernels.slicedim2mpi","text":"slicedim2mpi(dims, nc::Int)\n\n从 MPIArray4MoMs借的！为的是避免提前引入 MPI 导致在集群上的 bug。 TBW\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.slicedim2mpi-Tuple{Int64, Int64}","page":"Home","title":"MoM_Kernels.slicedim2mpi","text":"slicedim2mpi(sz::Int, nc::Int)\n\n从 MPIArray4MoMs借的！为的是避免提前引入 MPI 导致在集群上的 bug。 TBW\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.solve!-Union{Tuple{T}, Tuple{Union{LinearMaps.LinearMap{T}, MLMFAIterator{T, VT}, AbstractMatrix{T}} where VT, AbstractVector{T}, AbstractVector{T}}} where T<:Number","page":"Home","title":"MoM_Kernels.solve!","text":"矩阵方程 Ax=b 复合求解函数 输入值： A::LinearMapType{T}, b::Vector{T} solverT::Symbol  求解器类型\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.solve-Union{Tuple{T}, Tuple{Union{LinearMaps.LinearMap{T}, MLMFAIterator{T, VT}, AbstractMatrix{T}} where VT, AbstractVector{T}}} where T<:Number","page":"Home","title":"MoM_Kernels.solve","text":"矩阵方程 Ax=b 复合求解函数 输入值： A::LinearMapType{T}, b::Vector{T} solverT::Symbol  求解器类型\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.sparseApproximateInversePl-Union{Tuple{CT}, Tuple{FT}, Tuple{MoM_Kernels.ZnearChunksStruct{CT}, Any}} where {FT<:Real, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.sparseApproximateInversePl","text":"采用多线程计算稀疏近似逆 (Sparse Approximate Inverse (SAI)) 的函数 输入为近场阻抗矩阵CSC, 叶层信息 (也可以为非叶层, 但计算量更大)  ZnearChunks::ZnearChunksStruct{CT} cubes::AbstractVector{CubeInfo{IT, FT}} 该函数提供左预条件\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.sparseApproximateInversePl-Union{Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, AbstractVector}} where {FT<:Real, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.sparseApproximateInversePl","text":"计算稀疏近似逆 (Sparse Approximate Inverse (SAI)) 的函数 输入为近场阻抗矩阵CSC, 叶层信息 (也可以为非叶层, 但计算量更大)  ZnearCSC::ZnearT{CT} cubes 该函数提供左预条件\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.sparseApproximateInversePl-Union{Tuple{LT}, Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, MoM_Kernels.OctreeInfo{FT, LT}}} where {FT<:Real, CT<:Complex{FT}, LT}","page":"Home","title":"MoM_Kernels.sparseApproximateInversePl","text":"计算稀疏近似逆 (Sparse Approximate Inverse (SAI)) 的函数 输入为近场阻抗矩阵CSC, 叶层信息 (也可以为非叶层, 但计算量更大)  ZnearCSC::::SparseMatrixCSC{CT, Int} octree::Octree{FT} 该函数提供左预条件\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.sparseApproximateInversePl-Union{Tuple{LT}, Tuple{CT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, LT}} where {CT<:Complex, LT<:MoM_Kernels.AbstractLevel}","page":"Home","title":"MoM_Kernels.sparseApproximateInversePl","text":"计算稀疏近似逆 (Sparse Approximate Inverse (SAI)) 的函数 输入为近场阻抗矩阵CSC, 叶层信息 (也可以为非叶层, 但计算量更大)  ZnearCSC::::SparseMatrixCSC{CT, Int} level 该函数提供左预条件\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.sparseApproximateInversePr-Union{Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, AbstractVector}} where {FT<:Real, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.sparseApproximateInversePr","text":"计算稀疏近似逆 (Sparse Approximate Inverse (SAI)) 的函数 输入为近场阻抗矩阵CSC, 叶层信息 (也可以为非叶层, 但计算量更大)  ZnearCSC::::SparseMatrixCSC{CT, Int} cubes 该函数提供右预条件\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.sparseApproximateInversePr-Union{Tuple{LT}, Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, MoM_Kernels.OctreeInfo{FT, LT}}} where {FT<:Real, CT<:Complex{FT}, LT}","page":"Home","title":"MoM_Kernels.sparseApproximateInversePr","text":"计算稀疏近似逆 (Sparse Approximate Inverse (SAI)) 的函数 输入为近场阻抗矩阵CSC, 叶层信息 (也可以为非叶层, 但计算量更大)  ZnearCSC::::SparseMatrixCSC{CT, Int} octree::Octree{FT} 该函数提供右预条件\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.sparseApproximateInversePr-Union{Tuple{LT}, Tuple{CT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, LT}} where {CT<:Complex, LT<:MoM_Kernels.AbstractLevel}","page":"Home","title":"MoM_Kernels.sparseApproximateInversePr","text":"计算稀疏近似逆 (Sparse Approximate Inverse (SAI)) 的函数 输入为近场阻抗矩阵CSC, 叶层信息 (也可以为非叶层, 但计算量更大)  ZnearCSC::::SparseMatrixCSC{CT, Int} octree::Octree{FT} 该函数提供右预条件\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.spherical_h1l-Tuple{Integer, Real}","page":"Home","title":"MoM_Kernels.spherical_h1l","text":"第一类球汉克尔函数，使用GSL.jl(GNU Scientific Library)，适用于 l 为整数，x 为浮点数时算的更快\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.spherical_h1l-Union{Tuple{T}, Tuple{Any, T}} where T","page":"Home","title":"MoM_Kernels.spherical_h1l","text":"第一类球汉克尔函数，使用 SpecialFunctions.jl， 适用于非整数阶、复数变量，算的较慢，只在计算有耗介质（复数波矢）时调用\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.spherical_h1l_array-Union{Tuple{T}, Tuple{Any, T}} where T","page":"Home","title":"MoM_Kernels.spherical_h1l_array","text":"一次计算 0:lmax 的多阶第一类球汉克尔函数， 保存在数组里\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.spherical_h1l_array-Union{Tuple{T}, Tuple{Integer, T}} where T<:Real","page":"Home","title":"MoM_Kernels.spherical_h1l_array","text":"一次计算 0:lmax 的多阶第一类球汉克尔函数， 保存在数组里\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.spherical_h2l-Tuple{Integer, Real}","page":"Home","title":"MoM_Kernels.spherical_h2l","text":"第二类球汉克尔函数，使用GSL.jl(GNU Scientific Library)，，适用于 l 为整数，x 为浮点数时算的更快\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.spherical_h2l-Union{Tuple{T}, Tuple{Any, T}} where T","page":"Home","title":"MoM_Kernels.spherical_h2l","text":"第二类球汉克尔函数，使用 SpecialFunctions.jl， 适用于非整数阶、复数变量，算的较慢，只在计算有耗介质（复数波矢）时调用\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.spherical_h2l_array-Union{Tuple{T}, Tuple{Any, T}} where T","page":"Home","title":"MoM_Kernels.spherical_h2l_array","text":"一次计算 0:lmax 的多阶第二类球汉克尔函数， 保存在数组里\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.spherical_h2l_array-Union{Tuple{T}, Tuple{Integer, T}} where T<:Real","page":"Home","title":"MoM_Kernels.spherical_h2l_array","text":"一次计算 0:lmax 的多阶第二类球汉克尔函数， 保存在数组里\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.transOnLevel!-Tuple{Any}","page":"Home","title":"MoM_Kernels.transOnLevel!","text":"层内转移\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.transOnLevels!-Tuple{Any, Any}","page":"Home","title":"MoM_Kernels.transOnLevels!","text":"各层内转移\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.truncationLCal-Tuple{FT} where FT<:Real","page":"Home","title":"MoM_Kernels.truncationLCal","text":"该函数计算八叉树各层截断项数 输入为本层最小盒子的边长\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.truncationLCal-Tuple{}","page":"Home","title":"MoM_Kernels.truncationLCal","text":"truncationLCal(;rel_l) where {FT<:Real}\n\n该函数计算八叉树各层截断项数 输入为相对波长\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.volumeSingularityIg-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, HexahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.volumeSingularityIg","text":"volumeSingularityIg(rtveclc::AbstractVector{FT}, volumeCell::HexahedraInfo{IT, FT, CT}) where {IT<:Integer, FT<:Real, CT<:Complex{FT}}\n\n计算场点rgt在体网格volumeCell上的奇异性。 计算结果为：\n\nbeginaligned\nI_gV  = intg(R)dV\n        = -sum_S_id_isum_n^SglrOrderfraccoeffgreen(n)n+2I_RS^n-1\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.volumeSingularityIgIvecg-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, TetrahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.volumeSingularityIgIvecg","text":"volumeSingularityIgIvecg(rtveclc::AbstractVector{FT}, volumeCell::TetrahedraInfo{IT, FT, CT}) where {IT<:Integer, FT<:Real, CT<:Complex{FT}}\nvolumeSingularityIgIvecg(rtveclc::AbstractVector{FT}, volumeCell::HexahedraInfo{IT, FT, CT}) where {IT<:Integer, FT<:Real, CT<:Complex{FT}}\n\n计算场点rgt在体网格volumeCell上的奇异性。 计算结果为：\n\nbeginaligned\nI_gV  = intg(R)dV\n        = -sum_S_id_isum_n^SglrOrderfraccoeffgreen(n)n+2I_RS^n-1\nboldsymbolI_gV  = intboldsymbolRg(R)dV\n        = -sum_S_ihatbmn_i sum_n=0^SglrOrderfraccoeffgreen(n)n+1I^n+1_RS\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.volumeSingularityLOpDyad-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, TetrahedraInfo{IT, FT, CT}}} where {IT<:Integer, FT<:Real, CT<:Complex{FT}}","page":"Home","title":"MoM_Kernels.volumeSingularityLOpDyad","text":"volumeSingularityLOpDyad(rtveclc::AbstractVector{FT}, volumeCell::TetrahedraInfo{IT, FT, CT}) where {IT<:Integer, FT<:Real, CT<:Complex{FT}}\nvolumeSingularityLOpDyad(rtveclc::AbstractVector{FT}, volumeCell::HexahedraInfo{IT, FT, CT}) where {IT<:Integer, FT<:Real, CT<:Complex{FT}}\n\n计算场点rtveclc在体网格volumeCell上的并矢格林函数奇异性。 计算结果为：\n\nbeginaligned\noverlineI_V  = int(k^2 I + )G(R) dV\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"#MoM_Kernels.writeZtt!-Union{Tuple{GT}, Tuple{T}, Tuple{Any, Any, T, GT, Bool}} where {T<:Number, GT<:VolumeCellType}","page":"Home","title":"MoM_Kernels.writeZtt!","text":"为适应类型变化而将写入部分单独封装\n\n\n\n\n\n","category":"method"}]
}
