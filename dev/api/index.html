<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · MoM_Kernels.jl</title><meta name="title" content="API · MoM_Kernels.jl"/><meta property="og:title" content="API · MoM_Kernels.jl"/><meta property="twitter:title" content="API · MoM_Kernels.jl"/><meta name="description" content="Documentation for MoM_Kernels.jl."/><meta property="og:description" content="Documentation for MoM_Kernels.jl."/><meta property="twitter:description" content="Documentation for MoM_Kernels.jl."/><meta property="og:url" content="https://deltaeecs.github.io/MoM_Kernels.jl/api/"/><meta property="twitter:url" content="https://deltaeecs.github.io/MoM_Kernels.jl/api/"/><link rel="canonical" href="https://deltaeecs.github.io/MoM_Kernels.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="MoM_Kernels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">MoM_Kernels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/master/docs/src/api.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#MoM_Kernels.GeosInterval"><code>MoM_Kernels.GeosInterval</code></a></li><li><a href="#MoM_Kernels.MLFMAParams"><code>MoM_Kernels.MLFMAParams</code></a></li><li><a href="#MoM_Kernels.ParallelParams"><code>MoM_Kernels.ParallelParams</code></a></li><li><a href="#MoM_Kernels.SSCg"><code>MoM_Kernels.SSCg</code></a></li><li><a href="#MoM_Kernels.SSCgdivnp2"><code>MoM_Kernels.SSCgdivnp2</code></a></li><li><a href="#MoM_Kernels.VSC₃ⁿ"><code>MoM_Kernels.VSC₃ⁿ</code></a></li><li><a href="#MoM_Kernels.CubeInfo"><code>MoM_Kernels.CubeInfo</code></a></li><li><a href="#MoM_Kernels.GLPolesInfo"><code>MoM_Kernels.GLPolesInfo</code></a></li><li><a href="#MoM_Kernels.GeosIntervalType"><code>MoM_Kernels.GeosIntervalType</code></a></li><li><a href="#MoM_Kernels.LagrangeInterp1StepInfo-Union{Tuple{IT}, Tuple{FT}, Tuple{SparseArrays.SparseMatrixCSC{FT, IT}, SparseArrays.SparseMatrixCSC{FT, IT}}} where {FT&lt;:Real, IT}"><code>MoM_Kernels.LagrangeInterp1StepInfo</code></a></li><li><a href="#MoM_Kernels.LagrangeInterp1StepInfo"><code>MoM_Kernels.LagrangeInterp1StepInfo</code></a></li><li><a href="#MoM_Kernels.LagrangeInterpInfo"><code>MoM_Kernels.LagrangeInterpInfo</code></a></li><li><a href="#MoM_Kernels.LagrangeInterpInfo-Union{Tuple{IT}, Tuple{FT}, Tuple{SparseArrays.SparseMatrixCSC{FT, IT}, SparseArrays.SparseMatrixCSC{FT, IT}}} where {FT&lt;:Real, IT}"><code>MoM_Kernels.LagrangeInterpInfo</code></a></li><li><a href="#MoM_Kernels.LevelInfo"><code>MoM_Kernels.LevelInfo</code></a></li><li><a href="#MoM_Kernels.MLFMAIterator-Union{Tuple{LT}, Tuple{FT}, Tuple{Any, MoM_Kernels.OctreeInfo{FT, LT}, Vector, Vector}} where {FT&lt;:Real, LT&lt;:MoM_Kernels.LevelInfo}"><code>MoM_Kernels.MLFMAIterator</code></a></li><li><a href="#MoM_Kernels.MLFMAIterator"><code>MoM_Kernels.MLFMAIterator</code></a></li><li><a href="#MoM_Kernels.MLFMAParamsType"><code>MoM_Kernels.MLFMAParamsType</code></a></li><li><a href="#MoM_Kernels.MatrixChunk"><code>MoM_Kernels.MatrixChunk</code></a></li><li><a href="#MoM_Kernels.MatrixChunk-Union{Tuple{T}, Tuple{Any, Any}} where T&lt;:Number"><code>MoM_Kernels.MatrixChunk</code></a></li><li><a href="#MoM_Kernels.OctreeInfo-Union{Tuple{LT}, Tuple{FT}, Tuple{Matrix{FT}, FT}} where {FT&lt;:Real, LT&lt;:MoM_Kernels.AbstractLevel}"><code>MoM_Kernels.OctreeInfo</code></a></li><li><a href="#MoM_Kernels.OctreeInfo"><code>MoM_Kernels.OctreeInfo</code></a></li><li><a href="#MoM_Kernels.PartitionedVector"><code>MoM_Kernels.PartitionedVector</code></a></li><li><a href="#MoM_Kernels.SAIChunkPrec"><code>MoM_Kernels.SAIChunkPrec</code></a></li><li><a href="#MoM_Kernels.SAIPrec"><code>MoM_Kernels.SAIPrec</code></a></li><li><a href="#MoM_Kernels.ZnearChunksStruct-Union{Tuple{Any}, Tuple{T}} where T&lt;:Number"><code>MoM_Kernels.ZnearChunksStruct</code></a></li><li><a href="#MoM_Kernels.ZnearChunksStruct"><code>MoM_Kernels.ZnearChunksStruct</code></a></li><li><a href="#MoM_Kernels.ZnearT"><code>MoM_Kernels.ZnearT</code></a></li><li><a href="#Base.:*-Union{Tuple{T}, Tuple{T, AbstractVector}} where T&lt;:MoM_Kernels.MatrixChunk"><code>Base.:*</code></a></li><li><a href="#Base.:*-Union{Tuple{T}, Tuple{T, AbstractVector}} where T&lt;:MoM_Kernels.ZnearChunksStruct"><code>Base.:*</code></a></li><li><a href="#Base.:*-Union{Tuple{T}, Tuple{AbstractVector, T}} where T&lt;:MoM_Kernels.MatrixChunk"><code>Base.:*</code></a></li><li><a href="#Base.:*-Union{Tuple{T}, Tuple{MoM_Kernels.ZNEARCHUNK{T}, AbstractMatrix}} where T&lt;:Number"><code>Base.:*</code></a></li><li><a href="#Base.:*-Union{Tuple{T}, Tuple{T, AbstractMatrix}} where T&lt;:MoM_Kernels.MatrixChunk"><code>Base.:*</code></a></li><li><a href="#Base.:*-Union{Tuple{T}, Tuple{AbstractMatrix, T}} where T&lt;:MoM_Kernels.MatrixChunk"><code>Base.:*</code></a></li><li><a href="#Base.convert-Union{Tuple{LTo}, Tuple{LTt}, Tuple{FT}, Tuple{Type{MoM_Kernels.OctreeInfo{FT, LTt}}, MoM_Kernels.OctreeInfo{FT, LTo}}} where {FT&lt;:Real, LTt&lt;:MoM_Kernels.AbstractLevel, LTo&lt;:MoM_Kernels.AbstractLevel}"><code>Base.convert</code></a></li><li><a href="#Base.eltype-Tuple{IncompleteLU.ILUFactorization}"><code>Base.eltype</code></a></li><li><a href="#Base.getindex-Union{Tuple{I}, Tuple{PartitionedVector, I}} where I&lt;:Integer"><code>Base.getindex</code></a></li><li><a href="#Base.getindex-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T&lt;:MoM_Kernels.MatrixChunk"><code>Base.getindex</code></a></li><li><a href="#Base.getindex-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T&lt;:MoM_Kernels.ZNEARCHUNK"><code>Base.getindex</code></a></li><li><a href="#Base.setindex!-Union{Tuple{T}, Tuple{T, Any, Int64, Int64}} where T&lt;:MoM_Kernels.MatrixChunk"><code>Base.setindex!</code></a></li><li><a href="#Base.setindex!-Union{Tuple{T}, Tuple{T, Any, Int64, Int64}} where T&lt;:MoM_Kernels.ZNEARCHUNK"><code>Base.setindex!</code></a></li><li><a href="#Base.size-Tuple{T} where T&lt;:IncompleteLU.ILUFactorization"><code>Base.size</code></a></li><li><a href="#LinearAlgebra.ldiv!-Union{Tuple{T}, Tuple{SAIChunkPrec{T}, AbstractVector}} where T"><code>LinearAlgebra.ldiv!</code></a></li><li><a href="#LinearAlgebra.ldiv!-Union{Tuple{T}, Tuple{SAIPrec{T}, AbstractVector}} where T"><code>LinearAlgebra.ldiv!</code></a></li><li><a href="#LinearAlgebra.mul!-Tuple{AbstractVector, MLFMAIterator, AbstractVector, Number, Number}"><code>LinearAlgebra.mul!</code></a></li><li><a href="#LinearAlgebra.mul!-Union{Tuple{V}, Tuple{T}, Tuple{AbstractVector, LinearAlgebra.Adjoint{T, MLFMAIterator{T, V}}, AbstractVector, Number, Number}} where {T, V}"><code>LinearAlgebra.mul!</code></a></li><li><a href="#LinearAlgebra.mul!-Union{Tuple{T}, Tuple{Any, T, AbstractVector}} where T&lt;:MoM_Kernels.MatrixChunk"><code>LinearAlgebra.mul!</code></a></li><li><a href="#LinearAlgebra.mul!-Union{Tuple{V}, Tuple{T}, Tuple{Any, LinearAlgebra.Adjoint{T, MLFMAIterator{T, V}}, Any}} where {T, V}"><code>LinearAlgebra.mul!</code></a></li><li><a href="#LinearAlgebra.mul!-Tuple{Any, MLFMAIterator, Any}"><code>LinearAlgebra.mul!</code></a></li><li><a href="#MoM_Kernels.CFIEOnNearTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.CFIEOnNearTris</code></a></li><li><a href="#MoM_Kernels.CFIEOnTris-Union{Tuple{TriangleInfo{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.CFIEOnTris</code></a></li><li><a href="#MoM_Kernels.CFIEOnTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.CFIEOnTris</code></a></li><li><a href="#MoM_Kernels.EFIEOnHexaPWC-Union{Tuple{HexahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnHexaPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnHexaPWCSepPV-Union{Tuple{HexahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnHexaPWCSepPV</code></a></li><li><a href="#MoM_Kernels.EFIEOnHexaRBF-Union{Tuple{HexahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnHexaRBF</code></a></li><li><a href="#MoM_Kernels.EFIEOnHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnHexaTetraPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnHexaTetraPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnHexasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnHexasPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnHexasRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnHexasRBF</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearHexaTetraPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearHexaTetraPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearHexasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearHexasPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearHexasRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearHexasRBF</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:VolumeCellType}"><code>MoM_Kernels.EFIEOnNearRWGPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:VolumeCellType}"><code>MoM_Kernels.EFIEOnNearRWGPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:HexahedraInfo}"><code>MoM_Kernels.EFIEOnNearRWGPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:HexahedraInfo}"><code>MoM_Kernels.EFIEOnNearRWGPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearRWGRBF</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearRWGRBF</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearRWGSWG</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearRWGSWG</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearTetrasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearTetrasPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearTetrasSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearTetrasSWG</code></a></li><li><a href="#MoM_Kernels.EFIEOnNearTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.EFIEOnNearTris</code></a></li><li><a href="#MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:TetrahedraInfo}"><code>MoM_Kernels.EFIEOnRWGPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:VolumeCellType}"><code>MoM_Kernels.EFIEOnRWGPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:HexahedraInfo}"><code>MoM_Kernels.EFIEOnRWGPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:HexahedraInfo}"><code>MoM_Kernels.EFIEOnRWGPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnRWGRBF</code></a></li><li><a href="#MoM_Kernels.EFIEOnRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnRWGRBF</code></a></li><li><a href="#MoM_Kernels.EFIEOnRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnRWGSWG</code></a></li><li><a href="#MoM_Kernels.EFIEOnRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnRWGSWG</code></a></li><li><a href="#MoM_Kernels.EFIEOnTetraPWC-Union{Tuple{TetrahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnTetraPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnTetraPWCSepPV-Union{Tuple{TetrahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnTetraPWCSepPV</code></a></li><li><a href="#MoM_Kernels.EFIEOnTetraSWG-Union{Tuple{TetrahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnTetraSWG</code></a></li><li><a href="#MoM_Kernels.EFIEOnTetrasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnTetrasPWC</code></a></li><li><a href="#MoM_Kernels.EFIEOnTetrasSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnTetrasSWG</code></a></li><li><a href="#MoM_Kernels.EFIEOnTris-Union{Tuple{TriangleInfo{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.EFIEOnTris</code></a></li><li><a href="#MoM_Kernels.EFIEOnTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.EFIEOnTris</code></a></li><li><a href="#MoM_Kernels.MFIEOnNearTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.MFIEOnNearTris</code></a></li><li><a href="#MoM_Kernels.MFIEOnTris-Union{Tuple{TriangleInfo{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.MFIEOnTris</code></a></li><li><a href="#MoM_Kernels.MFIEOnTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.MFIEOnTris</code></a></li><li><a href="#MoM_Kernels.RCSPlot-Union{Tuple{FT}, Tuple{Any, Any, Matrix{FT}, Matrix{FT}}} where FT&lt;:Real"><code>MoM_Kernels.RCSPlot</code></a></li><li><a href="#MoM_Kernels.ZnearChunkMulIVec!-Tuple{Any, Any, Any}"><code>MoM_Kernels.ZnearChunkMulIVec!</code></a></li><li><a href="#MoM_Kernels.adjoint_agg2HighLevel!-Tuple{Any, Any}"><code>MoM_Kernels.adjoint_agg2HighLevel!</code></a></li><li><a href="#MoM_Kernels.adjoint_agg2Level2!-Tuple{Any, Any}"><code>MoM_Kernels.adjoint_agg2Level2!</code></a></li><li><a href="#MoM_Kernels.adjoint_aggOnBF!-Union{Tuple{T}, Tuple{Any, Any, AbstractArray{T}}} where T&lt;:Number"><code>MoM_Kernels.adjoint_aggOnBF!</code></a></li><li><a href="#MoM_Kernels.adjoint_disagg2KidLevel!-Tuple{Any, Any}"><code>MoM_Kernels.adjoint_disagg2KidLevel!</code></a></li><li><a href="#MoM_Kernels.adjoint_disagg2LeafLevel!-Tuple{Any, Any}"><code>MoM_Kernels.adjoint_disagg2LeafLevel!</code></a></li><li><a href="#MoM_Kernels.adjoint_disaggOnBF!-Tuple{Any, Any, Any}"><code>MoM_Kernels.adjoint_disaggOnBF!</code></a></li><li><a href="#MoM_Kernels.adjoint_transOnLevel!-Tuple{Any}"><code>MoM_Kernels.adjoint_transOnLevel!</code></a></li><li><a href="#MoM_Kernels.adjoint_transOnLevels!-Tuple{Any, Any}"><code>MoM_Kernels.adjoint_transOnLevels!</code></a></li><li><a href="#MoM_Kernels.agg2HighLevel!-Tuple{Any, Any}"><code>MoM_Kernels.agg2HighLevel!</code></a></li><li><a href="#MoM_Kernels.agg2HighLevel!-Union{Tuple{IPT}, Tuple{FT}, Tuple{IT}, Tuple{Any, MoM_Kernels.LevelInfo{IT, FT, IPT}}} where {IT, FT, IPT&lt;:MoM_Kernels.LagrangeInterpInfo}"><code>MoM_Kernels.agg2HighLevel!</code></a></li><li><a href="#MoM_Kernels.agg2Level2!-Tuple{Any, Any}"><code>MoM_Kernels.agg2Level2!</code></a></li><li><a href="#MoM_Kernels.aggOnBF!-Union{Tuple{T}, Tuple{Any, Any, AbstractArray{T}}} where T&lt;:Number"><code>MoM_Kernels.aggOnBF!</code></a></li><li><a href="#MoM_Kernels.aggSBFOnLevel-Union{Tuple{BFT}, Tuple{VT}, Tuple{LT}, Tuple{LT, AbstractVector{VT}, AbstractVector{BFT}}} where {LT&lt;:MoM_Kernels.LevelInfo, VT&lt;:VolumeCellType, BFT&lt;:BasisFunctionType}"><code>MoM_Kernels.aggSBFOnLevel</code></a></li><li><a href="#MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{VT}, Tuple{Any, Any, Any, AbstractVector{VT}, Type{BFT}}} where {VT&lt;:HexahedraInfo, BFT&lt;:RBF}"><code>MoM_Kernels.aggSBFOnLevel!</code></a></li><li><a href="#MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:PWC}"><code>MoM_Kernels.aggSBFOnLevel!</code></a></li><li><a href="#MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:PWC}"><code>MoM_Kernels.aggSBFOnLevel!</code></a></li><li><a href="#MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:SWG}"><code>MoM_Kernels.aggSBFOnLevel!</code></a></li><li><a href="#MoM_Kernels.aggSBFOnLevelCFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Any}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.aggSBFOnLevelCFIE</code></a></li><li><a href="#MoM_Kernels.aggSBFOnLevelCFIE!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}"><code>MoM_Kernels.aggSBFOnLevelCFIE!</code></a></li><li><a href="#MoM_Kernels.aggSBFOnLevelEFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Any}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.aggSBFOnLevelEFIE</code></a></li><li><a href="#MoM_Kernels.aggSBFOnLevelEFIE!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}"><code>MoM_Kernels.aggSBFOnLevelEFIE!</code></a></li><li><a href="#MoM_Kernels.aggSBFOnLevelMFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Array{RWG{IT, FT}, 1}}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.aggSBFOnLevelMFIE</code></a></li><li><a href="#MoM_Kernels.aggSBFOnLevelMFIE!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}"><code>MoM_Kernels.aggSBFOnLevelMFIE!</code></a></li><li><a href="#MoM_Kernels.anterpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.anterpolate</code></a></li><li><a href="#MoM_Kernels.anterpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.anterpolate</code></a></li><li><a href="#MoM_Kernels.anterpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.anterpolate!</code></a></li><li><a href="#MoM_Kernels.anterpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.anterpolate!</code></a></li><li><a href="#MoM_Kernels.calZfarI!-Union{Tuple{MT}, Tuple{T}, Tuple{ZT}, Tuple{MLFMAIterator{ZT, MT}, AbstractArray{T}}} where {ZT, T&lt;:Number, MT&lt;:(Vector)}"><code>MoM_Kernels.calZfarI!</code></a></li><li><a href="#MoM_Kernels.calZnearCSC-Tuple{Any, Vector, Vector}"><code>MoM_Kernels.calZnearCSC</code></a></li><li><a href="#MoM_Kernels.calZnearCSC!-Union{Tuple{VSCellT}, Tuple{BFT}, Tuple{Any, AbstractVector{VSCellT}, Any}, Tuple{Any, AbstractVector{VSCellT}, Any, Type{BFT}}} where {BFT&lt;:BasisFunctionType, VSCellT&lt;:SurfaceCellType}"><code>MoM_Kernels.calZnearCSC!</code></a></li><li><a href="#MoM_Kernels.calZnearCSCCFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RWG}"><code>MoM_Kernels.calZnearCSCCFIE!</code></a></li><li><a href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{VT2}, Tuple{VT1}, Tuple{CT}, Tuple{FT}, Tuple{Any, AbstractVector{VT1}, AbstractVector{VT2}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, AbstractVector{VT1}, AbstractVector{VT2}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {FT&lt;:Real, CT&lt;:Complex{FT}, VT1&lt;:TetrahedraInfo, VT2&lt;:HexahedraInfo, BFT&lt;:PWC}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a></li><li><a href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a></li><li><a href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:ConstBasisFunction}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a></li><li><a href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:ConstBasisFunction}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a></li><li><a href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a></li><li><a href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:SWG}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a></li><li><a href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a></li><li><a href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{VT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractVector{VT}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractVector{VT}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, VT&lt;:VolumeCellType, BFT&lt;:PWC}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a></li><li><a href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RBF}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a></li><li><a href="#MoM_Kernels.calZnearCSCEFIEnew!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}"><code>MoM_Kernels.calZnearCSCEFIEnew!</code></a></li><li><a href="#MoM_Kernels.calZnearCSCMFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RWG}"><code>MoM_Kernels.calZnearCSCMFIE!</code></a></li><li><a href="#MoM_Kernels.caladjZfarI!-Union{Tuple{MT}, Tuple{T}, Tuple{ZT}, Tuple{LinearAlgebra.Adjoint{ZT, MLFMAIterator{ZT, MT}}, AbstractArray{T}}} where {ZT, T&lt;:Number, MT&lt;:(Vector)}"><code>MoM_Kernels.caladjZfarI!</code></a></li><li><a href="#MoM_Kernels.calαTransOnLevel!-NTuple{4, Any}"><code>MoM_Kernels.calαTransOnLevel!</code></a></li><li><a href="#MoM_Kernels.coeffgreen-Tuple{Integer}"><code>MoM_Kernels.coeffgreen</code></a></li><li><a href="#MoM_Kernels.convergencePlot-Union{Tuple{Vector{FT}}, Tuple{FT}} where FT&lt;:Real"><code>MoM_Kernels.convergencePlot</code></a></li><li><a href="#MoM_Kernels.cooraInCoorb-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T&lt;:Number"><code>MoM_Kernels.cooraInCoorb</code></a></li><li><a href="#MoM_Kernels.disagg2KidLevel!-Tuple{Any, Any}"><code>MoM_Kernels.disagg2KidLevel!</code></a></li><li><a href="#MoM_Kernels.disagg2KidLevel!-Union{Tuple{IPT}, Tuple{FT}, Tuple{IT}, Tuple{Any, MoM_Kernels.LevelInfo{IT, FT, IPT}}} where {IT, FT, IPT&lt;:MoM_Kernels.LagrangeInterpInfo}"><code>MoM_Kernels.disagg2KidLevel!</code></a></li><li><a href="#MoM_Kernels.disagg2LeafLevel!-Tuple{Any, Any}"><code>MoM_Kernels.disagg2LeafLevel!</code></a></li><li><a href="#MoM_Kernels.disaggOnBF!-Tuple{Any, Any, Any}"><code>MoM_Kernels.disaggOnBF!</code></a></li><li><a href="#MoM_Kernels.electricJCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{StaticArraysCore.StaticArray{Tuple{3}, FT, 1}, StaticArraysCore.StaticArray{Tuple{3}, CT, 1}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.electricJCal</code></a></li><li><a href="#MoM_Kernels.electricJCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.electricJCal</code></a></li><li><a href="#MoM_Kernels.excitationVectorCFIE-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TriangleInfo{IT, FT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}"><code>MoM_Kernels.excitationVectorCFIE</code></a></li><li><a href="#MoM_Kernels.excitationVectorCFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, Array{TriangleInfo{IT, FT}, 1}, Integer}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.excitationVectorCFIE</code></a></li><li><a href="#MoM_Kernels.excitationVectorCFIE!-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.excitationVectorCFIE!</code></a></li><li><a href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, Array{TriangleInfo{IT, FT}, 1}, Integer}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.excitationVectorEFIE</code></a></li><li><a href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, HexahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:ConstBasisFunction}"><code>MoM_Kernels.excitationVectorEFIE</code></a></li><li><a href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer}, Tuple{ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.excitationVectorEFIE</code></a></li><li><a href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{VT}, Tuple{ST}, Tuple{ST, Vector{VT}, Integer}} where {ST&lt;:ExcitingSources, VT&lt;:(AbstractVector)}"><code>MoM_Kernels.excitationVectorEFIE</code></a></li><li><a href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer}, Tuple{ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.excitationVectorEFIE</code></a></li><li><a href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TriangleInfo{IT, FT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}"><code>MoM_Kernels.excitationVectorEFIE</code></a></li><li><a href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TetrahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:ConstBasisFunction}"><code>MoM_Kernels.excitationVectorEFIE</code></a></li><li><a href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TetrahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}"><code>MoM_Kernels.excitationVectorEFIE</code></a></li><li><a href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, HexahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}"><code>MoM_Kernels.excitationVectorEFIE</code></a></li><li><a href="#MoM_Kernels.excitationVectorEFIE!-Union{Tuple{VT}, Tuple{ST}, Tuple{AbstractVector, ST, Vector{VT}}} where {ST&lt;:ExcitingSources, VT&lt;:(AbstractVector)}"><code>MoM_Kernels.excitationVectorEFIE!</code></a></li><li><a href="#MoM_Kernels.excitationVectorEFIE!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Vector{CT}, ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}}, Tuple{Vector{CT}, ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.excitationVectorEFIE!</code></a></li><li><a href="#MoM_Kernels.excitationVectorEFIE!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.excitationVectorEFIE!</code></a></li><li><a href="#MoM_Kernels.excitationVectorEFIE!-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.excitationVectorEFIE!</code></a></li><li><a href="#MoM_Kernels.excitationVectorMFIE-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TriangleInfo{IT, FT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}"><code>MoM_Kernels.excitationVectorMFIE</code></a></li><li><a href="#MoM_Kernels.excitationVectorMFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, Array{TriangleInfo{IT, FT}, 1}, Integer}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.excitationVectorMFIE</code></a></li><li><a href="#MoM_Kernels.excitationVectorMFIE!-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.excitationVectorMFIE!</code></a></li><li><a href="#MoM_Kernels.faceSingularityIg-Union{Tuple{ST}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, ST, FT, AbstractVector{FT}}} where {IT&lt;:Integer, FT&lt;:Real, ST&lt;:SurfaceCellType{IT, FT}}"><code>MoM_Kernels.faceSingularityIg</code></a></li><li><a href="#MoM_Kernels.faceSingularityIg-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, Tris4Tetra{IT, FT}, FT, AbstractVector{FT}}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.faceSingularityIg</code></a></li><li><a href="#MoM_Kernels.faceSingularityIg-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, TriangleInfo{IT, FT}, FT, AbstractVector{FT}}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.faceSingularityIg</code></a></li><li><a href="#MoM_Kernels.faceSingularityIgIvecg-Union{Tuple{ST}, Tuple{FT}, Tuple{AbstractVector{FT}, ST, Any, AbstractVector}} where {FT&lt;:Real, ST&lt;:SurfaceCellType}"><code>MoM_Kernels.faceSingularityIgIvecg</code></a></li><li><a href="#MoM_Kernels.faceSingularityIgIvecgI∇gS-Union{Tuple{ST}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, ST, FT, AbstractVector{FT}}} where {IT&lt;:Integer, FT&lt;:Real, ST&lt;:SurfaceCellType{IT, FT}}"><code>MoM_Kernels.faceSingularityIgIvecgI∇gS</code></a></li><li><a href="#MoM_Kernels.faceSingularityIᵣIᵨ-Union{Tuple{FT}, Tuple{IT}, Tuple{StaticArraysCore.MMatrix{3, 7, FT, 21}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.faceSingularityIᵣIᵨ</code></a></li><li><a href="#MoM_Kernels.farEPlot-Union{Tuple{FT}, Tuple{Any, Any, Matrix{FT}, Matrix{FT}}} where FT&lt;:Real"><code>MoM_Kernels.farEPlot</code></a></li><li><a href="#MoM_Kernels.farField-Tuple{Any, Any, Any}"><code>MoM_Kernels.farField</code></a></li><li><a href="#MoM_Kernels.farField-Union{Tuple{VT}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Any}} where {CT&lt;:Complex, VT&lt;:(AbstractVector)}"><code>MoM_Kernels.farField</code></a></li><li><a href="#MoM_Kernels.farField-Union{Tuple{BFT}, Tuple{CT}, Tuple{VT}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Any}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Any, Type{BFT}}} where {VT&lt;:VolumeCellType, CT&lt;:Complex, BFT&lt;:BasisFunctionType}"><code>MoM_Kernels.farField</code></a></li><li><a href="#MoM_Kernels.farField-Union{Tuple{BFT}, Tuple{ST}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{ST}, Any}, Tuple{Any, Any, Vector{CT}, Vector{ST}, Any, Type{BFT}}} where {CT&lt;:Complex, ST&lt;:TriangleInfo, BFT&lt;:RWG}"><code>MoM_Kernels.farField</code></a></li><li><a href="#MoM_Kernels.func4Cube1stkInterval-Tuple{MoM_Kernels.CubeInfo}"><code>MoM_Kernels.func4Cube1stkInterval</code></a></li><li><a href="#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:SWG}"><code>MoM_Kernels.geoElectricJCal</code></a></li><li><a href="#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}}, Tuple{Vector{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RWG}"><code>MoM_Kernels.geoElectricJCal</code></a></li><li><a href="#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RBF}"><code>MoM_Kernels.geoElectricJCal</code></a></li><li><a href="#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:PWC}"><code>MoM_Kernels.geoElectricJCal</code></a></li><li><a href="#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:PWC}"><code>MoM_Kernels.geoElectricJCal</code></a></li><li><a href="#MoM_Kernels.getAggSBFOnLevel-Union{Tuple{BFT}, Tuple{VT}, Tuple{Any, Vector{VT}, Vector{BFT}}} where {VT&lt;:VolumeCellType, BFT&lt;:BasisFunctionType}"><code>MoM_Kernels.getAggSBFOnLevel</code></a></li><li><a href="#MoM_Kernels.getAggSBFOnLevel-Union{Tuple{VT2}, Tuple{VT1}, Tuple{Any, Vector{VT1}, Vector{VT2}}} where {VT1&lt;:(AbstractVector), VT2&lt;:(AbstractVector)}"><code>MoM_Kernels.getAggSBFOnLevel</code></a></li><li><a href="#MoM_Kernels.getAggSBFOnLevel-Union{Tuple{BFT}, Tuple{ST}, Tuple{Any, Vector{ST}, Vector{BFT}}} where {ST&lt;:SurfaceCellType, BFT&lt;:BasisFunctionType}"><code>MoM_Kernels.getAggSBFOnLevel</code></a></li><li><a href="#MoM_Kernels.getBfsCenter-Union{Tuple{Vector{BFT}}, Tuple{BFT}} where BFT&lt;:BasisFunctionType"><code>MoM_Kernels.getBfsCenter</code></a></li><li><a href="#MoM_Kernels.getBfsCenter-Union{Tuple{Vector{VT}}, Tuple{VT}} where VT&lt;:(AbstractVector)"><code>MoM_Kernels.getBfsCenter</code></a></li><li><a href="#MoM_Kernels.getCubeIDsWithGeos-Tuple{Any, Any}"><code>MoM_Kernels.getCubeIDsWithGeos</code></a></li><li><a href="#MoM_Kernels.getExcitationVector-Union{Tuple{VT}, Tuple{Vector{VT}, Any, Any}} where VT&lt;:(AbstractVector)"><code>MoM_Kernels.getExcitationVector</code></a></li><li><a href="#MoM_Kernels.getExcitationVector-Union{Tuple{VST}, Tuple{Vector{VST}, Any, Any}} where VST&lt;:VolumeCellType"><code>MoM_Kernels.getExcitationVector</code></a></li><li><a href="#MoM_Kernels.getExcitationVector-Union{Tuple{VST}, Tuple{Vector{VST}, Any, Any}} where VST&lt;:SurfaceCellType"><code>MoM_Kernels.getExcitationVector</code></a></li><li><a href="#MoM_Kernels.getGeoIDsInCubeChunk-Tuple{Any, Tuple}"><code>MoM_Kernels.getGeoIDsInCubeChunk</code></a></li><li><a href="#MoM_Kernels.getGeosInterval-Tuple{T} where T&lt;:(AbstractVector)"><code>MoM_Kernels.getGeosInterval</code></a></li><li><a href="#MoM_Kernels.getImpedanceMatAndExciteV-Tuple{Any, Integer, Any}"><code>MoM_Kernels.getImpedanceMatAndExciteV</code></a></li><li><a href="#MoM_Kernels.getImpedanceMatAndExciteV-Tuple{Any, Vector, Any}"><code>MoM_Kernels.getImpedanceMatAndExciteV</code></a></li><li><a href="#MoM_Kernels.getImpedanceMatrix-Union{Tuple{ST}, Tuple{Vector{ST}, Integer}} where ST&lt;:SurfaceCellType"><code>MoM_Kernels.getImpedanceMatrix</code></a></li><li><a href="#MoM_Kernels.getImpedanceOpt-Tuple{Any, Any}"><code>MoM_Kernels.getImpedanceOpt</code></a></li><li><a href="#MoM_Kernels.getImpedanceOptAndExciteVOctree-Tuple{Any, Any, Any}"><code>MoM_Kernels.getImpedanceOptAndExciteVOctree</code></a></li><li><a href="#MoM_Kernels.getLeafCubeL-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:(AbstractVector)"><code>MoM_Kernels.getLeafCubeL</code></a></li><li><a href="#MoM_Kernels.getLeafCubeL-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:TriangleInfo"><code>MoM_Kernels.getLeafCubeL</code></a></li><li><a href="#MoM_Kernels.getLeafCubeL-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:TetrahedraInfo"><code>MoM_Kernels.getLeafCubeL</code></a></li><li><a href="#MoM_Kernels.getLeafCubeL-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:HexahedraInfo"><code>MoM_Kernels.getLeafCubeL</code></a></li><li><a href="#MoM_Kernels.getMeshDataSaveGeosInterval-Tuple{Any}"><code>MoM_Kernels.getMeshDataSaveGeosInterval</code></a></li><li><a href="#MoM_Kernels.getNeiFarNeighborCubeIDs-Tuple{Any, Tuple}"><code>MoM_Kernels.getNeiFarNeighborCubeIDs</code></a></li><li><a href="#MoM_Kernels.getNeighborCubeIDs-Tuple{Any, Tuple}"><code>MoM_Kernels.getNeighborCubeIDs</code></a></li><li><a href="#MoM_Kernels.getOctreeAndReOrderBFs!-Tuple{Any, Any}"><code>MoM_Kernels.getOctreeAndReOrderBFs!</code></a></li><li><a href="#MoM_Kernels.get_Interpolation_Method-Tuple{Symbol}"><code>MoM_Kernels.get_Interpolation_Method</code></a></li><li><a href="#MoM_Kernels.get_chunks_minmax_col-Tuple{Any}"><code>MoM_Kernels.get_chunks_minmax_col</code></a></li><li><a href="#MoM_Kernels.get_leafCubeSize-Tuple{}"><code>MoM_Kernels.get_leafCubeSize</code></a></li><li><a href="#MoM_Kernels.get_partition-Tuple{Any, Any, Any}"><code>MoM_Kernels.get_partition</code></a></li><li><a href="#MoM_Kernels.get_partition_map-Tuple{Any, Any}"><code>MoM_Kernels.get_partition_map</code></a></li><li><a href="#MoM_Kernels.gq_xsws_on_sphere-Tuple{Any}"><code>MoM_Kernels.gq_xsws_on_sphere</code></a></li><li><a href="#MoM_Kernels.greenfunc_star-Union{Tuple{T}, Tuple{StaticArraysCore.StaticArray{Tuple{3}, T, 1}, StaticArraysCore.StaticArray{Tuple{3}, T, 1}}} where T&lt;:AbstractFloat"><code>MoM_Kernels.greenfunc_star</code></a></li><li><a href="#MoM_Kernels.iluPrecondition-Tuple{Any, Any}"><code>MoM_Kernels.iluPrecondition</code></a></li><li><a href="#MoM_Kernels.impedancemat4CFIE4PEC-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{TriangleInfo{IT, FT}, 1}, Integer, Type{BFT}}} where {IT, FT, BFT&lt;:RWG}"><code>MoM_Kernels.impedancemat4CFIE4PEC</code></a></li><li><a href="#MoM_Kernels.impedancemat4EFIE4PEC-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{TriangleInfo{IT, FT}, 1}, Integer, Type{BFT}}} where {IT, FT, BFT&lt;:RWG}"><code>MoM_Kernels.impedancemat4EFIE4PEC</code></a></li><li><a href="#MoM_Kernels.impedancemat4EFIE4PEC!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{Complex{FT}, 2}, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT, FT, BFT&lt;:RWG}"><code>MoM_Kernels.impedancemat4EFIE4PEC!</code></a></li><li><a href="#MoM_Kernels.impedancemat4MFIE4PEC-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{TriangleInfo{IT, FT}, 1}, Integer, Type{BFT}}} where {IT, FT, BFT&lt;:RWG}"><code>MoM_Kernels.impedancemat4MFIE4PEC</code></a></li><li><a href="#MoM_Kernels.impedancemat4RWGPWC!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Any}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.impedancemat4RWGPWC!</code></a></li><li><a href="#MoM_Kernels.impedancemat4RWGPWC!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Any}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.impedancemat4RWGPWC!</code></a></li><li><a href="#MoM_Kernels.impedancemat4RWGRBF!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.impedancemat4RWGRBF!</code></a></li><li><a href="#MoM_Kernels.impedancemat4RWGSWG!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.impedancemat4RWGSWG!</code></a></li><li><a href="#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT&lt;:RBF}"><code>MoM_Kernels.impedancemat4VIE</code></a></li><li><a href="#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}"><code>MoM_Kernels.impedancemat4VIE</code></a></li><li><a href="#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT&lt;:SWG}"><code>MoM_Kernels.impedancemat4VIE</code></a></li><li><a href="#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{VT}, Tuple{AbstractVector{VT}, Integer, Type{BFT}}} where {VT&lt;:(AbstractVector), BFT&lt;:PWC}"><code>MoM_Kernels.impedancemat4VIE</code></a></li><li><a href="#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}"><code>MoM_Kernels.impedancemat4VIE</code></a></li><li><a href="#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}"><code>MoM_Kernels.impedancemat4VIE!</code></a></li><li><a href="#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:SWG}"><code>MoM_Kernels.impedancemat4VIE!</code></a></li><li><a href="#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}"><code>MoM_Kernels.impedancemat4VIE!</code></a></li><li><a href="#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}"><code>MoM_Kernels.impedancemat4VIE!</code></a></li><li><a href="#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:RBF}"><code>MoM_Kernels.impedancemat4VIE!</code></a></li><li><a href="#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}"><code>MoM_Kernels.impedancemat4VIE!</code></a></li><li><a href="#MoM_Kernels.impedancemat4VSIE-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT&lt;:(AbstractVector)"><code>MoM_Kernels.impedancemat4VSIE</code></a></li><li><a href="#MoM_Kernels.impedancemat4VSIERWGPWC-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT&lt;:(AbstractVector)"><code>MoM_Kernels.impedancemat4VSIERWGPWC</code></a></li><li><a href="#MoM_Kernels.impedancemat4VSIERWGRBF-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT&lt;:(AbstractVector)"><code>MoM_Kernels.impedancemat4VSIERWGRBF</code></a></li><li><a href="#MoM_Kernels.impedancemat4VSIERWGSWG-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT&lt;:(AbstractVector)"><code>MoM_Kernels.impedancemat4VSIERWGSWG</code></a></li><li><a href="#MoM_Kernels.initialVMulZchunks!-Tuple{T} where T&lt;:MoM_Kernels.ZnearChunksStruct"><code>MoM_Kernels.initialVMulZchunks!</code></a></li><li><a href="#MoM_Kernels.initialZchunksMulV!-Tuple{T} where T&lt;:MoM_Kernels.ZnearChunksStruct"><code>MoM_Kernels.initialZchunksMulV!</code></a></li><li><a href="#MoM_Kernels.initialZnearCSC-Tuple{Any, Int64}"><code>MoM_Kernels.initialZnearCSC</code></a></li><li><a href="#MoM_Kernels.initialZnearCSR-Tuple{Any, Int64}"><code>MoM_Kernels.initialZnearCSR</code></a></li><li><a href="#MoM_Kernels.initialZnearChunks-Tuple{Any, AbstractVector}"><code>MoM_Kernels.initialZnearChunks</code></a></li><li><a href="#MoM_Kernels.inputParameters-Tuple{}"><code>MoM_Kernels.inputParameters</code></a></li><li><a href="#MoM_Kernels.integral1DXW-Union{Tuple{FT}, Tuple{IT}, Tuple{FT, FT, IT, Symbol}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.integral1DXW</code></a></li><li><a href="#MoM_Kernels.interpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.interpolate</code></a></li><li><a href="#MoM_Kernels.interpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.interpolate</code></a></li><li><a href="#MoM_Kernels.interpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.interpolate!</code></a></li><li><a href="#MoM_Kernels.interpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.interpolate!</code></a></li><li><a href="#MoM_Kernels.interpolationCSCMatCal-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.GLPolesInfo{FT}, MoM_Kernels.GLPolesInfo{FT}, IT}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.interpolationCSCMatCal</code></a></li><li><a href="#MoM_Kernels.iterSolverSet-Tuple{Symbol}"><code>MoM_Kernels.iterSolverSet</code></a></li><li><a href="#MoM_Kernels.levelIntegralInfoCal-Union{Tuple{FT}, Tuple{FT, Union{Val{:Lagrange2Step}, Val{:Lagrange1Step}}}} where FT&lt;:Real"><code>MoM_Kernels.levelIntegralInfoCal</code></a></li><li><a href="#MoM_Kernels.loadCurrent-Tuple{Any}"><code>MoM_Kernels.loadCurrent</code></a></li><li><a href="#MoM_Kernels.loadGeoInterval-Tuple{Any}"><code>MoM_Kernels.loadGeoInterval</code></a></li><li><a href="#MoM_Kernels.memoryAllocationOnLevels!-Union{Tuple{LV}, Tuple{IT}, Tuple{Integer, Dict{IT, LV}}} where {IT&lt;:Integer, LV&lt;:MoM_Kernels.LevelInfo}"><code>MoM_Kernels.memoryAllocationOnLevels!</code></a></li><li><a href="#MoM_Kernels.modiSingularityRelatedConsts!-Tuple{}"><code>MoM_Kernels.modiSingularityRelatedConsts!</code></a></li><li><a href="#MoM_Kernels.octreeXWNCal-Union{Tuple{FT}, Tuple{IT}, Tuple{FT, FT, IT, Symbol}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.octreeXWNCal</code></a></li><li><a href="#MoM_Kernels.pickCycleVec-Union{Tuple{T}, Tuple{Integer, Vector{T}}} where T&lt;:Real"><code>MoM_Kernels.pickCycleVec</code></a></li><li><a href="#MoM_Kernels.pickθ-Union{Tuple{T}, Tuple{Integer, Vector{T}}} where T&lt;:Real"><code>MoM_Kernels.pickθ</code></a></li><li><a href="#MoM_Kernels.pickϕ-Union{Tuple{TT}, Tuple{Integer, Vector{TT}}} where TT&lt;:Real"><code>MoM_Kernels.pickϕ</code></a></li><li><a href="#MoM_Kernels.radarCrossSection-Union{Tuple{VT}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{VT}}} where {CT&lt;:Complex, VT&lt;:(AbstractVector)}"><code>MoM_Kernels.radarCrossSection</code></a></li><li><a href="#MoM_Kernels.radarCrossSection-Union{Tuple{BFT}, Tuple{CT}, Tuple{VT}, Tuple{Any, Any, Vector{CT}, Vector{VT}}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Type{BFT}}} where {VT&lt;:VolumeCellType, CT&lt;:Complex, BFT&lt;:BasisFunctionType}"><code>MoM_Kernels.radarCrossSection</code></a></li><li><a href="#MoM_Kernels.radarCrossSection-Union{Tuple{BFT}, Tuple{ST}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{ST}}, Tuple{Any, Any, Vector{CT}, Vector{ST}, Type{BFT}}} where {CT&lt;:Complex, ST&lt;:TriangleInfo, BFT&lt;:RWG}"><code>MoM_Kernels.radarCrossSection</code></a></li><li><a href="#MoM_Kernels.raditionalIntegralNCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Array{TriangleInfo{IT, FT}, 1}, Array{CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}"><code>MoM_Kernels.raditionalIntegralNCal</code></a></li><li><a href="#MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Matrix{CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}"><code>MoM_Kernels.raditionalIntegralNθϕCal</code></a></li><li><a href="#MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, Array{TriangleInfo{IT, FT}, 1}, Array{CT, 3}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}"><code>MoM_Kernels.raditionalIntegralNθϕCal</code></a></li><li><a href="#MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, Array{TriangleInfo{IT, FT}, 1}, Matrix{CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}"><code>MoM_Kernels.raditionalIntegralNθϕCal</code></a></li><li><a href="#MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Matrix{CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}"><code>MoM_Kernels.raditionalIntegralNθϕCal</code></a></li><li><a href="#MoM_Kernels.reOrderBasisFunctionAndGeoInfo!-Union{Tuple{VCellT}, Tuple{IT}, Tuple{Vector{IT}, Vector{VCellT}, Val{:PWC}}} where {IT&lt;:Integer, VCellT&lt;:VSCellType}"><code>MoM_Kernels.reOrderBasisFunctionAndGeoInfo!</code></a></li><li><a href="#MoM_Kernels.reOrderBasisFunctionAndGeoInfo!-Union{Tuple{VCellT}, Tuple{BFT}, Tuple{IT}, Tuple{Vector{IT}, Vector{VCellT}, Vector{BFT}}} where {IT&lt;:Integer, BFT&lt;:BasisFunctionType, VCellT&lt;:VSCellType}"><code>MoM_Kernels.reOrderBasisFunctionAndGeoInfo!</code></a></li><li><a href="#MoM_Kernels.reOrderBasisFunctionAndGeoInfo!-Union{Tuple{VT2}, Tuple{VT1}, Tuple{IT}, Tuple{Vector{IT}, Vector{VT1}, Vector{VT2}}} where {IT&lt;:Integer, VT1&lt;:(AbstractVector), VT2&lt;:(AbstractVector)}"><code>MoM_Kernels.reOrderBasisFunctionAndGeoInfo!</code></a></li><li><a href="#MoM_Kernels.reOrderCubeID!-Union{Tuple{LV}, Tuple{Integer, Dict{Int64, LV}, Dict{Int64, Vector{Int64}}}} where LV&lt;:MoM_Kernels.AbstractLevel"><code>MoM_Kernels.reOrderCubeID!</code></a></li><li><a href="#MoM_Kernels.record_memorys-Tuple{Any}"><code>MoM_Kernels.record_memorys</code></a></li><li><a href="#MoM_Kernels.restore_infos-Tuple{}"><code>MoM_Kernels.restore_infos</code></a></li><li><a href="#MoM_Kernels.saveCubes-Tuple{Any, Any}"><code>MoM_Kernels.saveCubes</code></a></li><li><a href="#MoM_Kernels.saveCurrent-Tuple{Any}"><code>MoM_Kernels.saveCurrent</code></a></li><li><a href="#MoM_Kernels.saveGeoInterval-Tuple{Any}"><code>MoM_Kernels.saveGeoInterval</code></a></li><li><a href="#MoM_Kernels.saveGeosInfoChunks-Tuple{AbstractVector, Any, AbstractString, Int64}"><code>MoM_Kernels.saveGeosInfoChunks</code></a></li><li><a href="#MoM_Kernels.saveLevel"><code>MoM_Kernels.saveLevel</code></a></li><li><a href="#MoM_Kernels.saveOctree-Tuple{Any}"><code>MoM_Kernels.saveOctree</code></a></li><li><a href="#MoM_Kernels.saveVec2Chunks-Tuple{AbstractVector, AbstractString, Any}"><code>MoM_Kernels.saveVec2Chunks</code></a></li><li><a href="#MoM_Kernels.saveVec2Chunks-Tuple{AbstractVector, AbstractString, Int64}"><code>MoM_Kernels.saveVec2Chunks</code></a></li><li><a href="#MoM_Kernels.searchNearCubes-Union{Tuple{IT}, Tuple{Matrix{IT}, Integer}} where IT&lt;:Integer"><code>MoM_Kernels.searchNearCubes</code></a></li><li><a href="#MoM_Kernels.setBFInterval!-Union{Tuple{LV}, Tuple{Integer, Dict{Int64, LV}}} where LV&lt;:MoM_Kernels.AbstractLevel"><code>MoM_Kernels.setBFInterval!</code></a></li><li><a href="#MoM_Kernels.setBigCube-Union{Tuple{FT}, Tuple{Matrix{FT}, FT}} where FT&lt;:Real"><code>MoM_Kernels.setBigCube</code></a></li><li><a href="#MoM_Kernels.setGeoIDsInLeafCubes!-Union{Tuple{CBF}, Tuple{Any, Vector{CBF}}} where CBF&lt;:ConstBasisFunction"><code>MoM_Kernels.setGeoIDsInLeafCubes!</code></a></li><li><a href="#MoM_Kernels.setGeoIDsInLeafCubes!-Union{Tuple{LBF}, Tuple{Any, Vector{LBF}}} where LBF&lt;:LinearBasisFunction"><code>MoM_Kernels.setGeoIDsInLeafCubes!</code></a></li><li><a href="#MoM_Kernels.setGeoIDsInLeafCubes!-Union{Tuple{VT}, Tuple{Any, Vector{VT}}} where VT&lt;:(AbstractVector)"><code>MoM_Kernels.setGeoIDsInLeafCubes!</code></a></li><li><a href="#MoM_Kernels.setKidLevelFarNeighbors!-Tuple{Any, Any}"><code>MoM_Kernels.setKidLevelFarNeighbors!</code></a></li><li><a href="#MoM_Kernels.setLevelInfo!-Union{Tuple{FT}, Tuple{Integer, Any, FT, StaticArraysCore.StaticArray{Tuple{3}, FT, 1}}} where FT&lt;:Real"><code>MoM_Kernels.setLevelInfo!</code></a></li><li><a href="#MoM_Kernels.setLevelInfo!-Union{Tuple{FT}, Tuple{Integer, Matrix{FT}, FT, StaticArraysCore.StaticArray{Tuple{3}, FT, 1}}} where FT&lt;:Real"><code>MoM_Kernels.setLevelInfo!</code></a></li><li><a href="#MoM_Kernels.setLevelTransFactor!-Union{Tuple{LV}, Tuple{Int64, Dict{Int64, LV}}} where LV&lt;:MoM_Kernels.AbstractLevel"><code>MoM_Kernels.setLevelTransFactor!</code></a></li><li><a href="#MoM_Kernels.setLevelsCubesKidsIn8!-Union{Tuple{LV}, Tuple{Integer, Dict{Int64, LV}}} where LV&lt;:MoM_Kernels.AbstractLevel"><code>MoM_Kernels.setLevelsCubesKidsIn8!</code></a></li><li><a href="#MoM_Kernels.setLevelsShiftFactor!-Union{Tuple{LV}, Tuple{Int64, Dict{Int64, LV}}} where LV&lt;:MoM_Kernels.AbstractLevel"><code>MoM_Kernels.setLevelsShiftFactor!</code></a></li><li><a href="#MoM_Kernels.setVSC₁₂₃ⁿ!-Tuple{}"><code>MoM_Kernels.setVSC₁₂₃ⁿ!</code></a></li><li><a href="#MoM_Kernels.set_Interpolation_Method!-Tuple{Any}"><code>MoM_Kernels.set_Interpolation_Method!</code></a></li><li><a href="#MoM_Kernels.set_geosInterval!-Tuple{Any}"><code>MoM_Kernels.set_geosInterval!</code></a></li><li><a href="#MoM_Kernels.set_leafCubeSize!-Union{Tuple{}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>MoM_Kernels.set_leafCubeSize!</code></a></li><li><a href="#MoM_Kernels.set_nprocs!-Tuple{}"><code>MoM_Kernels.set_nprocs!</code></a></li><li><a href="#MoM_Kernels.singularF1-Union{Tuple{FT}, NTuple{4, FT}} where FT&lt;:AbstractFloat"><code>MoM_Kernels.singularF1</code></a></li><li><a href="#MoM_Kernels.singularF1-Union{Tuple{FT}, Tuple{FT, FT, FT}} where FT&lt;:AbstractFloat"><code>MoM_Kernels.singularF1</code></a></li><li><a href="#MoM_Kernels.singularF21-Union{Tuple{FT}, NTuple{4, FT}} where FT&lt;:AbstractFloat"><code>MoM_Kernels.singularF21</code></a></li><li><a href="#MoM_Kernels.singularF22-Union{Tuple{FT}, NTuple{4, FT}} where FT&lt;:AbstractFloat"><code>MoM_Kernels.singularF22</code></a></li><li><a href="#MoM_Kernels.sizeChunks2cuts-Tuple{Any, Any}"><code>MoM_Kernels.sizeChunks2cuts</code></a></li><li><a href="#MoM_Kernels.sizeChunks2idxs-Tuple{Any, Any}"><code>MoM_Kernels.sizeChunks2idxs</code></a></li><li><a href="#MoM_Kernels.sizeChunksCuts2indices-Tuple{Any, Any, Tuple}"><code>MoM_Kernels.sizeChunksCuts2indices</code></a></li><li><a href="#MoM_Kernels.slicedim2bounds-Tuple{Int64, Int64}"><code>MoM_Kernels.slicedim2bounds</code></a></li><li><a href="#MoM_Kernels.slicedim2partition-Tuple{Any, Int64}"><code>MoM_Kernels.slicedim2partition</code></a></li><li><a href="#MoM_Kernels.solve-Union{Tuple{T}, Tuple{Union{LinearMaps.LinearMap{T}, MLFMAIterator{T, VT}, AbstractMatrix{T}} where VT, AbstractVector{T}}} where T&lt;:Number"><code>MoM_Kernels.solve</code></a></li><li><a href="#MoM_Kernels.solve!-Union{Tuple{T}, Tuple{Union{LinearMaps.LinearMap{T}, MLFMAIterator{T, VT}, AbstractMatrix{T}} where VT, AbstractVector{T}, AbstractVector{T}}} where T&lt;:Number"><code>MoM_Kernels.solve!</code></a></li><li><a href="#MoM_Kernels.sparseApproximateInversePl-Union{Tuple{LT}, Tuple{CT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, LT}} where {CT&lt;:Complex, LT&lt;:MoM_Kernels.AbstractLevel}"><code>MoM_Kernels.sparseApproximateInversePl</code></a></li><li><a href="#MoM_Kernels.sparseApproximateInversePl-Union{Tuple{LT}, Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, MoM_Kernels.OctreeInfo{FT, LT}}} where {FT&lt;:Real, CT&lt;:Complex{FT}, LT}"><code>MoM_Kernels.sparseApproximateInversePl</code></a></li><li><a href="#MoM_Kernels.sparseApproximateInversePl-Union{Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, AbstractVector}} where {FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.sparseApproximateInversePl</code></a></li><li><a href="#MoM_Kernels.sparseApproximateInversePl-Union{Tuple{CT}, Tuple{FT}, Tuple{MoM_Kernels.ZnearChunksStruct{CT}, Any}} where {FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.sparseApproximateInversePl</code></a></li><li><a href="#MoM_Kernels.sparseApproximateInversePr-Union{Tuple{LT}, Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, MoM_Kernels.OctreeInfo{FT, LT}}} where {FT&lt;:Real, CT&lt;:Complex{FT}, LT}"><code>MoM_Kernels.sparseApproximateInversePr</code></a></li><li><a href="#MoM_Kernels.sparseApproximateInversePr-Union{Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, AbstractVector}} where {FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.sparseApproximateInversePr</code></a></li><li><a href="#MoM_Kernels.sparseApproximateInversePr-Union{Tuple{LT}, Tuple{CT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, LT}} where {CT&lt;:Complex, LT&lt;:MoM_Kernels.AbstractLevel}"><code>MoM_Kernels.sparseApproximateInversePr</code></a></li><li><a href="#MoM_Kernels.spherical_h1l-Tuple{Integer, Real}"><code>MoM_Kernels.spherical_h1l</code></a></li><li><a href="#MoM_Kernels.spherical_h1l-Union{Tuple{T}, Tuple{Any, T}} where T"><code>MoM_Kernels.spherical_h1l</code></a></li><li><a href="#MoM_Kernels.spherical_h1l_array-Union{Tuple{T}, Tuple{Integer, T}} where T&lt;:Real"><code>MoM_Kernels.spherical_h1l_array</code></a></li><li><a href="#MoM_Kernels.spherical_h1l_array-Union{Tuple{T}, Tuple{Any, T}} where T"><code>MoM_Kernels.spherical_h1l_array</code></a></li><li><a href="#MoM_Kernels.spherical_h2l-Tuple{Integer, Real}"><code>MoM_Kernels.spherical_h2l</code></a></li><li><a href="#MoM_Kernels.spherical_h2l-Union{Tuple{T}, Tuple{Any, T}} where T"><code>MoM_Kernels.spherical_h2l</code></a></li><li><a href="#MoM_Kernels.spherical_h2l_array-Union{Tuple{T}, Tuple{Any, T}} where T"><code>MoM_Kernels.spherical_h2l_array</code></a></li><li><a href="#MoM_Kernels.spherical_h2l_array-Union{Tuple{T}, Tuple{Integer, T}} where T&lt;:Real"><code>MoM_Kernels.spherical_h2l_array</code></a></li><li><a href="#MoM_Kernels.transOnLevel!-Tuple{Any}"><code>MoM_Kernels.transOnLevel!</code></a></li><li><a href="#MoM_Kernels.transOnLevels!-Tuple{Any, Any}"><code>MoM_Kernels.transOnLevels!</code></a></li><li><a href="#MoM_Kernels.truncationLCal-Tuple{}"><code>MoM_Kernels.truncationLCal</code></a></li><li><a href="#MoM_Kernels.truncationLCal-Tuple{FT} where FT&lt;:Real"><code>MoM_Kernels.truncationLCal</code></a></li><li><a href="#MoM_Kernels.use_CSR-Tuple{}"><code>MoM_Kernels.use_CSR</code></a></li><li><a href="#MoM_Kernels.volumeSingularityIg-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.volumeSingularityIg</code></a></li><li><a href="#MoM_Kernels.volumeSingularityIgIvecg-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.volumeSingularityIgIvecg</code></a></li><li><a href="#MoM_Kernels.volumeSingularityLOpDyad-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.volumeSingularityLOpDyad</code></a></li><li><a href="#MoM_Kernels.writeZtt!-Union{Tuple{GT}, Tuple{T}, Tuple{Any, Any, T, GT, Bool}} where {T&lt;:Number, GT&lt;:VolumeCellType}"><code>MoM_Kernels.writeZtt!</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.GeosInterval" href="#MoM_Kernels.GeosInterval"><code>MoM_Kernels.GeosInterval</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>保存网格数据区间的实例。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Extends/ParallelParams.jl#L33-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.MLFMAParams" href="#MoM_Kernels.MLFMAParams"><code>MoM_Kernels.MLFMAParams</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>多层快速多极子的可调参数</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/MLFMAParams.jl#L16-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.ParallelParams" href="#MoM_Kernels.ParallelParams"><code>MoM_Kernels.ParallelParams</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>保存并行参数的实例。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Extends/ParallelParams.jl#L7-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.SSCg" href="#MoM_Kernels.SSCg"><code>MoM_Kernels.SSCg</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>计算面奇异性时用的两个系数。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/Singularity.jl#L50-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.SSCgdivnp2" href="#MoM_Kernels.SSCgdivnp2"><code>MoM_Kernels.SSCgdivnp2</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>计算体奇异性时用到的一些系数。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/Singularity.jl#L56-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.VSC₃ⁿ" href="#MoM_Kernels.VSC₃ⁿ"><code>MoM_Kernels.VSC₃ⁿ</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>这一项面、体奇异性都用到了，处理对格林函数梯度求积时的奇异性时用到的。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/Singularity.jl#L63-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.ZnearT" href="#MoM_Kernels.ZnearT"><code>MoM_Kernels.ZnearT</code></a> — <span class="docstring-category">Type</span></header><section><div><p>近场阻抗矩阵的类型集合。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/Znear.jl#L6-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.CubeInfo" href="#MoM_Kernels.CubeInfo"><code>MoM_Kernels.CubeInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CubeInfo{IT&lt;:Integer, FT&lt;:Real}</code></pre><p>盒子信息，包括：</p><pre><code class="nohighlight hljs">kidsInterval    ::UnitRange{IT}     子层盒子id的区间
bfInterval      ::UnitRange{IT}     包含的基函数区间
kidsIn8         ::Vector{IT}        非空子盒子在8个子盒子中的id
geoIDs          ::Vector{IT}        包含的网格如三角形、四面体的id，以基函数进行分，因此边界上的同一个网格可能被分到不同的盒子内。
neighbors       ::Vector{IT}        邻盒子id
farneighbors    ::Vector{IT}        远亲盒子的id
ID3D            ::MVec3D{IT}        本盒子在本层的三维整数坐标
center          ::MVec3D{FT}        本盒子在本层的三维全局坐标</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LevelInfo.jl#L5-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.GLPolesInfo" href="#MoM_Kernels.GLPolesInfo"><code>MoM_Kernels.GLPolesInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><p>多极子的极信息，即角谱空间采样信息 Xθs::Vector{FT}，θ方向的采样点坐标（rad单位），高斯-勒让德求积 Xϕs::Vector{FT}，ϕ方向的采样点坐标（rad单位），均值求积 Wθϕs::Vector{FT}，采样点权重，用于积分时使用，在MLFMA中直接乘在转移项</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LagrangeInterpolation.jl#L84-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.GeosIntervalType" href="#MoM_Kernels.GeosIntervalType"><code>MoM_Kernels.GeosIntervalType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeosIntervalType{T}</code></pre><p>保存网格数据区间的类。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Extends/ParallelParams.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.LagrangeInterp1StepInfo" href="#MoM_Kernels.LagrangeInterp1StepInfo"><code>MoM_Kernels.LagrangeInterp1StepInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><p>保存总的 稀疏插值矩阵，用于单步插值，根据稀疏度决定保存稀疏阵或是稠密阵 θϕCSC       ::AbstractMatrix{FT} 稀疏矩阵, θ 方向插值矩阵的转置，用于左乘本层多极子矩阵，在 θ 方向反插值 θϕCSCT      ::AbstractMatrix{FT} 稀疏矩阵, ϕ 方向插值矩阵的转置，用于左乘本层多极子矩阵，在 ϕ 方向反插值</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LagrangeInterpolation.jl#L191-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.LagrangeInterp1StepInfo-Union{Tuple{IT}, Tuple{FT}, Tuple{SparseArrays.SparseMatrixCSC{FT, IT}, SparseArrays.SparseMatrixCSC{FT, IT}}} where {FT&lt;:Real, IT}" href="#MoM_Kernels.LagrangeInterp1StepInfo-Union{Tuple{IT}, Tuple{FT}, Tuple{SparseArrays.SparseMatrixCSC{FT, IT}, SparseArrays.SparseMatrixCSC{FT, IT}}} where {FT&lt;:Real, IT}"><code>MoM_Kernels.LagrangeInterp1StepInfo</code></a> — <span class="docstring-category">Method</span></header><section><div><p>带参数的构造函数</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LagrangeInterpolation.jl#L204-L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.LagrangeInterpInfo" href="#MoM_Kernels.LagrangeInterpInfo"><code>MoM_Kernels.LagrangeInterpInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><p>保存 θ, ϕ 两个方向的稀疏插值矩阵， θ方向为 (npXθs, ntXθs) 稀疏矩阵, 用于左乘本层多极子矩阵，在 θ 方向插值 ϕ方向为 (ntXϕs, ntXϕs) 稀疏矩阵, 用于右乘本层多极子矩阵，在 ϕ 方向插值 θCSCT   ::SparseMatrixCSC{FT} 稀疏矩阵, θ 方向插值矩阵的转置，用于左乘本层多极子矩阵，在 θ 方向反插值 ϕCSCT   ::SparseMatrixCSC{FT} 稀疏矩阵, ϕ 方向插值矩阵的转置，用于左乘本层多极子矩阵，在 ϕ 方向反插值</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LagrangeInterpolation.jl#L129-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.LagrangeInterpInfo-Union{Tuple{IT}, Tuple{FT}, Tuple{SparseArrays.SparseMatrixCSC{FT, IT}, SparseArrays.SparseMatrixCSC{FT, IT}}} where {FT&lt;:Real, IT}" href="#MoM_Kernels.LagrangeInterpInfo-Union{Tuple{IT}, Tuple{FT}, Tuple{SparseArrays.SparseMatrixCSC{FT, IT}, SparseArrays.SparseMatrixCSC{FT, IT}}} where {FT&lt;:Real, IT}"><code>MoM_Kernels.LagrangeInterpInfo</code></a> — <span class="docstring-category">Method</span></header><section><div><p>带参数的构造函数</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LagrangeInterpolation.jl#L145-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.LevelInfo" href="#MoM_Kernels.LevelInfo"><code>MoM_Kernels.LevelInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LevelInfo{IT&lt;:Integer, FT&lt;:Real, IPT} &lt;: AbstractLevel</code></pre><p>层信息：</p><pre><code class="nohighlight hljs">ID          ::IT                        层序号
isleaf      ::Bool                      是否为叶层
L           ::IT                        本层截断项数
cubes       ::Vector{CubeInfo{IT, FT}}  包含每一个盒子信息的向量
cubeEdgel   ::FT                        本层盒子的边长
poles       ::PolesInfo{IT, FT}         多极子采样信息
interpWθϕ   ::InterpInfo{IT, FT}        插值信息
aggS        ::Array{Complex{FT}, 3}     聚合项
disaggG     ::Array{Complex{FT}, 3}     解聚项
phaseShift2Kids  ::Array{Complex{FT}, 3}本层盒子到子层盒子的相移因子 
αTrans      ::Array{Complex{FT}, 3}     本层盒子远亲组之间的转移因子，根据相对位置共有 7^3 - 3^3 = 316 个
αTransIndex ::Array{IT, 2}              远亲盒子的相对位置到其转移因子在所有转移因子数组的索引</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LevelInfo.jl#L33-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.MLFMAIterator" href="#MoM_Kernels.MLFMAIterator"><code>MoM_Kernels.MLFMAIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>保存 MLFMA 相关信息的结构体</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/MLFMAIterators.jl#L4-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.MLFMAIterator-Union{Tuple{LT}, Tuple{FT}, Tuple{Any, MoM_Kernels.OctreeInfo{FT, LT}, Vector, Vector}} where {FT&lt;:Real, LT&lt;:MoM_Kernels.LevelInfo}" href="#MoM_Kernels.MLFMAIterator-Union{Tuple{LT}, Tuple{FT}, Tuple{Any, MoM_Kernels.OctreeInfo{FT, LT}, Vector, Vector}} where {FT&lt;:Real, LT&lt;:MoM_Kernels.LevelInfo}"><code>MoM_Kernels.MLFMAIterator</code></a> — <span class="docstring-category">Method</span></header><section><div><p>实现矩阵向量乘积，并封装为线性算子</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/MLFMAIterators.jl#L40-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.MLFMAParamsType" href="#MoM_Kernels.MLFMAParamsType"><code>MoM_Kernels.MLFMAParamsType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>创建可变参数类型以在频率更改时对应更改 MLFMA 的相关参数</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/MLFMAParams.jl#L6-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.MatrixChunk" href="#MoM_Kernels.MatrixChunk"><code>MoM_Kernels.MatrixChunk</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MatrixChunk{T&lt;:Number} &lt;:AbstractMatrix{T}</code></pre><p>创建近场矩阵块结构体，所包含的数据为某一盒子内的近场矩阵元。</p><pre><code class="nohighlight hljs">m::Int                          行数
n::Int                          列数
mat::Matrix{T}                  矩阵
rowIndices::AbstractVector{Int} 行索引
colIndices::AbstractVector{Int} 列索引
lmul::AbstractVector{T}         用于左乘其它矩阵、向量的临时数组，大小与列数相同
rmul::AbstractVector{T}         用于右乘其它矩阵、向量的临时数组，大小与行数相同</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/MatrixChunk.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.MatrixChunk-Union{Tuple{T}, Tuple{Any, Any}} where T&lt;:Number" href="#MoM_Kernels.MatrixChunk-Union{Tuple{T}, Tuple{Any, Any}} where T&lt;:Number"><code>MoM_Kernels.MatrixChunk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MatrixChunk{T}(rowIndices, colIndices) where {T&lt;:Number}</code></pre><p>用行、列索引 <code>rowIndices, colIndices</code> 初始化矩阵块。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/MatrixChunk.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.OctreeInfo" href="#MoM_Kernels.OctreeInfo"><code>MoM_Kernels.OctreeInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><p>八叉树类 nLevels ::Integer, 叶层ID（定义大盒子为（“0” 层），叶层为第“n”层，nLevels取“n”的值） leafCubeEdgel::FT，叶层盒子边长 bigCubeLowerCoor::MVec3D{FT}，第0层盒子的角坐标 levels  ::Dict{Int, LevelInfo}，保存各层信息的字典</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/OctreeInfo.jl#L6-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.OctreeInfo-Union{Tuple{LT}, Tuple{FT}, Tuple{Matrix{FT}, FT}} where {FT&lt;:Real, LT&lt;:MoM_Kernels.AbstractLevel}" href="#MoM_Kernels.OctreeInfo-Union{Tuple{LT}, Tuple{FT}, Tuple{Matrix{FT}, FT}} where {FT&lt;:Real, LT&lt;:MoM_Kernels.AbstractLevel}"><code>MoM_Kernels.OctreeInfo</code></a> — <span class="docstring-category">Method</span></header><section><div><p>构建八叉树类</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/OctreeInfo.jl#L20-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.PartitionedVector" href="#MoM_Kernels.PartitionedVector"><code>MoM_Kernels.PartitionedVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PartitionedVector{T} &lt;: AbstractVector{T}</code></pre><p>用于保存向量块的类，同时在块内保存一些其他块的数据。</p><pre><code class="nohighlight hljs">size::Int                           原始 Vector 的大小
data::OffsetVector{T, Vector{T}}    本地保存的数据
indices::UnitRange{Int}             本地保存数据的索引区间
ghostdata::SparseVector{T, Int}     用到的其它数据
ghostindices::Vector{Int}           用到的其它数据的索引区间</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Extends/PartitionedVector.jl#L2-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.SAIChunkPrec" href="#MoM_Kernels.SAIChunkPrec"><code>MoM_Kernels.SAIChunkPrec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SAIChunkPrec{T} &lt;: AbstractMatrix{T}</code></pre><p>分块系数近似逆的结构体。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Precondition/SAIChunks.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.SAIPrec" href="#MoM_Kernels.SAIPrec"><code>MoM_Kernels.SAIPrec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SAIPrec{T} &lt;: AbstractMatrix{T}</code></pre><p>封装系数近似逆矩阵的类型。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Precondition/SAI.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.ZnearChunksStruct" href="#MoM_Kernels.ZnearChunksStruct"><code>MoM_Kernels.ZnearChunksStruct</code></a> — <span class="docstring-category">Type</span></header><section><div><p>创建近场矩阵结构体，所包含的数据为所有盒子内的近场矩阵元，多线程版本</p><pre><code class="nohighlight hljs">m::Int                  行数
n::Int                  列数
nChunks::Int            矩阵块儿数
chunks::Vector{ZnearChunksStruct{T}}    矩阵
lmul::Vector{T}         用于左乘其它矩阵、向量的临时数组，大小与列数相同
lmuld::Vector{T}        用于左乘其它矩阵、向量的临时分布式数组，大小与列数相同，默认不分配
rmul::Vector{T}         用于右乘其它矩阵、向量的临时数组，大小与行数相同
lmuld::Vector{T}        用于左乘其它矩阵、向量的临时分布式数组，大小与列数相同，默认不分配</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/ZnearChunks.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.ZnearChunksStruct-Union{Tuple{Any}, Tuple{T}} where T&lt;:Number" href="#MoM_Kernels.ZnearChunksStruct-Union{Tuple{Any}, Tuple{T}} where T&lt;:Number"><code>MoM_Kernels.ZnearChunksStruct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ZnearChunksStruct{T}(chunks; m, n) where {T&lt;:Number}</code></pre><p>ZnearChunksStruct 类的初始化函数。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/ZnearChunks.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{AbstractMatrix, T}} where T&lt;:MoM_Kernels.MatrixChunk" href="#Base.:*-Union{Tuple{T}, Tuple{AbstractMatrix, T}} where T&lt;:MoM_Kernels.MatrixChunk"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(mat::AbstractMatrix, Z::T) where{T&lt;:MatrixChunk}</code></pre><p>实现右乘其它矩阵，默认矩阵块较小，不在本阶段并行。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/MatrixChunk.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{AbstractVector, T}} where T&lt;:MoM_Kernels.MatrixChunk" href="#Base.:*-Union{Tuple{T}, Tuple{AbstractVector, T}} where T&lt;:MoM_Kernels.MatrixChunk"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(x::AbstractVector, Z::T) where{T&lt;:MatrixChunk}</code></pre><p>实现矩阵块 <code>Z</code> 右乘其它向量，默认矩阵块较小，不在本阶段并行。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/MatrixChunk.jl#L127-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{MoM_Kernels.ZNEARCHUNK{T}, AbstractMatrix}} where T&lt;:Number" href="#Base.:*-Union{Tuple{T}, Tuple{MoM_Kernels.ZNEARCHUNK{T}, AbstractMatrix}} where T&lt;:Number"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.:*(Z::ZNEARCHUNK{T}, mat::AbstractMatrix) where{T&lt;:Number}</code></pre><p>实现左乘其它矩阵</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/ZnearChunks.jl#L163-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{T, AbstractMatrix}} where T&lt;:MoM_Kernels.MatrixChunk" href="#Base.:*-Union{Tuple{T}, Tuple{T, AbstractMatrix}} where T&lt;:MoM_Kernels.MatrixChunk"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(Z::T, mat::AbstractMatrix) where{T&lt;:MatrixChunk}</code></pre><p>实现矩阵块 <code>Z</code> 左乘其它矩阵，默认矩阵块较小，不在本阶段并行。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/MatrixChunk.jl#L113-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{T, AbstractVector}} where T&lt;:MoM_Kernels.MatrixChunk" href="#Base.:*-Union{Tuple{T}, Tuple{T, AbstractVector}} where T&lt;:MoM_Kernels.MatrixChunk"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.:*(Z::T, x::AbstractVector) where{T&lt;:MatrixChunk}</code></pre><p>实现左乘其它向量，默认矩阵块较小，因此不在本阶段并行</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/MatrixChunk.jl#L84-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{T, AbstractVector}} where T&lt;:MoM_Kernels.ZnearChunksStruct" href="#Base.:*-Union{Tuple{T}, Tuple{T, AbstractVector}} where T&lt;:MoM_Kernels.ZnearChunksStruct"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.:*(Z::T, x::AbstractVector) where{T&lt;:ZnearChunksStruct}</code></pre><p>实现左乘其它向量</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/ZnearChunks.jl#L117-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Union{Tuple{LTo}, Tuple{LTt}, Tuple{FT}, Tuple{Type{MoM_Kernels.OctreeInfo{FT, LTt}}, MoM_Kernels.OctreeInfo{FT, LTo}}} where {FT&lt;:Real, LTt&lt;:MoM_Kernels.AbstractLevel, LTo&lt;:MoM_Kernels.AbstractLevel}" href="#Base.convert-Union{Tuple{LTo}, Tuple{LTt}, Tuple{FT}, Tuple{Type{MoM_Kernels.OctreeInfo{FT, LTt}}, MoM_Kernels.OctreeInfo{FT, LTo}}} where {FT&lt;:Real, LTt&lt;:MoM_Kernels.AbstractLevel, LTo&lt;:MoM_Kernels.AbstractLevel}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><p>实现包含分布式层的</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/OctreeInfo.jl#L85-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.eltype-Tuple{IncompleteLU.ILUFactorization}" href="#Base.eltype-Tuple{IncompleteLU.ILUFactorization}"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eltype(opt::ILUFactorization)</code></pre><p>提供 ilu 的算子 eltype 函数。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Precondition/Precondition.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Union{Tuple{I}, Tuple{PartitionedVector, I}} where I&lt;:Integer" href="#Base.getindex-Union{Tuple{I}, Tuple{PartitionedVector, I}} where I&lt;:Integer"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.getindex(A::PartitionedVector, i::I) where {I&lt;:Integer}</code></pre><p>重载 <code>PartitionedVector</code> 类型的 <code>getindex</code> 函数。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Extends/PartitionedVector.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T&lt;:MoM_Kernels.MatrixChunk" href="#Base.getindex-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T&lt;:MoM_Kernels.MatrixChunk"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(Z::T, i1::Int, i2::Int) where{T&lt;:MatrixChunk}</code></pre><p>重载 getindex 函数。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/MatrixChunk.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T&lt;:MoM_Kernels.ZNEARCHUNK" href="#Base.getindex-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T&lt;:MoM_Kernels.ZNEARCHUNK"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><p>重载 getindex 函数</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/ZnearChunks.jl#L60-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.setindex!-Union{Tuple{T}, Tuple{T, Any, Int64, Int64}} where T&lt;:MoM_Kernels.MatrixChunk" href="#Base.setindex!-Union{Tuple{T}, Tuple{T, Any, Int64, Int64}} where T&lt;:MoM_Kernels.MatrixChunk"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setindex!(Z::T, x, i1::Int, i2::Int) where{T&lt;:MatrixChunk}</code></pre><p>重载 setindex! 函数</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/MatrixChunk.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.setindex!-Union{Tuple{T}, Tuple{T, Any, Int64, Int64}} where T&lt;:MoM_Kernels.ZNEARCHUNK" href="#Base.setindex!-Union{Tuple{T}, Tuple{T, Any, Int64, Int64}} where T&lt;:MoM_Kernels.ZNEARCHUNK"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setindex!(Z::T, x, i1::Int, i2::Int) where{T&lt;:ZNEARCHUNK}</code></pre><p>重载 setindex! 函数</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/ZnearChunks.jl#L75-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.size-Tuple{T} where T&lt;:IncompleteLU.ILUFactorization" href="#Base.size-Tuple{T} where T&lt;:IncompleteLU.ILUFactorization"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">size(operator::T) where {T&lt;:ILUFactorization}</code></pre><p>提供 ilu 的算子 size 函数。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Precondition/Precondition.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.ldiv!-Union{Tuple{T}, Tuple{SAIChunkPrec{T}, AbstractVector}} where T" href="#LinearAlgebra.ldiv!-Union{Tuple{T}, Tuple{SAIChunkPrec{T}, AbstractVector}} where T"><code>LinearAlgebra.ldiv!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ldiv!(M::SAIChunkPrec{T}, x::AbstractVector) where {T}
ldiv!(y::AbstractVector, M::SAIChunkPrec{T}, x::AbstractVector) where {T}</code></pre><p>实现 <code>x .= M * x</code> 或 <code>y .= M * x</code>。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Precondition/SAIChunks.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.ldiv!-Union{Tuple{T}, Tuple{SAIPrec{T}, AbstractVector}} where T" href="#LinearAlgebra.ldiv!-Union{Tuple{T}, Tuple{SAIPrec{T}, AbstractVector}} where T"><code>LinearAlgebra.ldiv!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ldiv!(M::SAIPrec{T}, x::AbstractVector) where {T}
ldiv!(y::AbstractVector, M::SAIPrec{T}, x::AbstractVector) where {T}</code></pre><p>实现 <code>x .= M * x</code> 或 <code>y .= M * x</code>。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Precondition/SAI.jl#L18-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.mul!-Tuple{AbstractVector, MLFMAIterator, AbstractVector, Number, Number}" href="#LinearAlgebra.mul!-Tuple{AbstractVector, MLFMAIterator, AbstractVector, Number, Number}"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LinearAlgebra.mul!(y, Zopt::MLFMAIterator, x)

重载以实现矩阵向量乘积计算</code></pre><p>TBW</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/MLFMAIterators.jl#L94-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.mul!-Tuple{Any, MLFMAIterator, Any}" href="#LinearAlgebra.mul!-Tuple{Any, MLFMAIterator, Any}"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LinearAlgebra.mul!(y, Zopt::MLFMAIterator, x)

重载以实现矩阵向量乘积计算</code></pre><p>TBW</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/MLFMAIterators.jl#L75-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.mul!-Union{Tuple{T}, Tuple{Any, T, AbstractVector}} where T&lt;:MoM_Kernels.MatrixChunk" href="#LinearAlgebra.mul!-Union{Tuple{T}, Tuple{Any, T, AbstractVector}} where T&lt;:MoM_Kernels.MatrixChunk"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mul!(y, Z::T, x::AbstractVector) where{T&lt;:MatrixChunk}</code></pre><p>实现矩阵块 <code>Z</code> 的矩阵向量乘积计算。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/MatrixChunk.jl#L97-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.mul!-Union{Tuple{V}, Tuple{T}, Tuple{AbstractVector, LinearAlgebra.Adjoint{T, MLFMAIterator{T, V}}, AbstractVector, Number, Number}} where {T, V}" href="#LinearAlgebra.mul!-Union{Tuple{V}, Tuple{T}, Tuple{AbstractVector, LinearAlgebra.Adjoint{T, MLFMAIterator{T, V}}, AbstractVector, Number, Number}} where {T, V}"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LinearAlgebra.mul!(y, Zopt::MLFMAIterator, x)

重载以实现矩阵向量乘积计算</code></pre><p>TBW</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/MLFMAIterators.jl#L142-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.mul!-Union{Tuple{V}, Tuple{T}, Tuple{Any, LinearAlgebra.Adjoint{T, MLFMAIterator{T, V}}, Any}} where {T, V}" href="#LinearAlgebra.mul!-Union{Tuple{V}, Tuple{T}, Tuple{Any, LinearAlgebra.Adjoint{T, MLFMAIterator{T, V}}, Any}} where {T, V}"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LinearAlgebra.mul!(y, Zopt::MLFMAIterator, x)

重载以实现矩阵向量乘积计算</code></pre><p>TBW</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/MLFMAIterators.jl#L122-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.CFIEOnNearTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}" href="#MoM_Kernels.CFIEOnNearTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.CFIEOnNearTris</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形不重合但相隔较近的情况，因此输入有两个个三角形信息类型实例 输入 trit， tris     :   TriangleInfo, 场三角形和源三角形</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/CFIE/CFIERWGTri.jl#L111-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.CFIEOnTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}" href="#MoM_Kernels.CFIEOnTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.CFIEOnTris</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形不重合且相隔较远的情况，因此输入有两个个三角形信息类型实例 输入 trit， tris     :   TriangleInfo, 场三角形和源三角形</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/CFIE/CFIERWGTri.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.CFIEOnTris-Union{Tuple{TriangleInfo{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}" href="#MoM_Kernels.CFIEOnTris-Union{Tuple{TriangleInfo{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.CFIEOnTris</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形重合的情况，因此输入只有一个三角形信息类型实例 输入 tri     :   TriangleInfo</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/CFIE/CFIERWGTri.jl#L229-L234">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnHexaPWC-Union{Tuple{HexahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnHexaPWC-Union{Tuple{HexahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnHexaPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC 基函数 计算六面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体重合的情况，因此输入有一个六面体信息类型实例 输入： hexat   HexahedraInfo, 场六面体和六面体 计算： jkη₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 其中， ∫ₜ∫ₛ∇∇G(R)dV′dV = ∫ₜ∑ᵢn̂ᵢ(∫ᵢR̂(jk + 1/R)G(R)dS′)dV 计算得到结果为并矢:: jη₀/k ∫∫ (k²I + ∇∇)G(R) dV&#39;dV Kᵣⁿ  =   ∫ Rⁿ dV&#39; K̂ᵣⁿ  =   ∫ R̂Rⁿ dV&#39; 注意为与两两作用不同，此处加上了 κ 项，因此后续填充时不需加上。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEPWCHexa.jl#L114-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnHexaPWCSepPV-Union{Tuple{HexahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnHexaPWCSepPV-Union{Tuple{HexahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnHexaPWCSepPV</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC 基函数 计算六面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体重合的情况，因此输入有一个六面体信息类型实例 输入： hexat   HexahedraInfo, 场六面体和六面体 计算： jkη₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 其中， ∫ₜ∫ₛ∇∇G(R)dV′dV = ∫ₜ∑ᵢn̂ᵢ(∫ᵢR̂(jk + 1/R)G(R)dS′)dV 计算得到结果为并矢:: jη₀/k ∫∫ (k²I + ∇∇)G(R) dV&#39;dV Kᵣⁿ  =   ∫ Rⁿ dV&#39; K̂ᵣⁿ  =   ∫ R̂Rⁿ dV&#39; 注意为与两两作用不同，此处加上了 κ 项，因此后续填充时不需加上。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEPWCHexa.jl#L159-L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnHexaRBF-Union{Tuple{HexahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnHexaRBF-Union{Tuple{HexahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnHexaRBF</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算六面体上相关的 36 个阻抗矩阵元， 此函数方法用于计算场源六面体重合的情况，因此输入有一个六面体信息类型实例 输入 hexat     :   HexahedraInfo, 场六面体和源六面体</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIERBFHexa.jl#L249-L254">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnHexaTetraPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC 基函数 计算六面体和四面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况，因此输入有两个六面体信息类型实例 输入： hexat::HexahedraInfo,   场六面体 tetras::TetrahedraInfo  源四面体 计算： <code>jk₀η₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV</code> 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEPWCTetraHexa.jl#L2-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnHexaTetraPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC 基函数 计算六面体和四面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况，因此输入有两个六面体信息类型实例 输入： tetrat::TetrahedraInfo  场四面体 hexas::HexahedraInfo,   源六面体 计算： <code>jk₀η₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV</code> 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEPWCTetraHexa.jl#L67-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnHexasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnHexasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnHexasPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC 基函数 计算六面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况，因此输入有两个六面体信息类型实例 输入： hexat  hexas     :   HexahedraInfo, 场六面体和六面体 计算： <code>jk₀η₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV</code> 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEPWCHexa.jl#L2-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnHexasRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnHexasRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnHexasRBF</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算六面体上相关的 36 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况，因此输入有两个六面体信息类型实例 输入 hexat, hexas     :   HexahedraInfo, 场六面体和源六面体</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIERBFHexa.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnNearHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearHexaTetraPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC 基函数 计算六面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较近的情况，因此输入有两个六面体信息类型实例 输入： hexat  hexas     :   HexahedraInfo, 场六面体和六面体 计算： jkη₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 其中， ∫ₜ∫ₛ∇∇G(R)dV′dV = ∫ₜ∑ᵢn̂ᵢ(∫ᵢR̂(jk + 1/R)G(R)dS′)dV 计算得到结果为并矢:: jη₀/k ∫∫ (k²I + ∇∇)G(R) dV&#39;dV Kᵣⁿ  =   ∫ Rⁿ dV&#39; K̂ᵣⁿ  =   ∫ R̂Rⁿ dV&#39; 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEPWCTetraHexa.jl#L88-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnNearHexaTetraPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearHexaTetraPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC 基函数 计算六面体和四面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况，因此输入有两个六面体信息类型实例 输入： tetrat::TetrahedraInfo  场四面体 hexas::HexahedraInfo,   源六面体 计算： <code>jk₀η₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV</code> 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEPWCTetraHexa.jl#L129-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearHexasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnNearHexasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearHexasPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC 基函数 计算六面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较近的情况，因此输入有两个六面体信息类型实例 输入： hexat  hexas     :   HexahedraInfo, 场六面体和六面体 计算： jkη₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 其中， ∫ₜ∫ₛ∇∇G(R)dV′dV = ∫ₜ∑ᵢn̂ᵢ(∫ᵢR̂(jk + 1/R)G(R)dS′)dV 计算得到结果为并矢:: jη₀/k ∫∫ (k²I + ∇∇)G(R) dV&#39;dV Kᵣⁿ  =   ∫ Rⁿ dV&#39; K̂ᵣⁿ  =   ∫ R̂Rⁿ dV&#39; 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEPWCHexa.jl#L73-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearHexasRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnNearHexasRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearHexasRBF</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算六面体上相关的 36 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合但相隔较近的情况，输入有两个六面体信息类型实例 输入 hexat, hexas     :   HexahedraInfo, 场六面体和源六面体</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIERBFHexa.jl#L494-L499">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:HexahedraInfo}" href="#MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:HexahedraInfo}"><code>MoM_Kernels.EFIEOnNearRWGPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和六面体上相关的 9 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较近的情况 输入 trit    ::  TriangleInfo,  场三角形面体 geos    ::  HexahedraInfo, 源六面体</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEVSIERWGPWCHexa.jl#L103-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:VolumeCellType}" href="#MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:VolumeCellType}"><code>MoM_Kernels.EFIEOnNearRWGPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和四面体上相关的 9 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较近的情况 输入 trit    ::  TriangleInfo,  场三角形面体 geos    ::  TetrahedraInfo, TetrahedraInfo, 源四面体、四面体</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEVSIERWGPWCTetra.jl#L103-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:HexahedraInfo}" href="#MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:HexahedraInfo}"><code>MoM_Kernels.EFIEOnNearRWGPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和六面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 geot    ::  HexahedraInfo, 场六面体</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEVSIERWGPWCHexa.jl#L159-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:VolumeCellType}" href="#MoM_Kernels.EFIEOnNearRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:VolumeCellType}"><code>MoM_Kernels.EFIEOnNearRWGPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和四面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 geot    ::  TetrahedraInfo, TetrahedraInfo, 场四面体、四面体</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEVSIERWGPWCTetra.jl#L159-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnNearRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearRWGRBF</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和六面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 hexat  ::  HexahedraInfo, 场六面体</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEVSIERWGRBF.jl#L294-L300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnNearRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearRWGRBF</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和六面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较近的情况 输入 tris    ::  TriangleInfo,  源三角形面体 hexat  ::  HexahedraInfo, 场六面体</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEVSIERWGRBF.jl#L161-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnNearRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearRWGSWG</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和四面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 tetrat  ::  TetrahedraInfo, 场四面体</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEVSIERWGSWG.jl#L290-L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnNearRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearRWGSWG</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和四面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较近的情况 输入 tris    ::  TriangleInfo,  源三角形面体 tetrat  ::  TetrahedraInfo, 场四面体</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEVSIERWGSWG.jl#L158-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearTetrasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnNearTetrasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearTetrasPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC 基函数 计算四面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较近的情况，因此输入有两个四面体信息类型实例 输入： tetrat  tetras     :   TetrahedraInfo, 场四面体和四面体 计算： jkη₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 其中， ∫ₜ∫ₛ∇∇G(R)dV′dV = ∫ₜ∑ᵢn̂ᵢ(∫ᵢR̂(jk + 1/R)G(R)dS′)dV 计算得到结果为并矢:: jη₀/k ∫∫ (k²I + ∇∇)G(R) dV&#39;dV Kᵣⁿ  =   ∫ Rⁿ dV&#39; K̂ᵣⁿ  =   ∫ R̂Rⁿ dV&#39; 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEPWCTetra.jl#L74-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearTetrasSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnNearTetrasSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnNearTetrasSWG</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算四面体上相关的 16 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合但相隔较近的情况，输入有两个四面体信息类型实例 输入 tetrat, tetras     :   TetrahedraInfo, 场四面体和源四面体</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIESWGTetra.jl#L452-L457">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnNearTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}" href="#MoM_Kernels.EFIEOnNearTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.EFIEOnNearTris</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形不重合但相隔较近的情况，因此输入有两个个三角形信息类型实例 输入 trit， tris     :   TriangleInfo, 场三角形和源三角形</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIERWGTri.jl#L85-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:HexahedraInfo}" href="#MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:HexahedraInfo}"><code>MoM_Kernels.EFIEOnRWGPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和六面体上相关的 9 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况 输入 trit    ::  TriangleInfo,  场三角形面体 geos    ::  HexahedraInfo, 源六面体</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEVSIERWGPWCHexa.jl#L4-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:TetrahedraInfo}" href="#MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, VT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:TetrahedraInfo}"><code>MoM_Kernels.EFIEOnRWGPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和四面体上相关的 9 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况 输入 trit    ::  TriangleInfo,  场三角形面体 geos    ::  TetrahedraInfo, 源四面体</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEVSIERWGPWCTetra.jl#L4-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:HexahedraInfo}" href="#MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:HexahedraInfo}"><code>MoM_Kernels.EFIEOnRWGPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和六面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 geot    ::  HexahedraInfo, 场六面体</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEVSIERWGPWCHexa.jl#L91-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:VolumeCellType}" href="#MoM_Kernels.EFIEOnRWGPWC-Union{Tuple{VT}, Tuple{FT}, Tuple{IT}, Tuple{VT, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, VT&lt;:VolumeCellType}"><code>MoM_Kernels.EFIEOnRWGPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和四面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 geot    ::  TetrahedraInfo, TetrahedraInfo, 场四面体、四面体</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEVSIERWGPWCTetra.jl#L91-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{HexahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnRWGRBF</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和六面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 hexat  ::  HexahedraInfo, 场六面体</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEVSIERWGRBF.jl#L149-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnRWGRBF-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnRWGRBF</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和六面体上相关的 18 个阻抗矩阵元， 此函数方法用于计算场源六面体不重合且相隔较远的情况 输入 trit    ::  TriangleInfo,  场三角形面体 hexas   ::  HexahedraInfo, 源六面体</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEVSIERWGRBF.jl#L4-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnRWGSWG</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和四面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 tetrat  ::  TetrahedraInfo, 场四面体</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEVSIERWGSWG.jl#L146-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnRWGSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnRWGSWG</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形和四面体上相关的 12 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况 输入 tris    ::  TriangleInfo,  源三角形面体 tetrat  ::  TetrahedraInfo, 场四面体</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEVSIERWGSWG.jl#L4-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnTetraPWC-Union{Tuple{TetrahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnTetraPWC-Union{Tuple{TetrahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnTetraPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC 基函数 计算四面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源四面体重合的情况，因此输入有一个四面体信息类型实例 输入： tetrat   TetrahedraInfo, 场四面体和四面体 计算： jkη₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 其中， ∫ₜ∫ₛ∇∇G(R)dV′dV = ∫ₜ∑ᵢn̂ᵢ(∫ᵢR̂(jk + 1/R)G(R)dS′)dV 计算得到结果为并矢:: jη₀/k ∫∫ (k²I + ∇∇)G(R) dV&#39;dV Kᵣⁿ  =   ∫ Rⁿ dV&#39; K̂ᵣⁿ  =   ∫ R̂Rⁿ dV&#39; 注意为与两两作用不同，此处加上了 κ 项，因此后续填充时不需加上。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEPWCTetra.jl#L115-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnTetraPWCSepPV-Union{Tuple{TetrahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnTetraPWCSepPV-Union{Tuple{TetrahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnTetraPWCSepPV</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC 基函数 计算四面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源四面体重合的情况，因此输入有一个四面体信息类型实例 输入： tetrat   TetrahedraInfo, 场四面体和四面体 计算： jkη₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 其中， ∫ₜ∫ₛ∇∇G(R)dV′dV = ∫ₜ∑ᵢn̂ᵢ(∫ᵢR̂(jk + 1/R)G(R)dS′)dV 计算得到结果为并矢:: jη₀/k ∫∫ (k²I + ∇∇)G(R) dV&#39;dV Kᵣⁿ  =   ∫ Rⁿ dV&#39; K̂ᵣⁿ  =   ∫ R̂Rⁿ dV&#39; 注意为与两两作用不同，函数将主值积分分开返回以便它用</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEPWCTetra.jl#L160-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnTetraSWG-Union{Tuple{TetrahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnTetraSWG-Union{Tuple{TetrahedraInfo{IT, FT, CT}}, Tuple{CT}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnTetraSWG</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算四面体上相关的 16 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况，因此输入有两个四面体信息类型实例 输入 tetrat, tetras     :   TetrahedraInfo, 场四面体和源四面体</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIESWGTetra.jl#L242-L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnTetrasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnTetrasPWC-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnTetrasPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC 基函数 计算四面体上相关的9个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况，因此输入有两个四面体信息类型实例 输入： tetrat  tetras     :   TetrahedraInfo, 场四面体和四面体 计算： jk₀η₀∫ₜ∫ₛ(I + 1/k²∇∇)G(R)dV′dV 注意为方便对称性快速填充矩阵元，没有加入 κ 项，因此后续填充时要注意加上。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEPWCTetra.jl#L2-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnTetrasSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.EFIEOnTetrasSWG-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{TetrahedraInfo{IT, FT, CT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.EFIEOnTetrasSWG</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算四面体上相关的 16 个阻抗矩阵元， 此函数方法用于计算场源四面体不重合且相隔较远的情况，因此输入有两个四面体信息类型实例 输入 tetrat, tetras     :   TetrahedraInfo, 场四面体和源四面体</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIESWGTetra.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}" href="#MoM_Kernels.EFIEOnTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.EFIEOnTris</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形不重合且相隔较远的情况，因此输入有两个个三角形信息类型实例 输入 trit， tris     :   TriangleInfo, 场三角形和源三角形</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIERWGTri.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.EFIEOnTris-Union{Tuple{TriangleInfo{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}" href="#MoM_Kernels.EFIEOnTris-Union{Tuple{TriangleInfo{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.EFIEOnTris</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形重合的情况，因此输入只有一个三角形信息类型实例 输入 tri     :   TriangleInfo</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIERWGTri.jl#L151-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.MFIEOnNearTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}" href="#MoM_Kernels.MFIEOnNearTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.MFIEOnNearTris</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形不重合但相隔较近的情况，因此输入有两个个三角形信息类型实例 输入 trit， tris     :   TriangleInfo, 场三角形和源三角形</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/MFIE/MFIERWGTri.jl#L103-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.MFIEOnTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}" href="#MoM_Kernels.MFIEOnTris-Union{Tuple{FT}, Tuple{IT}, Tuple{TriangleInfo{IT, FT}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.MFIEOnTris</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形不重合且相隔较远的情况，因此输入有两个个三角形信息类型实例 输入 trit， tris     :   TriangleInfo, 场三角形和源三角形</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/MFIE/MFIERWGTri.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.MFIEOnTris-Union{Tuple{TriangleInfo{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}" href="#MoM_Kernels.MFIEOnTris-Union{Tuple{TriangleInfo{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT&lt;:Integer, FT&lt;:AbstractFloat}"><code>MoM_Kernels.MFIEOnTris</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形上相关9个阻抗矩阵元， 此函数方法用于计算场源三角形重合的情况，因此输入只有一个三角形信息类型实例 输入 tri     :   TriangleInfo</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/MFIE/MFIERWGTri.jl#L199-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.RCSPlot-Union{Tuple{FT}, Tuple{Any, Any, Matrix{FT}, Matrix{FT}}} where FT&lt;:Real" href="#MoM_Kernels.RCSPlot-Union{Tuple{FT}, Tuple{Any, Any, Matrix{FT}, Matrix{FT}}} where FT&lt;:Real"><code>MoM_Kernels.RCSPlot</code></a> — <span class="docstring-category">Method</span></header><section><div><p>RCS 绘图</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/PostProcess/RCS.jl#L185-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.ZnearChunkMulIVec!-Tuple{Any, Any, Any}" href="#MoM_Kernels.ZnearChunkMulIVec!-Tuple{Any, Any, Any}"><code>MoM_Kernels.ZnearChunkMulIVec!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ZnearChunkMulIVec!(ZnearChunk, resultChunk, IVec)</code></pre><p>计算某一块的矩阵向量乘积</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/Znear.jl#L181-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.adjoint_agg2HighLevel!-Tuple{Any, Any}" href="#MoM_Kernels.adjoint_agg2HighLevel!-Tuple{Any, Any}"><code>MoM_Kernels.adjoint_agg2HighLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>从子层聚合到本层 tLevel :: 本层 kLevel :: 子层</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/AdjointIterateOnOctree.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.adjoint_agg2Level2!-Tuple{Any, Any}" href="#MoM_Kernels.adjoint_agg2Level2!-Tuple{Any, Any}"><code>MoM_Kernels.adjoint_agg2Level2!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>从叶层聚合到第 &#39;2&#39; 层</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/AdjointIterateOnOctree.jl#L126-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.adjoint_aggOnBF!-Union{Tuple{T}, Tuple{Any, Any, AbstractArray{T}}} where T&lt;:Number" href="#MoM_Kernels.adjoint_aggOnBF!-Union{Tuple{T}, Tuple{Any, Any, AbstractArray{T}}} where T&lt;:Number"><code>MoM_Kernels.adjoint_aggOnBF!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在叶层从基函数向盒子聚合</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/AdjointIterateOnOctree.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.adjoint_disagg2KidLevel!-Tuple{Any, Any}" href="#MoM_Kernels.adjoint_disagg2KidLevel!-Tuple{Any, Any}"><code>MoM_Kernels.adjoint_disagg2KidLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>向低层解聚 tLevel :: 本层 kLevel :: 子层</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/AdjointIterateOnOctree.jl#L209-L213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.adjoint_disagg2LeafLevel!-Tuple{Any, Any}" href="#MoM_Kernels.adjoint_disagg2LeafLevel!-Tuple{Any, Any}"><code>MoM_Kernels.adjoint_disagg2LeafLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>解聚到叶层</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/AdjointIterateOnOctree.jl#L296-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.adjoint_disaggOnBF!-Tuple{Any, Any, Any}" href="#MoM_Kernels.adjoint_disaggOnBF!-Tuple{Any, Any, Any}"><code>MoM_Kernels.adjoint_disaggOnBF!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在叶层往测试基函数解聚</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/AdjointIterateOnOctree.jl#L313-L315">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.adjoint_transOnLevel!-Tuple{Any}" href="#MoM_Kernels.adjoint_transOnLevel!-Tuple{Any}"><code>MoM_Kernels.adjoint_transOnLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>层内转移</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/AdjointIterateOnOctree.jl#L141-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.adjoint_transOnLevels!-Tuple{Any, Any}" href="#MoM_Kernels.adjoint_transOnLevels!-Tuple{Any, Any}"><code>MoM_Kernels.adjoint_transOnLevels!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>各层内转移</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/AdjointIterateOnOctree.jl#L196-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.agg2HighLevel!-Tuple{Any, Any}" href="#MoM_Kernels.agg2HighLevel!-Tuple{Any, Any}"><code>MoM_Kernels.agg2HighLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>从子层聚合到本层 tLevel :: 本层 kLevel :: 子层</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/IterateOnOctree.jl#L129-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.agg2HighLevel!-Union{Tuple{IPT}, Tuple{FT}, Tuple{IT}, Tuple{Any, MoM_Kernels.LevelInfo{IT, FT, IPT}}} where {IT, FT, IPT&lt;:MoM_Kernels.LagrangeInterpInfo}" href="#MoM_Kernels.agg2HighLevel!-Union{Tuple{IPT}, Tuple{FT}, Tuple{IT}, Tuple{Any, MoM_Kernels.LevelInfo{IT, FT, IPT}}} where {IT, FT, IPT&lt;:MoM_Kernels.LagrangeInterpInfo}"><code>MoM_Kernels.agg2HighLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>从子层聚合到本层 tLevel :: 本层 kLevel :: 子层</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/IterateOnOctree.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.agg2Level2!-Tuple{Any, Any}" href="#MoM_Kernels.agg2Level2!-Tuple{Any, Any}"><code>MoM_Kernels.agg2Level2!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>从叶层聚合到第 &#39;2&#39; 层</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/IterateOnOctree.jl#L209-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.aggOnBF!-Union{Tuple{T}, Tuple{Any, Any, AbstractArray{T}}} where T&lt;:Number" href="#MoM_Kernels.aggOnBF!-Union{Tuple{T}, Tuple{Any, Any, AbstractArray{T}}} where T&lt;:Number"><code>MoM_Kernels.aggOnBF!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在叶层从基函数向盒子聚合</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/IterateOnOctree.jl#L2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:PWC}" href="#MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:PWC}"><code>MoM_Kernels.aggSBFOnLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aggSBFOnLevel!(aggSBF, disaggSBF, level, hexasInfo::AbstractVector{HexahedraInfo{IT, FT, CT}}, 
::Type{BFT}; setzero = true) where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:PWC}</code></pre><p>计算某层采用 EFIE 时在六面体上的 PWC 基函数的辐射函数 <code>aggSBF</code> 、配置函数 <code>disaggSBF</code>。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/AggOnBF/AggEFIE.jl#L398-L403">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:PWC}" href="#MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:PWC}"><code>MoM_Kernels.aggSBFOnLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aggSBFOnLevel!(aggSBF, disaggSBF, level, tetrasInfo::AbstractVector{TetrahedraInfo{IT, FT, CT}}, 
::Type{BFT}; setzero = true) where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:PWC}</code></pre><p>计算某层采用 EFIE 时在四面体上的 PWC 基函数的辐射函数 <code>aggSBF</code> 、配置函数 <code>disaggSBF</code>。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/AggOnBF/AggEFIE.jl#L289-L294">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:SWG}" href="#MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:SWG}"><code>MoM_Kernels.aggSBFOnLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aggSBFOnLevel!(aggSBF, disaggSBF, level, tetrasInfo::AbstractVector{TetrahedraInfo{IT, FT, CT}}, 
::Type{BFT}; setzero = true) where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:SWG}</code></pre><p>计算某层采用 EFIE 时 SWG 基函数的辐射函数 <code>aggSBF</code> 、配置函数 <code>disaggSBF</code>。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/AggOnBF/AggEFIE.jl#L173-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{VT}, Tuple{Any, Any, Any, AbstractVector{VT}, Type{BFT}}} where {VT&lt;:HexahedraInfo, BFT&lt;:RBF}" href="#MoM_Kernels.aggSBFOnLevel!-Union{Tuple{BFT}, Tuple{VT}, Tuple{Any, Any, Any, AbstractVector{VT}, Type{BFT}}} where {VT&lt;:HexahedraInfo, BFT&lt;:RBF}"><code>MoM_Kernels.aggSBFOnLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aggSBFOnLevel!(aggSBF, disaggSBF, level, hexasInfo::AbstractVector{VT}, 
::Type{BFT}; setzero = true) where {VT&lt;:HexahedraInfo, BFT&lt;:RBF}</code></pre><p>计算某层采用 EFIE 时在六面体上的 RBF 基函数的辐射函数 <code>aggSBF</code> 、配置函数 <code>disaggSBF</code>。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/AggOnBF/AggEFIE.jl#L500-L505">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.aggSBFOnLevel-Union{Tuple{BFT}, Tuple{VT}, Tuple{LT}, Tuple{LT, AbstractVector{VT}, AbstractVector{BFT}}} where {LT&lt;:MoM_Kernels.LevelInfo, VT&lt;:VolumeCellType, BFT&lt;:BasisFunctionType}" href="#MoM_Kernels.aggSBFOnLevel-Union{Tuple{BFT}, Tuple{VT}, Tuple{LT}, Tuple{LT, AbstractVector{VT}, AbstractVector{BFT}}} where {LT&lt;:MoM_Kernels.LevelInfo, VT&lt;:VolumeCellType, BFT&lt;:BasisFunctionType}"><code>MoM_Kernels.aggSBFOnLevel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aggSBFOnLevel(level::LT, geosInfo::AbstractVector{VT}, 
bfsInfo::AbstractVector{BFT}) where {LT&lt;:LevelInfo, VT&lt;:VolumeCellType, BFT&lt;:BasisFunctionType}</code></pre><p>计算某层采用 EFIE 时 SWG 基函数的辐射函数 <code>aggSBF</code> 、配置函数 <code>disaggSBF</code>。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/AggOnBF/AggEFIE.jl#L146-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.aggSBFOnLevelCFIE!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}" href="#MoM_Kernels.aggSBFOnLevelCFIE!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}"><code>MoM_Kernels.aggSBFOnLevelCFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aggSBFOnLevelCFIE!(aggSBF, disaggSBF, level, trianglesInfo::Vector{TriangleInfo{IT, FT}}, 
::Type{BFT}; setzero = true) where {IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}</code></pre><p>计算某层采用 CFIE 时 RWG 基函数的辐射函数 <code>aggSBF</code> 、配置函数 <code>disaggSBF</code>。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/AggOnBF/AggCFIE.jl#L30-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.aggSBFOnLevelCFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Any}} where {IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.aggSBFOnLevelCFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Any}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.aggSBFOnLevelCFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aggSBFOnLevelCFIE(level, trianglesInfo::Vector{TriangleInfo{IT, FT}}, 
bfsInfo) where {IT&lt;:Integer, FT&lt;:Real}</code></pre><p>计算某层采用 CFIE 时 RWG 基函数的辐射函数 <code>aggSBF</code> 、配置函数 <code>disaggSBF</code> ,  输入为层信息 <code>level</code> 、三角形信息 <code>trianglesInfo</code> 和基函数信息 <code>bfsInfo</code>。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/AggOnBF/AggCFIE.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.aggSBFOnLevelEFIE!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}" href="#MoM_Kernels.aggSBFOnLevelEFIE!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}"><code>MoM_Kernels.aggSBFOnLevelEFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aggSBFOnLevelEFIE!(aggSBF, disaggSBF, level, trianglesInfo::Vector{TriangleInfo{IT, FT}}, 
::Type{BFT}; setzero = true) where {IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}</code></pre><p>计算某层采用 EFIE 时 RWG 基函数的辐射函数 <code>aggSBF</code> 、配置函数 <code>disaggSBF</code>。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/AggOnBF/AggEFIE.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.aggSBFOnLevelEFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Any}} where {IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.aggSBFOnLevelEFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Any}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.aggSBFOnLevelEFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aggSBFOnLevelEFIE(level, trianglesInfo::Vector{TriangleInfo{IT, FT}}, 
bfsInfo) where {IT&lt;:Integer, FT&lt;:Real}</code></pre><p>计算某层采用 EFIE 时 RWG 基函数的辐射函数 <code>aggSBF</code> 、配置函数 <code>disaggSBF</code> ,  输入为层信息 <code>level</code> 、三角形信息 <code>trianglesInfo</code> 和基函数信息 <code>bfsInfo</code>。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/AggOnBF/AggEFIE.jl#L18-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.aggSBFOnLevelMFIE!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}" href="#MoM_Kernels.aggSBFOnLevelMFIE!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Any, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}"><code>MoM_Kernels.aggSBFOnLevelMFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aggSBFOnLevelMFIE!(aggSBF, disaggSBF, level, trianglesInfo::Vector{TriangleInfo{IT, FT}}, 
::Type{BFT}; setzero = true) where {IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}</code></pre><p>计算某层采用 MFIE 时在三角形上的 RWG 基函数的辐射函数 <code>aggSBF</code> 、配置函数 <code>disaggSBF</code>。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/AggOnBF/AggMFIE.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.aggSBFOnLevelMFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Array{RWG{IT, FT}, 1}}} where {IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.aggSBFOnLevelMFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Array{RWG{IT, FT}, 1}}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.aggSBFOnLevelMFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aggSBFOnLevelMFIE(level, trianglesInfo::Vector{TriangleInfo{IT, FT}}, 
bfsInfo::Vector{RWG{IT, FT}}) where {IT&lt;:Integer, FT&lt;:Real}</code></pre><p>计算某层采用 MFIE 时在三角形上的 RWG 基函数的辐射函数 <code>aggSBF</code> 、配置函数 <code>disaggSBF</code>。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/AggOnBF/AggMFIE.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.anterpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}" href="#MoM_Kernels.anterpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.anterpolate!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>拉格朗日单步反插值</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LagrangeInterpolation.jl#L244-L246">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.anterpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}" href="#MoM_Kernels.anterpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.anterpolate!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>拉格朗日分步反插值</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LagrangeInterpolation.jl#L182-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.anterpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}" href="#MoM_Kernels.anterpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.anterpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>拉格朗日单步反插值</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LagrangeInterpolation.jl#L228-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.anterpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}" href="#MoM_Kernels.anterpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.anterpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>拉格朗日分步反插值</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LagrangeInterpolation.jl#L167-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.calZfarI!-Union{Tuple{MT}, Tuple{T}, Tuple{ZT}, Tuple{MLFMAIterator{ZT, MT}, AbstractArray{T}}} where {ZT, T&lt;:Number, MT&lt;:(Vector)}" href="#MoM_Kernels.calZfarI!-Union{Tuple{MT}, Tuple{T}, Tuple{ZT}, Tuple{MLFMAIterator{ZT, MT}, AbstractArray{T}}} where {ZT, T&lt;:Number, MT&lt;:(Vector)}"><code>MoM_Kernels.calZfarI!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算远区矩阵向量乘积</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/IterateOnOctree.jl#L531-L533">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.calZnearCSC!-Union{Tuple{VSCellT}, Tuple{BFT}, Tuple{Any, AbstractVector{VSCellT}, Any}, Tuple{Any, AbstractVector{VSCellT}, Any, Type{BFT}}} where {BFT&lt;:BasisFunctionType, VSCellT&lt;:SurfaceCellType}" href="#MoM_Kernels.calZnearCSC!-Union{Tuple{VSCellT}, Tuple{BFT}, Tuple{Any, AbstractVector{VSCellT}, Any}, Tuple{Any, AbstractVector{VSCellT}, Any, Type{BFT}}} where {BFT&lt;:BasisFunctionType, VSCellT&lt;:SurfaceCellType}"><code>MoM_Kernels.calZnearCSC!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calZnearCSC!(level, geosInfo::AbstractVector{VSCellT}, 
    Znear, bfT::Type{BFT} = VSBFTypes.sbfType) where {BFT&lt;:BasisFunctionType, VSCellT&lt;:SurfaceCellType}
calZnearCSC!(level, geosInfo::AbstractVector{VSCellT}, 
    Znear, bfT::Type{BFT} = VSBFTypes.vbfType) where {BFT&lt;:BasisFunctionType, VSCellT&lt;:VolumeCellType}
calZnearCSC!(level, geosInfo::AbstractVector{VT}, 
    Znear) where {VT&lt;:AbstractVector}</code></pre><p>根据八叉树层信息 <code>level</code> 和几何信息 <code>geosInfo</code> 、基函数信息 <code>bfsInfo</code> 计算近场阻抗矩阵。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/Znear.jl#L222-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.calZnearCSC-Tuple{Any, Vector, Vector}" href="#MoM_Kernels.calZnearCSC-Tuple{Any, Vector, Vector}"><code>MoM_Kernels.calZnearCSC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calZnearCSC(level, geosInfo::Vector, bfsInfo::Vector)</code></pre><p>根据八叉树层信息 <code>level</code> 和几何信息 <code>geosInfo</code> 、基函数信息 <code>bfsInfo</code> 计算近场阻抗矩阵。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/Znear.jl#L194-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.calZnearCSCCFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RWG}" href="#MoM_Kernels.calZnearCSCCFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RWG}"><code>MoM_Kernels.calZnearCSCCFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calZnearCSCCFIE!(level, trianglesInfo::Vector{TriangleInfo{IT, FT}},
    Znear::ZnearT{CT}, ::Type{BFT}) where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RWG}</code></pre><p>采用 RWG 基函数计算 CFIE 面积分（SIE）阻抗矩阵近场元并将结果放在 ZnearCSC 稀疏矩阵中。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/ZnearCFIE.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:ConstBasisFunction}" href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:ConstBasisFunction}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC 基函数计算六面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/ZnearEFIE.jl#L856-L858">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}" href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 RBF 基函数计算六面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/ZnearEFIE.jl#L694-L696">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:ConstBasisFunction}" href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:ConstBasisFunction}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC 基函数计算四面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/ZnearEFIE.jl#L385-L387">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}" href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 SWG 基函数计算网格元 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/ZnearEFIE.jl#L174-L176">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RBF}" href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RBF}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 RWG + RBF 基函数计算六面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/ZnearEFIEVSIE.jl#L151-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:SWG}" href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:SWG}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 RWG + SWG 基函数计算 三角形 + 四面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/ZnearEFIEVSIE.jl#L2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}" href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 RWG 基函数计算 EFIE 面积分（SIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/ZnearEFIE.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{VT2}, Tuple{VT1}, Tuple{CT}, Tuple{FT}, Tuple{Any, AbstractVector{VT1}, AbstractVector{VT2}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, AbstractVector{VT1}, AbstractVector{VT2}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {FT&lt;:Real, CT&lt;:Complex{FT}, VT1&lt;:TetrahedraInfo, VT2&lt;:HexahedraInfo, BFT&lt;:PWC}" href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{VT2}, Tuple{VT1}, Tuple{CT}, Tuple{FT}, Tuple{Any, AbstractVector{VT1}, AbstractVector{VT2}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, AbstractVector{VT1}, AbstractVector{VT2}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {FT&lt;:Real, CT&lt;:Complex{FT}, VT1&lt;:TetrahedraInfo, VT2&lt;:HexahedraInfo, BFT&lt;:PWC}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 PWC + PWC 基函数计算 四面体 + 六面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/ZnearEFIE.jl#L1006-L1008">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{VT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractVector{VT}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractVector{VT}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, VT&lt;:VolumeCellType, BFT&lt;:PWC}" href="#MoM_Kernels.calZnearCSCEFIE!-Union{Tuple{BFT}, Tuple{VT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractVector{VT}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, AbstractVector{VT}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}, Any}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, VT&lt;:VolumeCellType, BFT&lt;:PWC}"><code>MoM_Kernels.calZnearCSCEFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 RWG + PWC 基函数计算 三角形 + 四面体/六面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/ZnearEFIEVSIE.jl#L295-L297">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.calZnearCSCEFIEnew!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}" href="#MoM_Kernels.calZnearCSCEFIEnew!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}"><code>MoM_Kernels.calZnearCSCEFIEnew!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 RBF 基函数计算六面体 EFIE 的体积分（VIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/ZnearEFIE.jl#L534-L536">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.calZnearCSCMFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RWG}" href="#MoM_Kernels.calZnearCSCMFIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Array{TriangleInfo{IT, FT}, 1}, Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RWG}"><code>MoM_Kernels.calZnearCSCMFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用 RWG 基函数计算 MFIE 面积分（SIE）阻抗矩阵近场元并将结果放在ZnearCSC稀疏矩阵中</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/ZnearMFIE.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.caladjZfarI!-Union{Tuple{MT}, Tuple{T}, Tuple{ZT}, Tuple{LinearAlgebra.Adjoint{ZT, MLFMAIterator{ZT, MT}}, AbstractArray{T}}} where {ZT, T&lt;:Number, MT&lt;:(Vector)}" href="#MoM_Kernels.caladjZfarI!-Union{Tuple{MT}, Tuple{T}, Tuple{ZT}, Tuple{LinearAlgebra.Adjoint{ZT, MLFMAIterator{ZT, MT}}, AbstractArray{T}}} where {ZT, T&lt;:Number, MT&lt;:(Vector)}"><code>MoM_Kernels.caladjZfarI!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算远区矩阵的伴随矩阵向量乘积</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/AdjointIterateOnOctree.jl#L358-L360">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.calαTransOnLevel!-NTuple{4, Any}" href="#MoM_Kernels.calαTransOnLevel!-NTuple{4, Any}"><code>MoM_Kernels.calαTransOnLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算 level 层的转移因子， 转移因子只存在于远亲组，每层远亲组最多有 7^3 - 3^3 = 316种结果</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/PhaseShiftAndTransFactors.jl#L156-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.coeffgreen-Tuple{Integer}" href="#MoM_Kernels.coeffgreen-Tuple{Integer}"><code>MoM_Kernels.coeffgreen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coeffgreen(n::Integer)</code></pre><p>归一化格林函数 (不包括<span>$\frac{1}{4π}$</span>项) 的展开系数函数，从 0 阶 到 n 阶：</p><p class="math-container">\[\begin{aligned}
g(R)    &amp;= \frac{e^{-jkR}}{R} = \sum_{n=0}^{SglrOrder}coeffgreen(n)R^{n-1}\\
coeffgreen(n)  &amp;=   \frac{{-jk}^{n}}{n!}\\
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/Singularity.jl#L36-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.convergencePlot-Union{Tuple{Vector{FT}}, Tuple{FT}} where FT&lt;:Real" href="#MoM_Kernels.convergencePlot-Union{Tuple{Vector{FT}}, Tuple{FT}} where FT&lt;:Real"><code>MoM_Kernels.convergencePlot</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算完成后绘制收敛曲线</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Solvers.jl#L141-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.cooraInCoorb-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T&lt;:Number" href="#MoM_Kernels.cooraInCoorb-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T&lt;:Number"><code>MoM_Kernels.cooraInCoorb</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算一维坐标coora在坐标corrb中的位置</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LagrangeInterpolation.jl#L481-L483">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.disagg2KidLevel!-Tuple{Any, Any}" href="#MoM_Kernels.disagg2KidLevel!-Tuple{Any, Any}"><code>MoM_Kernels.disagg2KidLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>向低层解聚 tLevel :: 本层 kLevel :: 子层</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/IterateOnOctree.jl#L379-L383">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.disagg2KidLevel!-Union{Tuple{IPT}, Tuple{FT}, Tuple{IT}, Tuple{Any, MoM_Kernels.LevelInfo{IT, FT, IPT}}} where {IT, FT, IPT&lt;:MoM_Kernels.LagrangeInterpInfo}" href="#MoM_Kernels.disagg2KidLevel!-Union{Tuple{IPT}, Tuple{FT}, Tuple{IT}, Tuple{Any, MoM_Kernels.LevelInfo{IT, FT, IPT}}} where {IT, FT, IPT&lt;:MoM_Kernels.LagrangeInterpInfo}"><code>MoM_Kernels.disagg2KidLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>向低层解聚 tLevel :: 本层 kLevel :: 子层</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/IterateOnOctree.jl#L292-L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.disagg2LeafLevel!-Tuple{Any, Any}" href="#MoM_Kernels.disagg2LeafLevel!-Tuple{Any, Any}"><code>MoM_Kernels.disagg2LeafLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>解聚到叶层</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/IterateOnOctree.jl#L469-L471">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.disaggOnBF!-Tuple{Any, Any, Any}" href="#MoM_Kernels.disaggOnBF!-Tuple{Any, Any, Any}"><code>MoM_Kernels.disaggOnBF!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在叶层往测试基函数解聚</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/IterateOnOctree.jl#L486-L488">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.electricJCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{StaticArraysCore.StaticArray{Tuple{3}, FT, 1}, StaticArraysCore.StaticArray{Tuple{3}, CT, 1}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}" href="#MoM_Kernels.electricJCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{StaticArraysCore.StaticArray{Tuple{3}, FT, 1}, StaticArraysCore.StaticArray{Tuple{3}, CT, 1}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.electricJCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算给定三角形面片位置 r 处的电流 电流基函数公式为：Jₙ = Iₙfₙ 同一个三角形面片上存在三个基函数，因此 Jₜ = ∑ₜₙ₌₁³ Iₜₙfₜₙ 输入： r               ::Vec3D{FT} ICoeff          ::Vec3D{CT}  三角形上的三个基函数的计算得到的电流系数 triangleInfo    ::TriangleInfo{IT, FT}，三角形信息 输出值: Jtrir           ::Complex{FT}, 三角形上加权后的电流</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/PostProcess/CurrentOnGeos.jl#L264-L275">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.electricJCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}" href="#MoM_Kernels.electricJCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.electricJCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算所有三角形上的高斯求积点电流权重乘积 JₙᵢWᵢ 电流基函数公式为：Jₙ = Iₙfₙ 同一个三角形面片上存在三个基函数，因此 JₙᵢWᵢ = ∑ₜₙ₌₁³ Iₜₙlₜₙ/2Sₜₙ 输入： ICoeff          ::Vector{Complex{FT}}  计算得到的电流系数 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，三角形信息 输出值: Jtri         ::Marrix{Complex{FT}}, 三角形上加权后的电流</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/PostProcess/CurrentOnGeos.jl#L292-L302">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.excitationVectorCFIE!-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.excitationVectorCFIE!-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.excitationVectorCFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在 RWG 基函数上的激励向量 输入： source          ::ST, 波源 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，保存三角形信息的向量 nbf             ::Integer，基函数数目</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/CFIE/CFIEExcitedVectors.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.excitationVectorCFIE-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TriangleInfo{IT, FT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}" href="#MoM_Kernels.excitationVectorCFIE-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TriangleInfo{IT, FT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}"><code>MoM_Kernels.excitationVectorCFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在给定三角形的三个 半RWG 基函数上的激励向量 输入： source  ::ST, 波源 tri     ::TriangleInfo{IT, FT}，三角形信息</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/CFIE/CFIEExcitedVectors.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.excitationVectorCFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, Array{TriangleInfo{IT, FT}, 1}, Integer}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.excitationVectorCFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, Array{TriangleInfo{IT, FT}, 1}, Integer}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.excitationVectorCFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在 RWG 基函数上的激励向量 输入： source          ::ST, 波源 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，保存三角形信息的向量 nbf             ::Integer，基函数数目</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/CFIE/CFIEExcitedVectors.jl#L34-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.excitationVectorEFIE!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}" href="#MoM_Kernels.excitationVectorEFIE!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.excitationVectorEFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在 基函数 上的激励向量 输入： source          ::ST, 平面波源 tetrasInfo      ::Vector{TetrahedraInfo{IT, FT, CT}}，保存四面体信息的向量 nbf             ::Integer，基函数数量  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEExcitedVectors.jl#L115-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.excitationVectorEFIE!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Vector{CT}, ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}}, Tuple{Vector{CT}, ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}" href="#MoM_Kernels.excitationVectorEFIE!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Vector{CT}, ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}}, Tuple{Vector{CT}, ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.excitationVectorEFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在 基函数 上的激励向量 输入： source          ::ST, 平面波源 hexasInfo       ::Vector{HexahedraInfo{IT, FT, CT}}，保存六面体信息的向量 nbf             ::Integer，基函数数量  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEExcitedVectors.jl#L222-L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.excitationVectorEFIE!-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.excitationVectorEFIE!-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.excitationVectorEFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在 RWG 基函数上的激励向量 输入： source          ::ST, 波源 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，保存三角形信息的向量 nbf             ::Integer，基函数数目</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEExcitedVectors.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.excitationVectorEFIE!-Union{Tuple{VT}, Tuple{ST}, Tuple{AbstractVector, ST, Vector{VT}}} where {ST&lt;:ExcitingSources, VT&lt;:(AbstractVector)}" href="#MoM_Kernels.excitationVectorEFIE!-Union{Tuple{VT}, Tuple{ST}, Tuple{AbstractVector, ST, Vector{VT}}} where {ST&lt;:ExcitingSources, VT&lt;:(AbstractVector)}"><code>MoM_Kernels.excitationVectorEFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在 基函数 上的激励向量 输入： source          ::ST, 平面波源 tetrasInfo      ::Vector{TetrahedraInfo{IT, FT, CT}}，保存六面体信息的向量 nbf             ::Integer，基函数数量  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEExcitedVectors.jl#L337-L343">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, HexahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:ConstBasisFunction}" href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, HexahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:ConstBasisFunction}"><code>MoM_Kernels.excitationVectorEFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在给定四面体的三个 PWC 基函数上的激励向量 输入： source      ::ST, 波源 hexa        ::HexahedraInfo{IT, FT, CT}，六面体信息</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEExcitedVectors.jl#L290-L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, HexahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}" href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, HexahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}"><code>MoM_Kernels.excitationVectorEFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在给定六面体的六个 半SWG 基函数上的激励向量 输入： source      ::ST, 波源 hexa        ::HexahedraInfo{IT, FT, CT}，六面体信息</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEExcitedVectors.jl#L252-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TetrahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:ConstBasisFunction}" href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TetrahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:ConstBasisFunction}"><code>MoM_Kernels.excitationVectorEFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在给定四面体的三个 PWC 基函数上的激励向量 输入： source      ::ST, 波源 tetra       ::TetrahedraInfo{IT, FT, CT}，四面体信息</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEExcitedVectors.jl#L177-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TetrahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}" href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TetrahedraInfo{IT, FT, CT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:LinearBasisFunction}"><code>MoM_Kernels.excitationVectorEFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在给定四面体的四个 半SWG 基函数上的激励向量 输入： source      ::ST, 波源 tetra       ::TetrahedraInfo{IT, FT, CT}，四面体信息</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEExcitedVectors.jl#L144-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TriangleInfo{IT, FT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}" href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TriangleInfo{IT, FT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}"><code>MoM_Kernels.excitationVectorEFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在给定三角形的三个 半RWG 基函数上的激励向量 输入： source  ::ST, 波源 tri     ::TriangleInfo{IT, FT}，三角形信息</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEExcitedVectors.jl#L55-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.excitationVectorEFIE-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer}, Tuple{ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}" href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer}, Tuple{ST, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.excitationVectorEFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在 基函数 上的激励向量 输入： source          ::ST, 平面波源 hexasInfo      ::Vector{HexahedraInfo{IT, FT, CT}}，保存六面体信息的向量 nbf             ::Integer，基函数数量  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEExcitedVectors.jl#L203-L209">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.excitationVectorEFIE-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer}, Tuple{ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}" href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer}, Tuple{ST, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.excitationVectorEFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在 基函数 上的激励向量 输入： source          ::ST, 平面波源 tetrasInfo      ::Vector{TetrahedraInfo{IT, FT, CT}}，保存四面体信息的向量 nbf             ::Integer，基函数数量  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEExcitedVectors.jl#L97-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.excitationVectorEFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, Array{TriangleInfo{IT, FT}, 1}, Integer}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, Array{TriangleInfo{IT, FT}, 1}, Integer}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.excitationVectorEFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在 RWG 基函数上的激励向量 输入： source          ::ST, 波源 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，保存三角形信息的向量 nbf             ::Integer，基函数数目</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEExcitedVectors.jl#L34-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.excitationVectorEFIE-Union{Tuple{VT}, Tuple{ST}, Tuple{ST, Vector{VT}, Integer}} where {ST&lt;:ExcitingSources, VT&lt;:(AbstractVector)}" href="#MoM_Kernels.excitationVectorEFIE-Union{Tuple{VT}, Tuple{ST}, Tuple{ST, Vector{VT}, Integer}} where {ST&lt;:ExcitingSources, VT&lt;:(AbstractVector)}"><code>MoM_Kernels.excitationVectorEFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在 基函数 上的激励向量 输入： source          ::ST, 平面波源 tetrasInfo      ::Vector{TetrahedraInfo{IT, FT, CT}}，保存六面体信息的向量 nbf             ::Integer，基函数数量  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEExcitedVectors.jl#L316-L322">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.excitationVectorMFIE!-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.excitationVectorMFIE!-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}}, Tuple{Array{Complex{FT}, 1}, ST, Array{TriangleInfo{IT, FT}, 1}, Any}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.excitationVectorMFIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在 RWG 基函数上的激励向量 输入： source          ::ST, 波源 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，保存三角形信息的向量 nbf             ::Integer，基函数数目</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/MFIE/MFIEExcitedVectors.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.excitationVectorMFIE-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TriangleInfo{IT, FT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}" href="#MoM_Kernels.excitationVectorMFIE-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, TriangleInfo{IT, FT}, Type{BFT}}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real, BFT&lt;:RWG}"><code>MoM_Kernels.excitationVectorMFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在给定三角形的三个 半RWG 基函数上的激励向量 输入： source  ::ST, 波源 tri     ::TriangleInfo{IT, FT}，三角形信息</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/MFIE/MFIEExcitedVectors.jl#L55-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.excitationVectorMFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, Array{TriangleInfo{IT, FT}, 1}, Integer}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.excitationVectorMFIE-Union{Tuple{FT}, Tuple{IT}, Tuple{ST}, Tuple{ST, Array{TriangleInfo{IT, FT}, 1}, Integer}} where {ST&lt;:ExcitingSources, IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.excitationVectorMFIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算平面波在 RWG 基函数上的激励向量 输入： source          ::ST, 波源 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，保存三角形信息的向量 nbf             ::Integer，基函数数目</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/MFIE/MFIEExcitedVectors.jl#L34-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.faceSingularityIg-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, TriangleInfo{IT, FT}, FT, AbstractVector{FT}}} where {IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.faceSingularityIg-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, TriangleInfo{IT, FT}, FT, AbstractVector{FT}}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.faceSingularityIg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">faceSingularityIg(rgt::AbstractVector{FT}, tris::TriangleInfo{IT, FT}, area::FT, facen̂::AbstractVector{FT}) where {IT&lt;:Integer, FT&lt;:Real}</code></pre><p>计算场点<code>rgt</code>在源三角形<code>tris</code>上的奇异性，<code>tris</code>的面积为<code>area</code>，外法向量为<code>facen̂</code>。 计算结果为：</p><p class="math-container">\[\begin{aligned}
I_{gS}  &amp;= \int{g(R)dS&#39;}\\
        &amp;= \sum_{n=0}^{SglrOrder}{coeffgreen(n)I^{n-1}_{RS}}\\
I^{n}_{RS}  &amp;= \int{R^{n}dS&#39;}
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/Singularity/FaceSingularity.jl#L66-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.faceSingularityIg-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, Tris4Tetra{IT, FT}, FT, AbstractVector{FT}}} where {IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.faceSingularityIg-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, Tris4Tetra{IT, FT}, FT, AbstractVector{FT}}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.faceSingularityIg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">faceSingularityIg(rgt::AbstractVector{FT}, tris::Tris4Tetra{IT, FT}, area::FT, facen̂::AbstractVector{FT}) where {IT&lt;:Integer, FT&lt;:Real}</code></pre><p>计算场点<code>rgt</code>在源三角形<code>tris</code>（该三角形为组成四面体的某一面）上的奇异性，<code>tris</code>的面积为<code>area</code>，外法向量为<code>facen̂</code>。 计算结果为：</p><p class="math-container">\[\begin{aligned}
I_{gS}  &amp;= \int{g(R)dS&#39;}\\
        &amp;= \sum_{n=0}^{SglrOrder}{coeffgreen(n)I^{n-1}_{RS}}\\
I^{n}_{RS}  &amp;= \int{R^{n}dS&#39;}
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/Singularity/FaceSingularity.jl#L191-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.faceSingularityIg-Union{Tuple{ST}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, ST, FT, AbstractVector{FT}}} where {IT&lt;:Integer, FT&lt;:Real, ST&lt;:SurfaceCellType{IT, FT}}" href="#MoM_Kernels.faceSingularityIg-Union{Tuple{ST}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, ST, FT, AbstractVector{FT}}} where {IT&lt;:Integer, FT&lt;:Real, ST&lt;:SurfaceCellType{IT, FT}}"><code>MoM_Kernels.faceSingularityIg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">faceSingularityIg(rgt::AbstractVector{FT}, polys::ST, area::FT, 
facen̂::AbstractVector{FT}) where {IT&lt;:Integer, FT&lt;:Real, ST&lt;:SurfaceCellType{IT, FT}}</code></pre><p>计算场点<code>rgt</code>在多边形<code>polys</code>上的奇异性，<code>polys</code>的面积为<code>area</code>，外法向量为<code>facen̂</code>。 计算结果为：</p><p class="math-container">\[\begin{aligned}
I_{gS}  &amp;= \int{g(R)dS&#39;}\\
        &amp;= \sum_{n=0}^{SglrOrder}{coeffgreen(n)I^{n-1}_{RS}}\\
I^{n}_{RS}  &amp;= \int{R^{n}dS&#39;}
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/Singularity/FaceSingularity.jl#L315-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.faceSingularityIgIvecg-Union{Tuple{ST}, Tuple{FT}, Tuple{AbstractVector{FT}, ST, Any, AbstractVector}} where {FT&lt;:Real, ST&lt;:SurfaceCellType}" href="#MoM_Kernels.faceSingularityIgIvecg-Union{Tuple{ST}, Tuple{FT}, Tuple{AbstractVector{FT}, ST, Any, AbstractVector}} where {FT&lt;:Real, ST&lt;:SurfaceCellType}"><code>MoM_Kernels.faceSingularityIgIvecg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">faceSingularityIgIvecg(rgt::AbstractVector{FT}, polys::ST, area, 
    facen̂::AbstractVector) where {FT&lt;:Real, ST&lt;:SurfaceCellType{IT, FT}}</code></pre><p>计算场点<code>rgt</code>在多边形<code>polys</code>上的奇异性，<code>polys</code>的面积为<code>area</code>，外法向量为<code>facen̂</code>。 计算结果为：</p><p class="math-container">\[\begin{aligned}
I_{gS}  &amp;= \int{g(R)dS&#39;}\\
        &amp;= \sum_{n=0}^{SglrOrder}{coeffgreen(n)I^{n-1}_{RS}}\\
\boldsymbol{I}_{gS}  &amp;= \int{\boldsymbol{R}g(R)dS&#39;}\\
        &amp;= \sum_{l_j}{\hat{\bm{u}}_j \sum_{n=0}^{SglrOrder}{\frac{coeffgreen(n)}{n+1}I^{n-1}_{lr}}} + d\bm{n}I^{n-1}_{gS}\\
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/Singularity/FaceSingularity.jl#L444-L458">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.faceSingularityIgIvecgI∇gS-Union{Tuple{ST}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, ST, FT, AbstractVector{FT}}} where {IT&lt;:Integer, FT&lt;:Real, ST&lt;:SurfaceCellType{IT, FT}}" href="#MoM_Kernels.faceSingularityIgIvecgI∇gS-Union{Tuple{ST}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, ST, FT, AbstractVector{FT}}} where {IT&lt;:Integer, FT&lt;:Real, ST&lt;:SurfaceCellType{IT, FT}}"><code>MoM_Kernels.faceSingularityIgIvecgI∇gS</code></a> — <span class="docstring-category">Method</span></header><section><div><p>面上的近奇异性 rgt, 为场三角形的求积点 tris::TriangleInfo{IT, FT}， 源三角形信息 计算得到结果:: IgS     =   ∫ g(R) dS&#39;      =   ∑ₙ₌₀(coeffgreen(n)<em>IR[n-1]) IvecgS  =   ∫ Rvec g(R) dS&#39; =   ∑ₗⱼ ûⱼ ∑ₙ₌₀(coeffgreen(n)/(n+1)</em>Ilᵣ[n-1]) + dn̂IgS I∇gS    =   ∫ ∇g(R) dS&#39;     =   ∑ₙ₌₀VSC₃ⁿ*(-1/(n+2)∑ₗⱼûⱼIlᵣ[n+2] + dn̂IgS )</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/deprecate.jl#L2-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.faceSingularityIᵣIᵨ-Union{Tuple{FT}, Tuple{IT}, Tuple{StaticArraysCore.MMatrix{3, 7, FT, 21}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.faceSingularityIᵣIᵨ-Union{Tuple{FT}, Tuple{IT}, Tuple{StaticArraysCore.MMatrix{3, 7, FT, 21}, TriangleInfo{IT, FT}}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.faceSingularityIᵣIᵨ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>面上的近奇异性 rgts::MMatrix{GQPNTriSglr, 3, Complex{FT}}, 为场三角形的所有高斯求积点 tris::TriangleInfo{IT, FT}， 源三角形信息 计算得到结果:: r0tProj2s::MMatrix{3, GQPNTriSglr, Complex{FT}, 3GQPNTriSglr}, 积分点在源三角形上的投影点 Iᵣ  =   ∫ 1/R dS&#39;   =   ∑₁³(p02il<em>fᵢ - dtsAbs</em>βᵢ) Iᵨ  =   ∫ ρ/R dS&#39;   =   0.5∑₁³{ûᵢ[(R0^2<em>fᵢ + li⁺</em>R⁺ - li⁻*R⁻)]}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/deprecate.jl#L157-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.farEPlot-Union{Tuple{FT}, Tuple{Any, Any, Matrix{FT}, Matrix{FT}}} where FT&lt;:Real" href="#MoM_Kernels.farEPlot-Union{Tuple{FT}, Tuple{Any, Any, Matrix{FT}, Matrix{FT}}} where FT&lt;:Real"><code>MoM_Kernels.farEPlot</code></a> — <span class="docstring-category">Method</span></header><section><div><p>farE 绘图</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/PostProcess/FarField.jl#L248-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.farField-Tuple{Any, Any, Any}" href="#MoM_Kernels.farField-Tuple{Any, Any, Any}"><code>MoM_Kernels.farField</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在球坐标为r̂θϕ处计算辐射积分，采用RWG基函数时，三角形上没有统一的电流值，每一点上都是三边电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙlₙρₙ/(2Sₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙlₙρₙ/2)exp(jkr̂(θ, ϕ)⋅rₙ) )</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/PostProcess/FarField.jl#L182-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.farField-Union{Tuple{BFT}, Tuple{CT}, Tuple{VT}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Any}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Any, Type{BFT}}} where {VT&lt;:VolumeCellType, CT&lt;:Complex, BFT&lt;:BasisFunctionType}" href="#MoM_Kernels.farField-Union{Tuple{BFT}, Tuple{CT}, Tuple{VT}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Any}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Any, Type{BFT}}} where {VT&lt;:VolumeCellType, CT&lt;:Complex, BFT&lt;:BasisFunctionType}"><code>MoM_Kernels.farField</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在球坐标为r̂θϕ处计算辐射积分，采用SWG基函数时，四面体上没有统一的电流值，每一点上都是四个SWG基函数电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙsₙρₙ/(3Vₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙsₙρₙ/3)exp(jkr̂(θ, ϕ)⋅rₙ) )</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/PostProcess/FarField.jl#L59-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.farField-Union{Tuple{BFT}, Tuple{ST}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{ST}, Any}, Tuple{Any, Any, Vector{CT}, Vector{ST}, Any, Type{BFT}}} where {CT&lt;:Complex, ST&lt;:TriangleInfo, BFT&lt;:RWG}" href="#MoM_Kernels.farField-Union{Tuple{BFT}, Tuple{ST}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{ST}, Any}, Tuple{Any, Any, Vector{CT}, Vector{ST}, Any, Type{BFT}}} where {CT&lt;:Complex, ST&lt;:TriangleInfo, BFT&lt;:RWG}"><code>MoM_Kernels.farField</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在球坐标为r̂θϕ处计算辐射积分，采用RWG基函数时，三角形上没有统一的电流值，每一点上都是三边电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙlₙρₙ/(2Sₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙlₙρₙ/2)exp(jkr̂(θ, ϕ)⋅rₙ) )</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/PostProcess/FarField.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.farField-Union{Tuple{VT}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Any}} where {CT&lt;:Complex, VT&lt;:(AbstractVector)}" href="#MoM_Kernels.farField-Union{Tuple{VT}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Any}} where {CT&lt;:Complex, VT&lt;:(AbstractVector)}"><code>MoM_Kernels.farField</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在球坐标为r̂θϕ处计算辐射积分，采用SWG基函数时，四面体上没有统一的电流值，每一点上都是四个SWG基函数电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙsₙρₙ/(3Vₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙsₙρₙ/3)exp(jkr̂(θ, ϕ)⋅rₙ) )</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/PostProcess/FarField.jl#L116-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.func4Cube1stkInterval-Tuple{MoM_Kernels.CubeInfo}" href="#MoM_Kernels.func4Cube1stkInterval-Tuple{MoM_Kernels.CubeInfo}"><code>MoM_Kernels.func4Cube1stkInterval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">func4Cube1stkInterval(cube::CubeInfo)
func4Cube1stkInterval(i::T) where T
func4Cube1stkInterval(interval::T) where T &lt;: UnitRange
func4CubelastkInterval(cube::CubeInfo)
func4CubelastkInterval(i::T) where T
func4CubelastkInterval(interval::T) where T</code></pre><p>这六个函数用于寻找盒子的子盒子区间内的比较函数，多重分派以实现不同数据类型的比较。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Extends/IOs.jl#L190-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:PWC}" href="#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:PWC}"><code>MoM_Kernels.geoElectricJCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算六面体上的电流。 分片常数基 PWC 基函数 电流基函数公式为：Jₙ = κₙIₙfₙ 同一个六面体面片上存在 x̂, ŷ, ẑ 方向的三个基函数，因此 Jₜ = κₜ ∑ₜₙ₌₁³Iₜₙfₜₙ 输入： ICoeff          ::Vector{Complex{FT}}  计算得到的电流系数 hexasInfo      ::Vector{HexahedraInfo{IT, FT, CT}},  输出值: Jhexa          ::Marrix{Complex{FT}}, 六面体上的电流</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/PostProcess/CurrentOnGeos.jl#L156-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RBF}" href="#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RBF}"><code>MoM_Kernels.geoElectricJCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算六面体上的电流。 分片常数基 RBF 基函数 电流基函数公式为：Jₙ = κₙIₙfₙ 同一个六面体面片上存在 6 或 3 个基函数，因此 Jₜ = ∑ₜₙ₌₁ Iₜₙfₜₙ 输入： ICoeff          ::Vector{Complex{FT}}  计算得到的电流系数 hexasInfo       ::Vector{HexahedraInfo{IT, FT, CT}},  输出值: Jhexa          ::Marrix{Complex{FT}}, 六面体上加权后的电流</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/PostProcess/CurrentOnGeos.jl#L197-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:PWC}" href="#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:PWC}"><code>MoM_Kernels.geoElectricJCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算四面体上的电流。 分片常数基 PWC 基函数 电流基函数公式为：Jₙ = κₙIₙfₙ 同一个四面体面片上存在 x̂, ŷ, ẑ 方向的三个基函数，因此 Jₜ = κₜ ∑ₜₙ₌₁³Iₜₙfₜₙ 输入： ICoeff          ::Vector{Complex{FT}}  计算得到的电流系数 tetrasInfo      ::Vector{TetrahedraInfo{IT, FT, CT}},  输出值: Jtetra          ::Marrix{Complex{FT}}, 四面体上的电流</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/PostProcess/CurrentOnGeos.jl#L56-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:SWG}" href="#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:SWG}"><code>MoM_Kernels.geoElectricJCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算四面体上的电流。 分片常数基 SWG 基函数 电流基函数公式为：Jₙ = κₙIₙfₙ 同一个四面体面片上存在四个基函数，因此 Jₜ = ∑ₜₙ₌₁⁴ Iₜₙfₜₙ 输入： ICoeff          ::Vector{Complex{FT}}  计算得到的电流系数 tetrasInfo      ::Vector{TetrahedraInfo{IT, FT, CT}},  输出值: Jtetra          ::Marrix{Complex{FT}}, 四面体上加权后的电流</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/PostProcess/CurrentOnGeos.jl#L96-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}}, Tuple{Vector{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RWG}" href="#MoM_Kernels.geoElectricJCal-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Vector{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}}, Tuple{Vector{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}, BFT&lt;:RWG}"><code>MoM_Kernels.geoElectricJCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算三角形面片上的加权电流。 电流基函数公式为：Jₙ = Iₙfₙ 同一个三角形面片上存在三个基函数，因此 Jₜ = ∑ₜₙ₌₁³ Iₜₙfₜₙ 输入： ICoeff          ::Vector{Complex{FT}}  计算得到的电流系数 trianglesInfo   ::Vector{TriangleInfo{IT, FT}}，三角形信息 输出值: Jtri         ::Marrix{Complex{FT}}, 三角形上加权后的电流</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/PostProcess/CurrentOnGeos.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.getAggSBFOnLevel-Union{Tuple{BFT}, Tuple{ST}, Tuple{Any, Vector{ST}, Vector{BFT}}} where {ST&lt;:SurfaceCellType, BFT&lt;:BasisFunctionType}" href="#MoM_Kernels.getAggSBFOnLevel-Union{Tuple{BFT}, Tuple{ST}, Tuple{Any, Vector{ST}, Vector{BFT}}} where {ST&lt;:SurfaceCellType, BFT&lt;:BasisFunctionType}"><code>MoM_Kernels.getAggSBFOnLevel</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据积分方程类型计算基层聚合项</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/AggregateOnLevel.jl#L5-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.getAggSBFOnLevel-Union{Tuple{BFT}, Tuple{VT}, Tuple{Any, Vector{VT}, Vector{BFT}}} where {VT&lt;:VolumeCellType, BFT&lt;:BasisFunctionType}" href="#MoM_Kernels.getAggSBFOnLevel-Union{Tuple{BFT}, Tuple{VT}, Tuple{Any, Vector{VT}, Vector{BFT}}} where {VT&lt;:VolumeCellType, BFT&lt;:BasisFunctionType}"><code>MoM_Kernels.getAggSBFOnLevel</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据积分方程类型计算基层聚合项</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/AggregateOnLevel.jl#L19-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.getAggSBFOnLevel-Union{Tuple{VT2}, Tuple{VT1}, Tuple{Any, Vector{VT1}, Vector{VT2}}} where {VT1&lt;:(AbstractVector), VT2&lt;:(AbstractVector)}" href="#MoM_Kernels.getAggSBFOnLevel-Union{Tuple{VT2}, Tuple{VT1}, Tuple{Any, Vector{VT1}, Vector{VT2}}} where {VT1&lt;:(AbstractVector), VT2&lt;:(AbstractVector)}"><code>MoM_Kernels.getAggSBFOnLevel</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据积分方程类型计算基层聚合项</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/AggregateOnLevel.jl#L28-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.getBfsCenter-Union{Tuple{Vector{BFT}}, Tuple{BFT}} where BFT&lt;:BasisFunctionType" href="#MoM_Kernels.getBfsCenter-Union{Tuple{Vector{BFT}}, Tuple{BFT}} where BFT&lt;:BasisFunctionType"><code>MoM_Kernels.getBfsCenter</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算基函数中心的数组，用于方便混合基函数使用时的情况</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/MLFMA.jl#L9-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.getBfsCenter-Union{Tuple{Vector{VT}}, Tuple{VT}} where VT&lt;:(AbstractVector)" href="#MoM_Kernels.getBfsCenter-Union{Tuple{Vector{VT}}, Tuple{VT}} where VT&lt;:(AbstractVector)"><code>MoM_Kernels.getBfsCenter</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算基函数中心的数组，用于方便混合基函数使用时的情况</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/MLFMA.jl#L26-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.getCubeIDsWithGeos-Tuple{Any, Any}" href="#MoM_Kernels.getCubeIDsWithGeos-Tuple{Any, Any}"><code>MoM_Kernels.getCubeIDsWithGeos</code></a> — <span class="docstring-category">Method</span></header><section><div><p>找到 geosInfo 所在的所有 cude id</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/ZnearEFIE.jl#L353-L355">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.getExcitationVector-Union{Tuple{VST}, Tuple{Vector{VST}, Any, Any}} where VST&lt;:SurfaceCellType" href="#MoM_Kernels.getExcitationVector-Union{Tuple{VST}, Tuple{Vector{VST}, Any, Any}} where VST&lt;:SurfaceCellType"><code>MoM_Kernels.getExcitationVector</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据几何信息与基函数数量，计算激励向量 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 nbf::       基函数数量 source::    激励源 返回： V::         激励向量</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/DirectAlgorithm.jl#L57-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.getExcitationVector-Union{Tuple{VST}, Tuple{Vector{VST}, Any, Any}} where VST&lt;:VolumeCellType" href="#MoM_Kernels.getExcitationVector-Union{Tuple{VST}, Tuple{Vector{VST}, Any, Any}} where VST&lt;:VolumeCellType"><code>MoM_Kernels.getExcitationVector</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据几何信息与基函数数量，计算激励向量 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 nbf::       基函数数量 source::    激励源 返回： V::         激励向量</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/DirectAlgorithm.jl#L80-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.getExcitationVector-Union{Tuple{VT}, Tuple{Vector{VT}, Any, Any}} where VT&lt;:(AbstractVector)" href="#MoM_Kernels.getExcitationVector-Union{Tuple{VT}, Tuple{Vector{VT}, Any, Any}} where VT&lt;:(AbstractVector)"><code>MoM_Kernels.getExcitationVector</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据几何信息与基函数数量，计算激励向量 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 nbf::       基函数数量 source::    激励源 返回： V::         激励向量</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/DirectAlgorithm.jl#L95-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.getGeoIDsInCubeChunk-Tuple{Any, Tuple}" href="#MoM_Kernels.getGeoIDsInCubeChunk-Tuple{Any, Tuple}"><code>MoM_Kernels.getGeoIDsInCubeChunk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getGeoIDsInCubeChunk(cubes, chunkIndice::Tuple)
getGeoIDsInCubeChunk(cubes, ckunkIndice::UnitRange)</code></pre><p>获取 <code>ckunkIndice</code> 内的所有 <code>cubes</code> 的编号， 返回为 Tuple 形式以适应数组索引相关API</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Extends/IOs.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.getGeosInterval-Tuple{T} where T&lt;:(AbstractVector)" href="#MoM_Kernels.getGeosInterval-Tuple{T} where T&lt;:(AbstractVector)"><code>MoM_Kernels.getGeosInterval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getGeosInterval(geosInfo::T) where {T&lt;:AbstractVector}
getGeosInterval(geosInfo::T) where {T&lt;:OffsetVector}</code></pre><p>获取几何信息数组的区间，针对普通 <code>Vector</code> 和 <code>OffsetVector</code> 分别派发。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/AggOnBF/AggEFIE.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.getImpedanceMatAndExciteV-Tuple{Any, Integer, Any}" href="#MoM_Kernels.getImpedanceMatAndExciteV-Tuple{Any, Integer, Any}"><code>MoM_Kernels.getImpedanceMatAndExciteV</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据几何信息与基函数数量，计算阻抗矩阵和激励向量 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 nbf::       基函数数量 source::    激励源 返回： Zmat::      阻抗矩阵 V::         激励向量</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/DirectAlgorithm.jl#L119-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.getImpedanceMatAndExciteV-Tuple{Any, Vector, Any}" href="#MoM_Kernels.getImpedanceMatAndExciteV-Tuple{Any, Vector, Any}"><code>MoM_Kernels.getImpedanceMatAndExciteV</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据几何信息与基函数数量，计算阻抗矩阵和激励向量 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 bfsInfo::   基函数信息 source::    激励源 返回： Zmat::      阻抗矩阵 V::         激励向量</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/DirectAlgorithm.jl#L135-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.getImpedanceMatrix-Union{Tuple{ST}, Tuple{Vector{ST}, Integer}} where ST&lt;:SurfaceCellType" href="#MoM_Kernels.getImpedanceMatrix-Union{Tuple{ST}, Tuple{Vector{ST}, Integer}} where ST&lt;:SurfaceCellType"><code>MoM_Kernels.getImpedanceMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据几何信息与基函数数量，计算阻抗矩阵 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 nbf::       基函数数量 返回： Zmat</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/DirectAlgorithm.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.getImpedanceOpt-Tuple{Any, Any}" href="#MoM_Kernels.getImpedanceOpt-Tuple{Any, Any}"><code>MoM_Kernels.getImpedanceOpt</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据几何信息与基函数数量，计算阻抗矩阵算子 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 nbf::       基函数数量 source::    激励源 返回： Zopt::      阻抗矩阵算子，由近场稀疏矩阵和远场八叉树聚合、转移、解聚组成 V::         激励向量 Octree::    八叉树 Znear::  阻抗矩阵近场元</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/FastAlgorithm.jl#L28-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.getImpedanceOptAndExciteVOctree-Tuple{Any, Any, Any}" href="#MoM_Kernels.getImpedanceOptAndExciteVOctree-Tuple{Any, Any, Any}"><code>MoM_Kernels.getImpedanceOptAndExciteVOctree</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据几何信息与基函数数量，计算阻抗矩阵算子和激励向量 输入： geosInfo::  几何信息，三角形、四面体、六面体的向量 nbf::       基函数数量 source::    激励源 返回： Zopt::      阻抗矩阵算子，由近场稀疏矩阵和远场八叉树聚合、转移、解聚组成 V::         激励向量 Octree::    八叉树 Znear::  阻抗矩阵近场元</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/FastAlgorithm.jl#L7-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.getLeafCubeL-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:HexahedraInfo" href="#MoM_Kernels.getLeafCubeL-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:HexahedraInfo"><code>MoM_Kernels.getLeafCubeL</code></a> — <span class="docstring-category">Method</span></header><section><div><p>六面体从网格平均尺寸设置整体的叶层盒子边长</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/MLFMA.jl#L62-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.getLeafCubeL-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:TetrahedraInfo" href="#MoM_Kernels.getLeafCubeL-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:TetrahedraInfo"><code>MoM_Kernels.getLeafCubeL</code></a> — <span class="docstring-category">Method</span></header><section><div><p>四面体从网格平均尺寸设置整体的叶层盒子边长</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/MLFMA.jl#L53-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.getLeafCubeL-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:TriangleInfo" href="#MoM_Kernels.getLeafCubeL-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:TriangleInfo"><code>MoM_Kernels.getLeafCubeL</code></a> — <span class="docstring-category">Method</span></header><section><div><p>三角形面网格直接设置为的叶层盒子边长</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/MLFMA.jl#L44-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.getLeafCubeL-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:(AbstractVector)" href="#MoM_Kernels.getLeafCubeL-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:(AbstractVector)"><code>MoM_Kernels.getLeafCubeL</code></a> — <span class="docstring-category">Method</span></header><section><div><p>混合网格从第2类里的网格平均尺寸设置整体的叶层盒子边长</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/MLFMA.jl#L71-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.getMeshDataSaveGeosInterval-Tuple{Any}" href="#MoM_Kernels.getMeshDataSaveGeosInterval-Tuple{Any}"><code>MoM_Kernels.getMeshDataSaveGeosInterval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getMeshDataSaveGeosInterval(filename[; meshUnit=:mm, dir = &quot;temp/GeosInfo&quot;])</code></pre><p>在获取网格数据 <code>meshData</code> 和介电参数 <code>εᵣs</code> 的同时保存网格数据 <code>meshData</code> 中各类型网格的区间。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Extends/IOs.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.getNeiFarNeighborCubeIDs-Tuple{Any, Tuple}" href="#MoM_Kernels.getNeiFarNeighborCubeIDs-Tuple{Any, Tuple}"><code>MoM_Kernels.getNeiFarNeighborCubeIDs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getNeiFarNeighborCubeIDs(cubes, chunkIndice::Tuple)</code></pre><p>获取 <code>ckunkIndice</code> 内的所有 <code>cubes</code> 的 远亲盒子 序号， 返回为 <code>Tuple</code> 形式以适应数组索引相关 API。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Extends/IOs.jl#L257-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.getNeighborCubeIDs-Tuple{Any, Tuple}" href="#MoM_Kernels.getNeighborCubeIDs-Tuple{Any, Tuple}"><code>MoM_Kernels.getNeighborCubeIDs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getNeighborCubeIDs(cubes, chunkIndice::Tuple)
getNeighborCubeIDs(cubes, chunkIndice::AbstractVector)</code></pre><p>获取 <code>ckunkIndice</code> 内的所有 <code>cubes</code> 的 <code>邻盒子</code> 编号， 返回为 <code>Tuple</code> 形式以适应数组索引相关API</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Extends/IOs.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.getOctreeAndReOrderBFs!-Tuple{Any, Any}" href="#MoM_Kernels.getOctreeAndReOrderBFs!-Tuple{Any, Any}"><code>MoM_Kernels.getOctreeAndReOrderBFs!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据基函数中心位置构建八叉树，并重排基函数信息、将新基函数 ID 赋值给几何元信息数组 返回值： nLevels::   层数 octree::    得到的八叉树 leafCubeEdgel:: 控制叶层盒子大小 isDistribute:: 控制是否为分布式计算</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/MLFMA.jl#L79-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.get_Interpolation_Method-Tuple{Symbol}" href="#MoM_Kernels.get_Interpolation_Method-Tuple{Symbol}"><code>MoM_Kernels.get_Interpolation_Method</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_Interpolation_Method(method::Symbol)
get_Interpolation_Method(method::Union{Val{:Lagrange2Step}, Val{:Lagrange1Step}})</code></pre><p>获取插值算法。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/MLFMAParams.jl#L51-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.get_chunks_minmax_col-Tuple{Any}" href="#MoM_Kernels.get_chunks_minmax_col-Tuple{Any}"><code>MoM_Kernels.get_chunks_minmax_col</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_chunks_minmax_col(matchunks)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/ZnearChunks.jl#L149-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.get_leafCubeSize-Tuple{}" href="#MoM_Kernels.get_leafCubeSize-Tuple{}"><code>MoM_Kernels.get_leafCubeSize</code></a> — <span class="docstring-category">Method</span></header><section><div><p>获取叶层盒子边长</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/MLFMAParams.jl#L28-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.get_partition-Tuple{Any, Any, Any}" href="#MoM_Kernels.get_partition-Tuple{Any, Any, Any}"><code>MoM_Kernels.get_partition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_partition(nCubes, sizePoles, np)</code></pre><p>根据给定的盒子数 <code>nCubes</code> 、多极子数 <code>sizePoles</code>、进程数 <code>np</code> 返回该层辐射函数的三个维度的划分数量。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Extends/IOs.jl#L148-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.get_partition_map-Tuple{Any, Any}" href="#MoM_Kernels.get_partition_map-Tuple{Any, Any}"><code>MoM_Kernels.get_partition_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_partition_map(partition, kcubeIndices)</code></pre><p>根据 <code>partition</code> 计算在盒子方向本层所有 rank 到子层所有 rank 的 map 。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Extends/IOs.jl#L207-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.gq_xsws_on_sphere-Tuple{Any}" href="#MoM_Kernels.gq_xsws_on_sphere-Tuple{Any}"><code>MoM_Kernels.gq_xsws_on_sphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gq_xsws_on_sphere(L)

计算单位球面 2(L+1) 阶高斯求积的采样点坐标权重</code></pre><p>TBW</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LagrangeInterpolation.jl#L57-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.greenfunc_star-Union{Tuple{T}, Tuple{StaticArraysCore.StaticArray{Tuple{3}, T, 1}, StaticArraysCore.StaticArray{Tuple{3}, T, 1}}} where T&lt;:AbstractFloat" href="#MoM_Kernels.greenfunc_star-Union{Tuple{T}, Tuple{StaticArraysCore.StaticArray{Tuple{3}, T, 1}, StaticArraysCore.StaticArray{Tuple{3}, T, 1}}} where T&lt;:AbstractFloat"><code>MoM_Kernels.greenfunc_star</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">greenfunc_star(pa::Vec3D{T}, pb::Vec3D{T}[; k=Params.K_0, taylorOrder = SglrOrder]) where {T&lt;:AbstractFloat}</code></pre><p>归一化格林函数 <span>$4πG(R)$</span> 泰勒展开后去奇异项：</p><p class="math-container">\[g^{*}(R)    = \frac{e^{-jkR}}{R} - \frac{1}{R}
            = \sum_{n=1}^{SglrOrder}\frac{{-jk}^{n}}{n!}R^{n-1}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/Singularity.jl#L5-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.iluPrecondition-Tuple{Any, Any}" href="#MoM_Kernels.iluPrecondition-Tuple{Any, Any}"><code>MoM_Kernels.iluPrecondition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iluPrecondition(A, level; τ = 1e-3)</code></pre><p>从 (IncompleteLU.jl)[https://github.com/haampie/IncompleteLU.jl.git]  包实现ilu, 再次封装是因为要加入一些判断</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Precondition/ILU.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.impedancemat4CFIE4PEC-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{TriangleInfo{IT, FT}, 1}, Integer, Type{BFT}}} where {IT, FT, BFT&lt;:RWG}" href="#MoM_Kernels.impedancemat4CFIE4PEC-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{TriangleInfo{IT, FT}, 1}, Integer, Type{BFT}}} where {IT, FT, BFT&lt;:RWG}"><code>MoM_Kernels.impedancemat4CFIE4PEC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算PEC的CFIE阻抗矩阵。 输入信息： trianglesInfo:  为包含三角形信息实例的向量 nrwg        :  基函数数目 返回值 Zmat         :  阻抗矩阵</p><p>注意，此程序由于采用的对三角形循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/CFIE/CFIERWGTri.jl#L348-L358">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.impedancemat4EFIE4PEC!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{Complex{FT}, 2}, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT, FT, BFT&lt;:RWG}" href="#MoM_Kernels.impedancemat4EFIE4PEC!-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{Complex{FT}, 2}, Array{TriangleInfo{IT, FT}, 1}, Type{BFT}}} where {IT, FT, BFT&lt;:RWG}"><code>MoM_Kernels.impedancemat4EFIE4PEC!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于在有矩阵的情况下计算PEC的EFIE阻抗矩阵。 输入信息： Zmat trianglesInfo:  为包含三角形信息实例的向量 nrwg        :  基函数数目 返回值 Zmat         :  阻抗矩阵</p><p>注意，此程序由于采用的对三角形循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIERWGTri.jl#L268-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.impedancemat4EFIE4PEC-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{TriangleInfo{IT, FT}, 1}, Integer, Type{BFT}}} where {IT, FT, BFT&lt;:RWG}" href="#MoM_Kernels.impedancemat4EFIE4PEC-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{TriangleInfo{IT, FT}, 1}, Integer, Type{BFT}}} where {IT, FT, BFT&lt;:RWG}"><code>MoM_Kernels.impedancemat4EFIE4PEC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算PEC的EFIE阻抗矩阵。 输入信息： trianglesInfo:  为包含三角形信息实例的向量 nrwg        :  基函数数目 返回值 Zmat         :  阻抗矩阵</p><p>注意，此程序由于采用的对三角形循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIERWGTri.jl#L250-L259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.impedancemat4MFIE4PEC-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{TriangleInfo{IT, FT}, 1}, Integer, Type{BFT}}} where {IT, FT, BFT&lt;:RWG}" href="#MoM_Kernels.impedancemat4MFIE4PEC-Union{Tuple{BFT}, Tuple{FT}, Tuple{IT}, Tuple{Array{TriangleInfo{IT, FT}, 1}, Integer, Type{BFT}}} where {IT, FT, BFT&lt;:RWG}"><code>MoM_Kernels.impedancemat4MFIE4PEC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算PEC的MFIE阻抗矩阵。 输入信息： trianglesInfo:  为包含三角形信息实例的向量 nrwg        :  基函数数目 返回值 Zmat         :  阻抗矩阵</p><p>注意，此程序由于采用的对三角形循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/MFIE/MFIERWGTri.jl#L265-L275">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.impedancemat4RWGPWC!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Any}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.impedancemat4RWGPWC!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Any}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.impedancemat4RWGPWC!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>RWG + PWC 部分的阻抗矩阵</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEVSIERWGPWCHexa.jl#L172-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.impedancemat4RWGPWC!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Any}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.impedancemat4RWGPWC!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Any}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.impedancemat4RWGPWC!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>RWG + PWC 部分的阻抗矩阵</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEVSIERWGPWCTetra.jl#L172-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.impedancemat4RWGRBF!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.impedancemat4RWGRBF!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.impedancemat4RWGRBF!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>RWG + RBF 部分的阻抗矩阵</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEVSIERWGRBF.jl#L307-L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.impedancemat4RWGSWG!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}" href="#MoM_Kernels.impedancemat4RWGSWG!-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TriangleInfo{IT, FT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}}} where {IT&lt;:Integer, FT&lt;:AbstractFloat, CT&lt;:Complex{FT}}"><code>MoM_Kernels.impedancemat4RWGSWG!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>RWG + SWG 部分的阻抗矩阵</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEVSIERWGSWG.jl#L368-L370">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}" href="#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}"><code>MoM_Kernels.impedancemat4VIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算介质体的 PWC 基函数下的 EFIE 阻抗矩阵。 输入信息： hexasInfo::AbstractVector{HexahedraInfo{IT, FT, CT}},  为包含六面体信息实例的向量 tetrasInfo::AbstractVector{TetrahedraInfo{IT, FT, CT}}, 为包含四面体信息实例的向量 nPWC        :  基函数数目 返回值 Zmat        :  阻抗矩阵</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEPWCTetraHexa.jl#L149-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}" href="#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}"><code>MoM_Kernels.impedancemat4VIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算介质体的 PWC 基函数下的 EFIE 阻抗矩阵。 输入信息： hexasInfo  :  为包含六面体信息实例的向量 nrwg        :  基函数数目 返回值 Zmat        :  阻抗矩阵</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEPWCHexa.jl#L296-L303">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:RBF}" href="#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:RBF}"><code>MoM_Kernels.impedancemat4VIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算介质的EFIE阻抗矩阵。 输入信息： hexasInfo  :  为包含六面体信息实例的向量 nrbf        :  基函数数目 返回值 Zmat         :  阻抗矩阵</p><p>注意，此程序由于采用的对六面体循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIERBFHexa.jl#L755-L765">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}" href="#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}"><code>MoM_Kernels.impedancemat4VIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算介质体的 PWC 基函数下的 EFIE 阻抗矩阵。 输入信息： hexasInfo::AbstractVector{HexahedraInfo{IT, FT, CT}},  为包含六面体信息实例的向量 tetrasInfo::AbstractVector{TetrahedraInfo{IT, FT, CT}}, 为包含四面体信息实例的向量 nPWC        :  基函数数目 返回值 Zmat        :  阻抗矩阵</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEPWCTetraHexa.jl#L233-L241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}" href="#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}"><code>MoM_Kernels.impedancemat4VIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算介质体的 PWC 基函数下的 EFIE 阻抗矩阵。 输入信息： tetrasInfo  :  为包含四面体信息实例的向量 nrwg        :  基函数数目 返回值 Zmat        :  阻抗矩阵</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEPWCTetra.jl#L223-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:SWG}" href="#MoM_Kernels.impedancemat4VIE!-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Matrix{CT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Type{BFT}}} where {IT, FT, CT, BFT&lt;:SWG}"><code>MoM_Kernels.impedancemat4VIE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算介质的 EFIE 阻抗矩阵。 输入信息： Zmat       :   已初始化的阻抗矩阵 tetrasInfo  :  为包含四面体信息实例的向量 nswg        :  基函数数目 返回值 Zmat         :  阻抗矩阵</p><p>注意，此程序由于采用的对四面体循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIESWGTetra.jl#L693-L704">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}" href="#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}"><code>MoM_Kernels.impedancemat4VIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算介质体的 PWC 基函数下的 EFIE 阻抗矩阵。 输入信息： hexasInfo  :  为包含六面体信息实例的向量 nPWC        :  基函数数目 返回值 Zmat        :  阻抗矩阵</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEPWCHexa.jl#L413-L420">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT&lt;:RBF}" href="#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT&lt;:RBF}"><code>MoM_Kernels.impedancemat4VIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算介质的EFIE阻抗矩阵。 输入信息： hexasInfo  :  为包含六面体信息实例的向量 nrbf        :  基函数数目 返回值 Zmat         :  阻抗矩阵</p><p>注意，此程序由于采用的对六面体循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIERBFHexa.jl#L734-L744">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}" href="#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT&lt;:PWC}"><code>MoM_Kernels.impedancemat4VIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算介质体的 PWC 基函数下的 EFIE 阻抗矩阵。 输入信息： tetrasInfo  :  为包含四面体信息实例的向量 nrwg        :  基函数数目 返回值 Zmat        :  阻抗矩阵</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEPWCTetra.jl#L203-L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT&lt;:SWG}" href="#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Integer, Type{BFT}}} where {IT, FT, CT, BFT&lt;:SWG}"><code>MoM_Kernels.impedancemat4VIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算介质的EFIE阻抗矩阵。 输入信息： tetrasInfo  :  为包含四面体信息实例的向量 nswg        :  基函数数目 返回值 Zmat         :  阻抗矩阵</p><p>注意，此程序由于采用的对四面体循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIESWGTetra.jl#L671-L681">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{VT}, Tuple{AbstractVector{VT}, Integer, Type{BFT}}} where {VT&lt;:(AbstractVector), BFT&lt;:PWC}" href="#MoM_Kernels.impedancemat4VIE-Union{Tuple{BFT}, Tuple{VT}, Tuple{AbstractVector{VT}, Integer, Type{BFT}}} where {VT&lt;:(AbstractVector), BFT&lt;:PWC}"><code>MoM_Kernels.impedancemat4VIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算混合网格（四面体+六面体）下介质体的 PWC 基函数下的 EFIE 阻抗矩阵。 输入信息： geosInfo    :  为包含四面体信息实例的向量 nPWC        :  基函数数目 返回值 Zmat        :  阻抗矩阵</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEPWCTetraHexa.jl#L248-L255">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.impedancemat4VSIE-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT&lt;:(AbstractVector)" href="#MoM_Kernels.impedancemat4VSIE-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT&lt;:(AbstractVector)"><code>MoM_Kernels.impedancemat4VSIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算VSIE的矩阵</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEVSIE.jl#L8-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.impedancemat4VSIERWGPWC-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT&lt;:(AbstractVector)" href="#MoM_Kernels.impedancemat4VSIERWGPWC-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT&lt;:(AbstractVector)"><code>MoM_Kernels.impedancemat4VSIERWGPWC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算金属介质混合体的EFIE阻抗矩阵。 输入信息： geosInfo    :  为包含几何体信息实例的向量 nbf        :  基函数数目 返回值 Zmat         :  阻抗矩阵</p><p>注意，此程序由于采用的对网格元（几何体）循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEVSIERWGPWCHexa.jl#L255-L265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.impedancemat4VSIERWGRBF-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT&lt;:(AbstractVector)" href="#MoM_Kernels.impedancemat4VSIERWGRBF-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT&lt;:(AbstractVector)"><code>MoM_Kernels.impedancemat4VSIERWGRBF</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算金属介质混合体的EFIE阻抗矩阵。 输入信息： geosInfo    :  为包含几何体信息实例的向量 nbf        :  基函数数目 返回值 Zmat         :  阻抗矩阵</p><p>注意，此程序由于采用的对网格元（几何体）循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEVSIERWGRBF.jl#L379-L389">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.impedancemat4VSIERWGSWG-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT&lt;:(AbstractVector)" href="#MoM_Kernels.impedancemat4VSIERWGSWG-Union{Tuple{VT}, Tuple{Vector{VT}, Integer}} where VT&lt;:(AbstractVector)"><code>MoM_Kernels.impedancemat4VSIERWGSWG</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于计算金属介质混合体的EFIE阻抗矩阵。 输入信息： geosInfo    :  为包含几何体信息实例的向量 nbf        :  基函数数目 返回值 Zmat         :  阻抗矩阵</p><p>注意，此程序由于采用的对网格元（几何体）循环计算，因此在并行化时，会出现不同线程计算出同一个矩阵元，导致写入冲突，因此要加线程锁保证结果写入正确</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/EFIE/EFIEVSIERWGSWG.jl#L439-L449">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.initialVMulZchunks!-Tuple{T} where T&lt;:MoM_Kernels.ZnearChunksStruct" href="#MoM_Kernels.initialVMulZchunks!-Tuple{T} where T&lt;:MoM_Kernels.ZnearChunksStruct"><code>MoM_Kernels.initialVMulZchunks!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialVMulZchunks!(Z::T) where{T&lt;:ZnearChunksStruct}</code></pre><p>初始化 阻抗矩阵 右乘 向量 乘积的 分布式数组</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/ZnearChunks.jl#L105-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.initialZchunksMulV!-Tuple{T} where T&lt;:MoM_Kernels.ZnearChunksStruct" href="#MoM_Kernels.initialZchunksMulV!-Tuple{T} where T&lt;:MoM_Kernels.ZnearChunksStruct"><code>MoM_Kernels.initialZchunksMulV!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialZchunksMulV!(Z::T) where{T&lt;:ZnearChunksStruct}</code></pre><p>初始化 阻抗矩阵 左乘 向量 乘积的 分布式数组。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/ZnearChunks.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.initialZnearCSC-Tuple{Any, Int64}" href="#MoM_Kernels.initialZnearCSC-Tuple{Any, Int64}"><code>MoM_Kernels.initialZnearCSC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialZnearCSC(level, nbf::Int)</code></pre><p>根据八叉树层信息 <code>level</code> 初始化近场阻抗矩阵。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/Znear.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.initialZnearCSR-Tuple{Any, Int64}" href="#MoM_Kernels.initialZnearCSR-Tuple{Any, Int64}"><code>MoM_Kernels.initialZnearCSR</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialZnearCSR(level, nbf::Int)</code></pre><p>根据八叉树层信息 <code>level</code> 初始化近场阻抗矩阵，用 <code>transpose</code> 实现 CSR 压缩稀疏行。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/Znear.jl#L81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.initialZnearChunks-Tuple{Any, AbstractVector}" href="#MoM_Kernels.initialZnearChunks-Tuple{Any, AbstractVector}"><code>MoM_Kernels.initialZnearChunks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialZnearChunks(cube, cubes::AbstractVector; CT = Complex{Precision.FT})</code></pre><p>根据八叉树某个盒子 <code>cube</code> 信息初始化 <code>cube</code> 对应的近场矩阵元块。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/Znear.jl#L156-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.inputParameters-Tuple{}" href="#MoM_Kernels.inputParameters-Tuple{}"><code>MoM_Kernels.inputParameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inputParameters(;args...)</code></pre><p>用于输入仿真参数，并修改奇异性处理中频率相关常量。 详见 [<code>MoM_Basics.inputBasicParameters</code>] 和 <a href="#MoM_Kernels.modiSingularityRelatedConsts!-Tuple{}"><code>modiSingularityRelatedConsts!</code></a>。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Inputs.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.integral1DXW-Union{Tuple{FT}, Tuple{IT}, Tuple{FT, FT, IT, Symbol}} where {IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.integral1DXW-Union{Tuple{FT}, Tuple{IT}, Tuple{FT, FT, IT, Symbol}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.integral1DXW</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算分别采用高斯求积、中点求积计算 θ,ϕ 方向的采样点的坐标、权重 lb::FT，  积分区域下界 hb::FT,   积分区域上界 Nsample::IT, 采样点数 mod::Symbol， 模式，接受 :uni, 均值积分 :glq, 高斯-勒让德积分 两种模式</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LagrangeInterpolation.jl#L2-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.interpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}" href="#MoM_Kernels.interpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.interpolate!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>拉格朗日单步插值</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LagrangeInterpolation.jl#L236-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.interpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}" href="#MoM_Kernels.interpolate!-Union{Tuple{FT}, Tuple{IT}, Tuple{AbstractArray, MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.interpolate!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>拉格朗日分步插值</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LagrangeInterpolation.jl#L175-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.interpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}" href="#MoM_Kernels.interpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterp1StepInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.interpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>拉格朗日单步插值</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LagrangeInterpolation.jl#L220-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.interpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}" href="#MoM_Kernels.interpolate-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.LagrangeInterpInfo{IT, FT}, AbstractArray}} where {IT, FT}"><code>MoM_Kernels.interpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>拉格朗日分步插值</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LagrangeInterpolation.jl#L160-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.interpolationCSCMatCal-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.GLPolesInfo{FT}, MoM_Kernels.GLPolesInfo{FT}, IT}} where {IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.interpolationCSCMatCal-Union{Tuple{FT}, Tuple{IT}, Tuple{MoM_Kernels.GLPolesInfo{FT}, MoM_Kernels.GLPolesInfo{FT}, IT}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.interpolationCSCMatCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>采用局部插值、两步插值法，计算局部坐标到全局坐标的稀疏插值矩阵，Julia数据存储为列主的，因此使用 压缩稀疏列(Compressed Sparse Column, CSC) pLevelPoles::GLPolesInfo{FT}， 父层多极子信息 tLevelPoles::GLPolesInfo{FT}， 本层多极子信息</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LagrangeInterpolation.jl#L252-L256">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.iterSolverSet-Tuple{Symbol}" href="#MoM_Kernels.iterSolverSet-Tuple{Symbol}"><code>MoM_Kernels.iterSolverSet</code></a> — <span class="docstring-category">Method</span></header><section><div><p>迭代求解器选择</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Solvers.jl#L2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.levelIntegralInfoCal-Union{Tuple{FT}, Tuple{FT, Union{Val{:Lagrange2Step}, Val{:Lagrange1Step}}}} where FT&lt;:Real" href="#MoM_Kernels.levelIntegralInfoCal-Union{Tuple{FT}, Tuple{FT, Union{Val{:Lagrange2Step}, Val{:Lagrange1Step}}}} where FT&lt;:Real"><code>MoM_Kernels.levelIntegralInfoCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算八叉树的积分相关信息，包括截断项、各层积分点和求积权重数据 输入: levelCubeEdgel::FT,  层盒子边长, 一般叶层为0.25λ，其中 λ 为区域局部波长。 返回值 L           ::IT， 层 截断项 levelsPoles ::Vector{GLPolesInfo{FT}}，从叶层到第 “2” 层的角谱空间采样信息</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LagrangeInterpolation.jl#L97-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.loadCurrent-Tuple{Any}" href="#MoM_Kernels.loadCurrent-Tuple{Any}"><code>MoM_Kernels.loadCurrent</code></a> — <span class="docstring-category">Method</span></header><section><div><p>读取电流系数</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Solvers.jl#L16-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.loadGeoInterval-Tuple{Any}" href="#MoM_Kernels.loadGeoInterval-Tuple{Any}"><code>MoM_Kernels.loadGeoInterval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_geosInterval!(fn)</code></pre><p>载入文件 <code>fn</code> 读取网格数据区间。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Extends/ParallelParams.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.memoryAllocationOnLevels!-Union{Tuple{LV}, Tuple{IT}, Tuple{Integer, Dict{IT, LV}}} where {IT&lt;:Integer, LV&lt;:MoM_Kernels.LevelInfo}" href="#MoM_Kernels.memoryAllocationOnLevels!-Union{Tuple{LV}, Tuple{IT}, Tuple{Integer, Dict{IT, LV}}} where {IT&lt;:Integer, LV&lt;:MoM_Kernels.LevelInfo}"><code>MoM_Kernels.memoryAllocationOnLevels!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>预分配各层上的聚合项、解聚项</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LevelInfo.jl#L347-L349">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.modiSingularityRelatedConsts!-Tuple{}" href="#MoM_Kernels.modiSingularityRelatedConsts!-Tuple{}"><code>MoM_Kernels.modiSingularityRelatedConsts!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>用于输入参数（特指频率）改变时的更改相关常数项</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/Singularity.jl#L89-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.octreeXWNCal-Union{Tuple{FT}, Tuple{IT}, Tuple{FT, FT, IT, Symbol}} where {IT&lt;:Integer, FT&lt;:Real}" href="#MoM_Kernels.octreeXWNCal-Union{Tuple{FT}, Tuple{IT}, Tuple{FT, FT, IT, Symbol}} where {IT&lt;:Integer, FT&lt;:Real}"><code>MoM_Kernels.octreeXWNCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算各层八叉树求积坐标、求积权重 lb::FT，  积分区域下界 hb::FT,   积分区域上界 nlevels::IT, 八叉树叶层ID mod::Symbol， 模式，接受 :uni, 均值积分(ϕ方向) :glq, 高斯-勒让德积分(θ方向) 两种模式</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LagrangeInterpolation.jl#L35-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.pickCycleVec-Union{Tuple{T}, Tuple{Integer, Vector{T}}} where T&lt;:Real" href="#MoM_Kernels.pickCycleVec-Union{Tuple{T}, Tuple{Integer, Vector{T}}} where T&lt;:Real"><code>MoM_Kernels.pickCycleVec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据循环向量 cycleVec 的周期性索引超出上下界的 index 对应的值</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LagrangeInterpolation.jl#L518-L520">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.pickθ-Union{Tuple{T}, Tuple{Integer, Vector{T}}} where T&lt;:Real" href="#MoM_Kernels.pickθ-Union{Tuple{T}, Tuple{Integer, Vector{T}}} where T&lt;:Real"><code>MoM_Kernels.pickθ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>利用 θ 在极点附近的对称性计算索引超出上下界的 θ 值</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LagrangeInterpolation.jl#L534-L536">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.pickϕ-Union{Tuple{TT}, Tuple{Integer, Vector{TT}}} where TT&lt;:Real" href="#MoM_Kernels.pickϕ-Union{Tuple{TT}, Tuple{Integer, Vector{TT}}} where TT&lt;:Real"><code>MoM_Kernels.pickϕ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>利用 ϕ 的周期性索引超出上下界的 ϕ 值</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LagrangeInterpolation.jl#L501-L503">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.radarCrossSection-Union{Tuple{BFT}, Tuple{CT}, Tuple{VT}, Tuple{Any, Any, Vector{CT}, Vector{VT}}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Type{BFT}}} where {VT&lt;:VolumeCellType, CT&lt;:Complex, BFT&lt;:BasisFunctionType}" href="#MoM_Kernels.radarCrossSection-Union{Tuple{BFT}, Tuple{CT}, Tuple{VT}, Tuple{Any, Any, Vector{CT}, Vector{VT}}, Tuple{Any, Any, Vector{CT}, Vector{VT}, Type{BFT}}} where {VT&lt;:VolumeCellType, CT&lt;:Complex, BFT&lt;:BasisFunctionType}"><code>MoM_Kernels.radarCrossSection</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在球坐标为r̂θϕ处计算辐射积分，采用SWG基函数时，四面体上没有统一的电流值，每一点上都是四个SWG基函数电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙsₙρₙ/(3Vₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙsₙρₙ/3)exp(jkr̂(θ, ϕ)⋅rₙ) )</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/PostProcess/RCS.jl#L57-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.radarCrossSection-Union{Tuple{BFT}, Tuple{ST}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{ST}}, Tuple{Any, Any, Vector{CT}, Vector{ST}, Type{BFT}}} where {CT&lt;:Complex, ST&lt;:TriangleInfo, BFT&lt;:RWG}" href="#MoM_Kernels.radarCrossSection-Union{Tuple{BFT}, Tuple{ST}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{ST}}, Tuple{Any, Any, Vector{CT}, Vector{ST}, Type{BFT}}} where {CT&lt;:Complex, ST&lt;:TriangleInfo, BFT&lt;:RWG}"><code>MoM_Kernels.radarCrossSection</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在球坐标为r̂θϕ处计算辐射积分，采用RWG基函数时，三角形上没有统一的电流值，每一点上都是三边电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙlₙρₙ/(2Sₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙlₙρₙ/2)exp(jkr̂(θ, ϕ)⋅rₙ) )</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/PostProcess/RCS.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.radarCrossSection-Union{Tuple{VT}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{VT}}} where {CT&lt;:Complex, VT&lt;:(AbstractVector)}" href="#MoM_Kernels.radarCrossSection-Union{Tuple{VT}, Tuple{CT}, Tuple{Any, Any, Vector{CT}, Vector{VT}}} where {CT&lt;:Complex, VT&lt;:(AbstractVector)}"><code>MoM_Kernels.radarCrossSection</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在球坐标为r̂θϕ处计算辐射积分，采用SWG基函数时，四面体上没有统一的电流值，每一点上都是四个SWG基函数电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙsₙρₙ/(3Vₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙsₙρₙ/3)exp(jkr̂(θ, ϕ)⋅rₙ) )</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/PostProcess/RCS.jl#L110-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.raditionalIntegralNCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Array{TriangleInfo{IT, FT}, 1}, Array{CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}" href="#MoM_Kernels.raditionalIntegralNCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{Any, Any, Array{TriangleInfo{IT, FT}, 1}, Array{CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}"><code>MoM_Kernels.raditionalIntegralNCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在设定好的观测角度上的球坐标处计算辐射积分，采用RWG基函数时，三角形上没有统一的电流值，每一点上都是三边电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙlₙρₙ/(2Sₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙlₙρₙ/2)exp(jkr̂(θ, ϕ)⋅rₙ) )</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/PostProcess/RadiationIntegral.jl#L205-L212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Matrix{CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}" href="#MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, AbstractArray{HexahedraInfo{IT, FT, CT}, 1}, Matrix{CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}"><code>MoM_Kernels.raditionalIntegralNθϕCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在球坐标为r̂θϕ处计算辐射积分，采用 RBF 基函数时，六面体上没有统一的电流值 N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dV)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/PostProcess/RadiationIntegral.jl#L154-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Matrix{CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}" href="#MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, AbstractArray{TetrahedraInfo{IT, FT, CT}, 1}, Matrix{CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}"><code>MoM_Kernels.raditionalIntegralNθϕCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在球坐标为r̂θϕ处计算辐射积分，采用 SWG 基函数时，四面体上没有统一的电流值，每一点上都是四面电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dV)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁⁴ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dV)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁⁴ IₙSₙρₙ/(3Vₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁⁴ IₙSₙρₙ/3)exp(jkr̂(θ, ϕ)⋅rₙ) )</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/PostProcess/RadiationIntegral.jl#L99-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, Array{TriangleInfo{IT, FT}, 1}, Array{CT, 3}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}" href="#MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, Array{TriangleInfo{IT, FT}, 1}, Array{CT, 3}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}"><code>MoM_Kernels.raditionalIntegralNθϕCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在球坐标为r̂θϕ处计算辐射积分，采用RWG基函数时，三角形上没有统一的电流值，每一点上都是三边电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙlₙρₙ/(2Sₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙlₙρₙ/2)exp(jkr̂(θ, ϕ)⋅rₙ) )</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/PostProcess/RadiationIntegral.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, Array{TriangleInfo{IT, FT}, 1}, Matrix{CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}" href="#MoM_Kernels.raditionalIntegralNθϕCal-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{r̂θϕInfo{FT}, Array{TriangleInfo{IT, FT}, 1}, Matrix{CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex}"><code>MoM_Kernels.raditionalIntegralNθϕCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>在球坐标为r̂θϕ处计算辐射积分，采用RWG基函数时，三角形上没有统一的电流值，每一点上都是三边电流的叠加， 此时: N(θ, ϕ) =   ∑ₙ(∫ₛ Jˢ exp( jkr̂(θ, ϕ)⋅rₙ ) dS)         =   ∑ₙ(∫ₛ (∑ₜₙ₌₁³ Iₙfₙ)exp(jkr̂(θ, ϕ)⋅rₙ) dS)         =   ∑ₙ(Sₜ (∑ₜₙ₌₁³ Iₙlₙρₙ/(2Sₙ))exp(jkr̂(θ, ϕ)⋅rₙ) )         =   ∑ₙ(∑ᵢWᵢ(∑ₜₙ₌₁³ Iₙlₙρₙ/2)exp(jkr̂(θ, ϕ)⋅rₙ) )</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/PostProcess/RadiationIntegral.jl#L50-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.reOrderBasisFunctionAndGeoInfo!-Union{Tuple{VCellT}, Tuple{BFT}, Tuple{IT}, Tuple{Vector{IT}, Vector{VCellT}, Vector{BFT}}} where {IT&lt;:Integer, BFT&lt;:BasisFunctionType, VCellT&lt;:VSCellType}" href="#MoM_Kernels.reOrderBasisFunctionAndGeoInfo!-Union{Tuple{VCellT}, Tuple{BFT}, Tuple{IT}, Tuple{Vector{IT}, Vector{VCellT}, Vector{BFT}}} where {IT&lt;:Integer, BFT&lt;:BasisFunctionType, VCellT&lt;:VSCellType}"><code>MoM_Kernels.reOrderBasisFunctionAndGeoInfo!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据按八叉树重新排序的id重排基函数信息</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/OctreeInfo.jl#L195-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.reOrderBasisFunctionAndGeoInfo!-Union{Tuple{VCellT}, Tuple{IT}, Tuple{Vector{IT}, Vector{VCellT}, Val{:PWC}}} where {IT&lt;:Integer, VCellT&lt;:VSCellType}" href="#MoM_Kernels.reOrderBasisFunctionAndGeoInfo!-Union{Tuple{VCellT}, Tuple{IT}, Tuple{Vector{IT}, Vector{VCellT}, Val{:PWC}}} where {IT&lt;:Integer, VCellT&lt;:VSCellType}"><code>MoM_Kernels.reOrderBasisFunctionAndGeoInfo!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据按八叉树重新排序的id重排基函数信息，此函数适用于 PWC 基函数的情况</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/OctreeInfo.jl#L255-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.reOrderBasisFunctionAndGeoInfo!-Union{Tuple{VT2}, Tuple{VT1}, Tuple{IT}, Tuple{Vector{IT}, Vector{VT1}, Vector{VT2}}} where {IT&lt;:Integer, VT1&lt;:(AbstractVector), VT2&lt;:(AbstractVector)}" href="#MoM_Kernels.reOrderBasisFunctionAndGeoInfo!-Union{Tuple{VT2}, Tuple{VT1}, Tuple{IT}, Tuple{Vector{IT}, Vector{VT1}, Vector{VT2}}} where {IT&lt;:Integer, VT1&lt;:(AbstractVector), VT2&lt;:(AbstractVector)}"><code>MoM_Kernels.reOrderBasisFunctionAndGeoInfo!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据按八叉树重新排序的id重排基函数信息</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/OctreeInfo.jl#L222-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.reOrderCubeID!-Union{Tuple{LV}, Tuple{Integer, Dict{Int64, LV}, Dict{Int64, Vector{Int64}}}} where LV&lt;:MoM_Kernels.AbstractLevel" href="#MoM_Kernels.reOrderCubeID!-Union{Tuple{LV}, Tuple{Integer, Dict{Int64, LV}, Dict{Int64, Vector{Int64}}}} where LV&lt;:MoM_Kernels.AbstractLevel"><code>MoM_Kernels.reOrderCubeID!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据排序后的新id重新排列子层盒子以及盒子的邻盒子信息，以将同一个父盒子层的盒子相邻排列，这样有利于计算 更新的量：父层盒子的kidsInterval， 本层的盒子顺序，本层盒子的邻盒子id</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/OctreeInfo.jl#L131-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.record_memorys-Tuple{Any}" href="#MoM_Kernels.record_memorys-Tuple{Any}"><code>MoM_Kernels.record_memorys</code></a> — <span class="docstring-category">Method</span></header><section><div><p>展示</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Recorder.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.restore_infos-Tuple{}" href="#MoM_Kernels.restore_infos-Tuple{}"><code>MoM_Kernels.restore_infos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">restore_infos()
记录各部分内存和各阶段计算时间。</code></pre><p>TBW</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Recorder.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.saveCubes-Tuple{Any, Any}" href="#MoM_Kernels.saveCubes-Tuple{Any, Any}"><code>MoM_Kernels.saveCubes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">saveCubes(cubes[, nchunk = ParallelParams.nprocs; name, dir=&quot;&quot;, kcubeIndices = nothing])</code></pre><p>将盒子 <code>cubes</code> 分为 <code>nchunk</code> 块以 <code>name</code> 为名保存在 <code>dir</code>中。<code>kcubeIndices</code> 同于计算不同分区间重复的部分。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Extends/IOs.jl#L216-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.saveCurrent-Tuple{Any}" href="#MoM_Kernels.saveCurrent-Tuple{Any}"><code>MoM_Kernels.saveCurrent</code></a> — <span class="docstring-category">Method</span></header><section><div><p>保存电流系数</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Solvers.jl#L9-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.saveGeoInterval-Tuple{Any}" href="#MoM_Kernels.saveGeoInterval-Tuple{Any}"><code>MoM_Kernels.saveGeoInterval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">saveGeoInterval(meshData[; dir = &quot;temp/GeosInfo&quot;])</code></pre><p>保存网格数据 <code>meshData</code> 中各类型网格的区间。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Extends/IOs.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.saveGeosInfoChunks-Tuple{AbstractVector, Any, AbstractString, Int64}" href="#MoM_Kernels.saveGeosInfoChunks-Tuple{AbstractVector, Any, AbstractString, Int64}"><code>MoM_Kernels.saveGeosInfoChunks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">saveGeosInfoChunks(geos::AbstractVector, cubes, name::AbstractString, nchunk::Int[; dir = &quot;&quot;, cubes_ChunksIndices = sizeChunks2idxs(length(cubes), nchunk)])</code></pre><p>将几何信息 <code>geos</code> 根据分块数量 <code>nchunk</code> 和在 <code>cubes</code> 中的分布进行分块并保存。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Extends/IOs.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.saveLevel" href="#MoM_Kernels.saveLevel"><code>MoM_Kernels.saveLevel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">saveLevel(level[, np = ParallelParams.nprocs; dir=&quot;&quot;, kcubeIndices = nothing])</code></pre><p>将层 <code>level</code> 信息保存，其中的盒子信息由 <a href="#MoM_Kernels.get_partition-Tuple{Any, Any, Any}"><code>get_partition</code></a> 计算的分块信息部分保存。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Extends/IOs.jl#L160-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.saveOctree-Tuple{Any}" href="#MoM_Kernels.saveOctree-Tuple{Any}"><code>MoM_Kernels.saveOctree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">saveOctree(octree[; dir=&quot;&quot;])</code></pre><p>将八叉树 <code>octree</code> 保存在 <code>dir</code> 中。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Extends/IOs.jl#L110-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.saveVec2Chunks-Tuple{AbstractVector, AbstractString, Any}" href="#MoM_Kernels.saveVec2Chunks-Tuple{AbstractVector, AbstractString, Any}"><code>MoM_Kernels.saveVec2Chunks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">saveVec2Chunks(y::AbstractVector, name::AbstractString, indices[; dir = &quot;&quot;, showpmeter = false, message = &quot;&quot;])</code></pre><p>把向量 <code>y</code> 以 <code>name</code> 按索引 <code>indices</code> 块保存在 <code>dir</code> 文件夹中。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Extends/IOs.jl#L92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.saveVec2Chunks-Tuple{AbstractVector, AbstractString, Int64}" href="#MoM_Kernels.saveVec2Chunks-Tuple{AbstractVector, AbstractString, Int64}"><code>MoM_Kernels.saveVec2Chunks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">saveVec2Chunks(y::AbstractVector, name::AbstractString, nchunk::Int[; dir = &quot;&quot;])</code></pre><p>把向量 <code>y</code> 以 <code>name</code> 分为 <code>nchunk</code> 块保存在 <code>dir</code> 文件夹中。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Extends/IOs.jl#L81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.searchNearCubes-Union{Tuple{IT}, Tuple{Matrix{IT}, Integer}} where IT&lt;:Integer" href="#MoM_Kernels.searchNearCubes-Union{Tuple{IT}, Tuple{Matrix{IT}, Integer}} where IT&lt;:Integer"><code>MoM_Kernels.searchNearCubes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>用于寻找邻盒子的函数 输入 cubesID3D::Matrix{Int}，(n×3)盒子在本层的三维坐标 levelID::Integer       层编号，（定义大盒子为（“0” 层），叶层为第“n”层</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LevelInfo.jl#L242-L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.setBFInterval!-Union{Tuple{LV}, Tuple{Integer, Dict{Int64, LV}}} where LV&lt;:MoM_Kernels.AbstractLevel" href="#MoM_Kernels.setBFInterval!-Union{Tuple{LV}, Tuple{Integer, Dict{Int64, LV}}} where LV&lt;:MoM_Kernels.AbstractLevel"><code>MoM_Kernels.setBFInterval!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>根据已经排序好的层的盒子信息，从叶层到顶层更新盒子包含的基函数区间</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/OctreeInfo.jl#L270-L272">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.setBigCube-Union{Tuple{FT}, Tuple{Matrix{FT}, FT}} where FT&lt;:Real" href="#MoM_Kernels.setBigCube-Union{Tuple{FT}, Tuple{Matrix{FT}, FT}} where FT&lt;:Real"><code>MoM_Kernels.setBigCube</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算包围目标的大盒子信息 输入： nodes::Matrix{FT}，大小为 (3, n) 的用于分割成八叉树的空间点，如基函数的中心坐标，或者为构成网格的所有点 leafCubeEdgel::FT，叶层盒子边长，用于计算总层数和大盒子的坐标信息</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/OctreeInfo.jl#L100-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.setGeoIDsInLeafCubes!-Union{Tuple{CBF}, Tuple{Any, Vector{CBF}}} where CBF&lt;:ConstBasisFunction" href="#MoM_Kernels.setGeoIDsInLeafCubes!-Union{Tuple{CBF}, Tuple{Any, Vector{CBF}}} where CBF&lt;:ConstBasisFunction"><code>MoM_Kernels.setGeoIDsInLeafCubes!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>用于设置给定层的盒子中包含的几何体，采用常数基函数时，同一个盒子不会出现重复值。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/SetGeoIDsInLevelCubes.jl#L88-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.setGeoIDsInLeafCubes!-Union{Tuple{LBF}, Tuple{Any, Vector{LBF}}} where LBF&lt;:LinearBasisFunction" href="#MoM_Kernels.setGeoIDsInLeafCubes!-Union{Tuple{LBF}, Tuple{Any, Vector{LBF}}} where LBF&lt;:LinearBasisFunction"><code>MoM_Kernels.setGeoIDsInLeafCubes!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>用于设置给定层的盒子中包含的几何体，采用 RWG、SWG、RBF 基函数时，八叉树分组依据为基函数， 同一个几何体会被分在不同的基函数上会被分入入不同的盒子，因此邻盒子中的几何体 id 大概率出现重复值。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/SetGeoIDsInLevelCubes.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.setGeoIDsInLeafCubes!-Union{Tuple{VT}, Tuple{Any, Vector{VT}}} where VT&lt;:(AbstractVector)" href="#MoM_Kernels.setGeoIDsInLeafCubes!-Union{Tuple{VT}, Tuple{Any, Vector{VT}}} where VT&lt;:(AbstractVector)"><code>MoM_Kernels.setGeoIDsInLeafCubes!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>用于设置给定层的盒子中包含的几何体，采用 RWG、SWG、RBF 基函数时，八叉树分组依据为基函数， 同一个几何体会被分在不同的基函数上会被分入入不同的盒子，因此邻盒子中的几何体 id 大概率出现重复值。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/SetGeoIDsInLevelCubes.jl#L34-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.setKidLevelFarNeighbors!-Tuple{Any, Any}" href="#MoM_Kernels.setKidLevelFarNeighbors!-Tuple{Any, Any}"><code>MoM_Kernels.setKidLevelFarNeighbors!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>寻找子层的远亲盒子 输入:: thisLevel::LevelInfo{IT, FT, IPT}, 本层信息 kidLevel::LevelInfo{IT, FT, IPT}， 子层信息</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LevelInfo.jl#L307-L312">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.setLevelInfo!-Union{Tuple{FT}, Tuple{Integer, Any, FT, StaticArraysCore.StaticArray{Tuple{3}, FT, 1}}} where FT&lt;:Real" href="#MoM_Kernels.setLevelInfo!-Union{Tuple{FT}, Tuple{Integer, Any, FT, StaticArraysCore.StaticArray{Tuple{3}, FT, 1}}} where FT&lt;:Real"><code>MoM_Kernels.setLevelInfo!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>非叶层LevelInfo的构造函数，输入为空间三维坐标数组 levelID::计算层的id leafnodes::Matrix{FT},大小为 (3, n) 的用于分割成八叉树的空间点，如基函数的中心坐标 cubeEdgel::FT，本层盒子边长</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LevelInfo.jl#L163-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.setLevelInfo!-Union{Tuple{FT}, Tuple{Integer, Matrix{FT}, FT, StaticArraysCore.StaticArray{Tuple{3}, FT, 1}}} where FT&lt;:Real" href="#MoM_Kernels.setLevelInfo!-Union{Tuple{FT}, Tuple{Integer, Matrix{FT}, FT, StaticArraysCore.StaticArray{Tuple{3}, FT, 1}}} where FT&lt;:Real"><code>MoM_Kernels.setLevelInfo!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setLevelInfo!(nLevels::Integer, leafnodes::Matrix{FT},cubeEdgel::FT, bigCubeLowerCoor::Vec3D{FT}[; 
                IPT = get_Interpolation_Method(MLFMAParams.InterpolationMethod), LT = LevelInfo]) where{FT&lt;:Real}</code></pre><p>叶层 LevelInfo 的构造函数，输入信息：</p><pre><code class="nohighlight hljs">nLevels::IT                 层数，亦为叶层层ID
leafnodes::Matrix{FT}       大小为 (3, n) 的用于分割成八叉树的空间点，如基函数的中心坐标
cubeEdgel::FT               叶层盒子边长
bigCubeLowerCoor::Vec3D{FT} 大盒子的角坐标
IPT                         插值算法类型
LT = LevelInfo              层类</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/LevelInfo.jl#L76-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.setLevelTransFactor!-Union{Tuple{LV}, Tuple{Int64, Dict{Int64, LV}}} where LV&lt;:MoM_Kernels.AbstractLevel" href="#MoM_Kernels.setLevelTransFactor!-Union{Tuple{LV}, Tuple{Int64, Dict{Int64, LV}}} where LV&lt;:MoM_Kernels.AbstractLevel"><code>MoM_Kernels.setLevelTransFactor!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算 第“2”层 到 叶 层的转移因子， 转移因子只存在于远亲组，每层远亲组最多有 7^3 - 3^3 = 316种结果</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/PhaseShiftAndTransFactors.jl#L109-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.setLevelsCubesKidsIn8!-Union{Tuple{LV}, Tuple{Integer, Dict{Int64, LV}}} where LV&lt;:MoM_Kernels.AbstractLevel" href="#MoM_Kernels.setLevelsCubesKidsIn8!-Union{Tuple{LV}, Tuple{Integer, Dict{Int64, LV}}} where LV&lt;:MoM_Kernels.AbstractLevel"><code>MoM_Kernels.setLevelsCubesKidsIn8!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>计算（nLevel-1）-2 层每层的非空盒子的非空子盒子在其8个子盒子中的位置</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/OctreeInfo.jl#L303-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.setLevelsShiftFactor!-Union{Tuple{LV}, Tuple{Int64, Dict{Int64, LV}}} where LV&lt;:MoM_Kernels.AbstractLevel" href="#MoM_Kernels.setLevelsShiftFactor!-Union{Tuple{LV}, Tuple{Int64, Dict{Int64, LV}}} where LV&lt;:MoM_Kernels.AbstractLevel"><code>MoM_Kernels.setLevelsShiftFactor!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>本函数用于给输入的本(level)层的盒子与其子盒子之间计算相移因子， 由盒子排列的规律性和相移因子的对称性，可知： 只需要计算8个相移因子，即可用于所有盒子到其子盒子的相移， 且这八个盒子关于原点对称的两两之间的相移因子为共轭关系 计算完成直接保存在 level 不再返回</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/PhaseShiftAndTransFactors.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.setVSC₁₂₃ⁿ!-Tuple{}" href="#MoM_Kernels.setVSC₁₂₃ⁿ!-Tuple{}"><code>MoM_Kernels.setVSC₁₂₃ⁿ!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setVSC₁₂₃ⁿ!()</code></pre><p>计算体奇异性三个系数。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/Singularity.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.set_Interpolation_Method!-Tuple{Any}" href="#MoM_Kernels.set_Interpolation_Method!-Tuple{Any}"><code>MoM_Kernels.set_Interpolation_Method!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>设置插值算法</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/MLFMAParams.jl#L35-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.set_geosInterval!-Tuple{Any}" href="#MoM_Kernels.set_geosInterval!-Tuple{Any}"><code>MoM_Kernels.set_geosInterval!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_geosInterval!(fn)</code></pre><p>通过文件 <code>fn</code> 设置网格数据区间。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Extends/ParallelParams.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.set_leafCubeSize!-Union{Tuple{}, Tuple{FT}} where FT&lt;:AbstractFloat" href="#MoM_Kernels.set_leafCubeSize!-Union{Tuple{}, Tuple{FT}} where FT&lt;:AbstractFloat"><code>MoM_Kernels.set_leafCubeSize!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>设置叶层盒子边长</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/MLFMAParams.jl#L21-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.set_nprocs!-Tuple{}" href="#MoM_Kernels.set_nprocs!-Tuple{}"><code>MoM_Kernels.set_nprocs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_nprocs!([;nprocs=1, np=nprocs])</code></pre><p>设置并行核心数量为 <code>nprocs</code> 。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Extends/ParallelParams.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.singularF1-Union{Tuple{FT}, NTuple{4, FT}} where FT&lt;:AbstractFloat" href="#MoM_Kernels.singularF1-Union{Tuple{FT}, NTuple{4, FT}} where FT&lt;:AbstractFloat"><code>MoM_Kernels.singularF1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">singularF1(a::FT, b::FT, c::FT, d::FT) where{FT&lt;:AbstractFloat}</code></pre><p>计算边长为<code>a, b, c, d</code>的四边形重合时的奇异性F1项，即 <span>$\int{\int{\frac{1}{R}}dS}$</span> 的解析值。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/Singularity/FaceSingularity.jl#L15-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.singularF1-Union{Tuple{FT}, Tuple{FT, FT, FT}} where FT&lt;:AbstractFloat" href="#MoM_Kernels.singularF1-Union{Tuple{FT}, Tuple{FT, FT, FT}} where FT&lt;:AbstractFloat"><code>MoM_Kernels.singularF1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">singularF1(a::FT, b::FT, c::FT) where{FT&lt;:AbstractFloat}</code></pre><p>计算边长为<code>a, b, c</code>的三角形重合时的奇异性F1项，即 <span>$\int{\int{\frac{1}{R}}dS}$</span> 的解析值。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/Singularity/FaceSingularity.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.singularF21-Union{Tuple{FT}, NTuple{4, FT}} where FT&lt;:AbstractFloat" href="#MoM_Kernels.singularF21-Union{Tuple{FT}, NTuple{4, FT}} where FT&lt;:AbstractFloat"><code>MoM_Kernels.singularF21</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">singularF21(a::FT, b::FT, c::FT, area2::FT) where{FT&lt;:AbstractFloat}</code></pre><p>计算边长为<code>a, b, c</code>，面积平方为<code>area2</code>的三角形重合时的奇异性F2项，即 <span>$\int{\int{\frac{\boldsymbol{\rho}_{m}\cdot\boldsymbol{\rho}_{n}}{R}}dS}$</span> 的解析值，该函数处理 m==n 即基函数自作用的情况。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/Singularity/FaceSingularity.jl#L30-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.singularF22-Union{Tuple{FT}, NTuple{4, FT}} where FT&lt;:AbstractFloat" href="#MoM_Kernels.singularF22-Union{Tuple{FT}, NTuple{4, FT}} where FT&lt;:AbstractFloat"><code>MoM_Kernels.singularF22</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">singularF21(a::FT, b::FT, c::FT, area2::FT) where{FT&lt;:AbstractFloat}</code></pre><p>计算边长为<code>a, b, c</code>，面积平方为<code>area2</code>的三角形重合时的奇异性F2项，即 <span>$\int{\int{\frac{\boldsymbol{\rho}_{m}\cdot\boldsymbol{\rho}_{n}}{R}}dS}$</span> 的解析值，该函数处理 m!=n 即同一三角形的不同基函数作用的情况。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/Singularity/FaceSingularity.jl#L48-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.sizeChunks2cuts-Tuple{Any, Any}" href="#MoM_Kernels.sizeChunks2cuts-Tuple{Any, Any}"><code>MoM_Kernels.sizeChunks2cuts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sizeChunks2cuts(Asize, chunks)
sizeChunks2cuts(Asize::Int, chunks)
sizeChunks2cuts(Asize, chunks::Int)
sizeChunks2cuts(Asize::Int, chunks::Int)</code></pre><p>将数组大小 <code>Asize</code> 按 <code>chunks</code> 进行分块。 <em>从 <a href="https://github.com/deltaeecs/MPIArray4MoMs.jl">MPIArray4MoMs</a> 借的！ 为的是避免提前引入 MPI 导致在集群上的 bug。因此该函数的修改必须与  <a href="https://github.com/deltaeecs/MPIArray4MoMs.jl">MPIArray4MoMs</a> 同步。</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Extends/MPIArray_utlis.jl#L65-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.sizeChunks2idxs-Tuple{Any, Any}" href="#MoM_Kernels.sizeChunks2idxs-Tuple{Any, Any}"><code>MoM_Kernels.sizeChunks2idxs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sizeChunks2idxs(Asize, nchunk)</code></pre><p>Borrowed form DistributedArray.jl, get the slice of matrix size Asize on each dimension with nchunk. <em>从 <a href="https://github.com/deltaeecs/MPIArray4MoMs.jl">MPIArray4MoMs</a> 借的！ 为的是避免提前引入 MPI 导致在集群上的 bug。因此该函数的修改必须与  <a href="https://github.com/deltaeecs/MPIArray4MoMs.jl">MPIArray4MoMs</a> 同步。</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Extends/MPIArray_utlis.jl#L119-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.sizeChunksCuts2indices-Tuple{Any, Any, Tuple}" href="#MoM_Kernels.sizeChunksCuts2indices-Tuple{Any, Any, Tuple}"><code>MoM_Kernels.sizeChunksCuts2indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sizeChunksCuts2indices(Asize, nchunk, cuts::Tuple)
sizeChunksCuts2indices(Asize, nchunk, cuts::Vector{I}) where{I&lt;:Integer}</code></pre><p>根据数组大小 <code>Asize</code> 分块数量 <code>nchunk</code> 以及各块索引区间 <code>cuts</code> 计算各块的索引。 <em>从 <a href="https://github.com/deltaeecs/MPIArray4MoMs.jl">MPIArray4MoMs</a> 借的！ 为的是避免提前引入 MPI 导致在集群上的 bug。因此该函数的修改必须与  <a href="https://github.com/deltaeecs/MPIArray4MoMs.jl">MPIArray4MoMs</a> 同步。</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Extends/MPIArray_utlis.jl#L89-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.slicedim2bounds-Tuple{Int64, Int64}" href="#MoM_Kernels.slicedim2bounds-Tuple{Int64, Int64}"><code>MoM_Kernels.slicedim2bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">slicedim2bounds(sz::Int, nc::Int)</code></pre><p>将区间 <code>1:sz</code> 划分为 <code>nc</code> 个区间并返回区间上下界。 <em>从 <a href="https://github.com/deltaeecs/MPIArray4MoMs.jl">MPIArray4MoMs</a> 借的！ 为的是避免提前引入 MPI 导致在集群上的 bug。因此该函数的修改必须与  <a href="https://github.com/deltaeecs/MPIArray4MoMs.jl">MPIArray4MoMs</a> 同步。</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Extends/MPIArray_utlis.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.slicedim2partition-Tuple{Any, Int64}" href="#MoM_Kernels.slicedim2partition-Tuple{Any, Int64}"><code>MoM_Kernels.slicedim2partition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">slicedim2bounds(dims, nc::Int)</code></pre><p>将区间 <code>dims</code> 划分为 <code>nc</code> 个区间并返回区间上下界。 <em>从 <a href="https://github.com/deltaeecs/MPIArray4MoMs.jl">MPIArray4MoMs</a> 借的！ 为的是避免提前引入 MPI 导致在集群上的 bug。因此该函数的修改必须与  <a href="https://github.com/deltaeecs/MPIArray4MoMs.jl">MPIArray4MoMs</a> 同步。</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Extends/MPIArray_utlis.jl#L30-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.solve!-Union{Tuple{T}, Tuple{Union{LinearMaps.LinearMap{T}, MLFMAIterator{T, VT}, AbstractMatrix{T}} where VT, AbstractVector{T}, AbstractVector{T}}} where T&lt;:Number" href="#MoM_Kernels.solve!-Union{Tuple{T}, Tuple{Union{LinearMaps.LinearMap{T}, MLFMAIterator{T, VT}, AbstractMatrix{T}} where VT, AbstractVector{T}, AbstractVector{T}}} where T&lt;:Number"><code>MoM_Kernels.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>矩阵方程 Ax=b 复合求解函数 输入值： A::LinearMapType{T}, b::Vector{T} solverT::Symbol  求解器类型</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Solvers.jl#L81-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.solve-Union{Tuple{T}, Tuple{Union{LinearMaps.LinearMap{T}, MLFMAIterator{T, VT}, AbstractMatrix{T}} where VT, AbstractVector{T}}} where T&lt;:Number" href="#MoM_Kernels.solve-Union{Tuple{T}, Tuple{Union{LinearMaps.LinearMap{T}, MLFMAIterator{T, VT}, AbstractMatrix{T}} where VT, AbstractVector{T}}} where T&lt;:Number"><code>MoM_Kernels.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><p>矩阵方程 Ax=b 复合求解函数 输入值： A::LinearMapType{T}, b::Vector{T} solverT::Symbol  求解器类型</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/Solvers.jl#L24-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.sparseApproximateInversePl-Union{Tuple{CT}, Tuple{FT}, Tuple{MoM_Kernels.ZnearChunksStruct{CT}, Any}} where {FT&lt;:Real, CT&lt;:Complex{FT}}" href="#MoM_Kernels.sparseApproximateInversePl-Union{Tuple{CT}, Tuple{FT}, Tuple{MoM_Kernels.ZnearChunksStruct{CT}, Any}} where {FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.sparseApproximateInversePl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sparseApproximateInversePl(ZnearChunks::ZnearChunksStruct{CT}, level; nbf = 0) where {FT&lt;:Real, CT&lt;:Complex{FT}}</code></pre><p>根据块状近场阻抗矩阵 <code>ZnearChunks</code> 和计算阻抗矩阵层的盒子信息 <code>cubes</code> 计算左稀疏近似逆 (Sparse Approximate Inverse (SAI)) 。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Precondition/SAIChunks.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.sparseApproximateInversePl-Union{Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, AbstractVector}} where {FT&lt;:Real, CT&lt;:Complex{FT}}" href="#MoM_Kernels.sparseApproximateInversePl-Union{Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, AbstractVector}} where {FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.sparseApproximateInversePl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sparseApproximateInversePl(Znear::ZnearT{CT}, cubes::AbstractVector) where {FT&lt;:Real, CT&lt;:Complex{FT}}</code></pre><p>根据近场阻抗矩阵 <code>Znear</code> 和计算阻抗矩阵层的盒子信息 <code>cubes</code> 计算左稀疏近似逆 (Sparse Approximate Inverse (SAI)) 。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Precondition/SAI.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.sparseApproximateInversePl-Union{Tuple{LT}, Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, MoM_Kernels.OctreeInfo{FT, LT}}} where {FT&lt;:Real, CT&lt;:Complex{FT}, LT}" href="#MoM_Kernels.sparseApproximateInversePl-Union{Tuple{LT}, Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, MoM_Kernels.OctreeInfo{FT, LT}}} where {FT&lt;:Real, CT&lt;:Complex{FT}, LT}"><code>MoM_Kernels.sparseApproximateInversePl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sparseApproximateInversePl(Znear::ZnearT{CT}, octree::OctreeInfo{FT, LT}) where { FT&lt;:Real, CT&lt;:Complex{FT}, LT}</code></pre><p>根据近场阻抗矩阵 <code>Znear</code> 和八叉树 <code>octree</code> 叶层计算左稀疏近似逆 (Sparse Approximate Inverse (SAI)) 。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Precondition/SAI.jl#L254-L258">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.sparseApproximateInversePl-Union{Tuple{LT}, Tuple{CT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, LT}} where {CT&lt;:Complex, LT&lt;:MoM_Kernels.AbstractLevel}" href="#MoM_Kernels.sparseApproximateInversePl-Union{Tuple{LT}, Tuple{CT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, LT}} where {CT&lt;:Complex, LT&lt;:MoM_Kernels.AbstractLevel}"><code>MoM_Kernels.sparseApproximateInversePl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sparseApproximateInversePl(Znear::ZnearT{CT}, level::LT) where { CT&lt;:Complex, LT &lt;: AbstractLevel}</code></pre><p>根据近场阻抗矩阵 <code>Znear</code> 和计算阻抗矩阵层信息 <code>level</code> 计算左稀疏近似逆 (Sparse Approximate Inverse (SAI)) 。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Precondition/SAI.jl#L234-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.sparseApproximateInversePr-Union{Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, AbstractVector}} where {FT&lt;:Real, CT&lt;:Complex{FT}}" href="#MoM_Kernels.sparseApproximateInversePr-Union{Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, AbstractVector}} where {FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.sparseApproximateInversePr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sparseApproximateInversePr(Znear::ZnearT{CT}, cubes::AbstractVector) where {FT&lt;:Real, CT&lt;:Complex{FT}}</code></pre><p>根据近场阻抗矩阵 <code>Znear</code> 和计算阻抗矩阵层的盒子信息 <code>cubes</code> 计算右稀疏近似逆 (Sparse Approximate Inverse (SAI)) 。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Precondition/SAI.jl#L135-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.sparseApproximateInversePr-Union{Tuple{LT}, Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, MoM_Kernels.OctreeInfo{FT, LT}}} where {FT&lt;:Real, CT&lt;:Complex{FT}, LT}" href="#MoM_Kernels.sparseApproximateInversePr-Union{Tuple{LT}, Tuple{CT}, Tuple{FT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, MoM_Kernels.OctreeInfo{FT, LT}}} where {FT&lt;:Real, CT&lt;:Complex{FT}, LT}"><code>MoM_Kernels.sparseApproximateInversePr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sparseApproximateInversePr(Znear::ZnearT{CT}, octree::OctreeInfo{FT, LT}) where { FT&lt;:Real, CT&lt;:Complex{FT}, LT}</code></pre><p>根据近场阻抗矩阵 <code>Znear</code> 和八叉树 <code>octree</code> 叶层计算右稀疏近似逆 (Sparse Approximate Inverse (SAI)) 。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Precondition/SAI.jl#L266-L270">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.sparseApproximateInversePr-Union{Tuple{LT}, Tuple{CT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, LT}} where {CT&lt;:Complex, LT&lt;:MoM_Kernels.AbstractLevel}" href="#MoM_Kernels.sparseApproximateInversePr-Union{Tuple{LT}, Tuple{CT}, Tuple{Union{LinearAlgebra.Transpose{CT, SparseArrays.SparseMatrixCSC{CT, Int64}}, SparseArrays.SparseMatrixCSC{CT, Int64}}, LT}} where {CT&lt;:Complex, LT&lt;:MoM_Kernels.AbstractLevel}"><code>MoM_Kernels.sparseApproximateInversePr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sparseApproximateInversePr(Znear::ZnearT{CT}, level::LT) where { CT&lt;:Complex, LT &lt;: AbstractLevel}</code></pre><p>根据近场阻抗矩阵 <code>Znear</code> 和计算阻抗矩阵层信息 <code>level</code> 计算右稀疏近似逆 (Sparse Approximate Inverse (SAI)) 。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Precondition/SAI.jl#L244-L248">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.spherical_h1l-Tuple{Integer, Real}" href="#MoM_Kernels.spherical_h1l-Tuple{Integer, Real}"><code>MoM_Kernels.spherical_h1l</code></a> — <span class="docstring-category">Method</span></header><section><div><p>第一类球汉克尔函数，使用GSL.jl(GNU Scientific Library)，适用于 l 为整数，x 为浮点数时算的更快</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/PhaseShiftAndTransFactors.jl#L68-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.spherical_h1l-Union{Tuple{T}, Tuple{Any, T}} where T" href="#MoM_Kernels.spherical_h1l-Union{Tuple{T}, Tuple{Any, T}} where T"><code>MoM_Kernels.spherical_h1l</code></a> — <span class="docstring-category">Method</span></header><section><div><p>第一类球汉克尔函数，使用 SpecialFunctions.jl， 适用于非整数阶、复数变量，算的较慢，只在计算有耗介质（复数波矢）时调用</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/PhaseShiftAndTransFactors.jl#L60-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.spherical_h1l_array-Union{Tuple{T}, Tuple{Any, T}} where T" href="#MoM_Kernels.spherical_h1l_array-Union{Tuple{T}, Tuple{Any, T}} where T"><code>MoM_Kernels.spherical_h1l_array</code></a> — <span class="docstring-category">Method</span></header><section><div><p>一次计算 0:lmax 的多阶第一类球汉克尔函数， 保存在数组里</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/PhaseShiftAndTransFactors.jl#L73-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.spherical_h1l_array-Union{Tuple{T}, Tuple{Integer, T}} where T&lt;:Real" href="#MoM_Kernels.spherical_h1l_array-Union{Tuple{T}, Tuple{Integer, T}} where T&lt;:Real"><code>MoM_Kernels.spherical_h1l_array</code></a> — <span class="docstring-category">Method</span></header><section><div><p>一次计算 0:lmax 的多阶第一类球汉克尔函数， 保存在数组里</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/PhaseShiftAndTransFactors.jl#L78-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.spherical_h2l-Tuple{Integer, Real}" href="#MoM_Kernels.spherical_h2l-Tuple{Integer, Real}"><code>MoM_Kernels.spherical_h2l</code></a> — <span class="docstring-category">Method</span></header><section><div><p>第二类球汉克尔函数，使用GSL.jl(GNU Scientific Library)，，适用于 l 为整数，x 为浮点数时算的更快</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/PhaseShiftAndTransFactors.jl#L92-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.spherical_h2l-Union{Tuple{T}, Tuple{Any, T}} where T" href="#MoM_Kernels.spherical_h2l-Union{Tuple{T}, Tuple{Any, T}} where T"><code>MoM_Kernels.spherical_h2l</code></a> — <span class="docstring-category">Method</span></header><section><div><p>第二类球汉克尔函数，使用 SpecialFunctions.jl， 适用于非整数阶、复数变量，算的较慢，只在计算有耗介质（复数波矢）时调用</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/PhaseShiftAndTransFactors.jl#L84-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.spherical_h2l_array-Union{Tuple{T}, Tuple{Any, T}} where T" href="#MoM_Kernels.spherical_h2l_array-Union{Tuple{T}, Tuple{Any, T}} where T"><code>MoM_Kernels.spherical_h2l_array</code></a> — <span class="docstring-category">Method</span></header><section><div><p>一次计算 0:lmax 的多阶第二类球汉克尔函数， 保存在数组里</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/PhaseShiftAndTransFactors.jl#L97-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.spherical_h2l_array-Union{Tuple{T}, Tuple{Integer, T}} where T&lt;:Real" href="#MoM_Kernels.spherical_h2l_array-Union{Tuple{T}, Tuple{Integer, T}} where T&lt;:Real"><code>MoM_Kernels.spherical_h2l_array</code></a> — <span class="docstring-category">Method</span></header><section><div><p>一次计算 0:lmax 的多阶第二类球汉克尔函数， 保存在数组里</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/PhaseShiftAndTransFactors.jl#L103-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.transOnLevel!-Tuple{Any}" href="#MoM_Kernels.transOnLevel!-Tuple{Any}"><code>MoM_Kernels.transOnLevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>层内转移</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/IterateOnOctree.jl#L224-L226">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.transOnLevels!-Tuple{Any, Any}" href="#MoM_Kernels.transOnLevels!-Tuple{Any, Any}"><code>MoM_Kernels.transOnLevels!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>各层内转移</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/IterateOnOctree.jl#L279-L281">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.truncationLCal-Tuple{FT} where FT&lt;:Real" href="#MoM_Kernels.truncationLCal-Tuple{FT} where FT&lt;:Real"><code>MoM_Kernels.truncationLCal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>该函数计算八叉树各层截断项数 输入为本层最小盒子的边长</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/IntegralInterpolationInfo.jl#L3-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.truncationLCal-Tuple{}" href="#MoM_Kernels.truncationLCal-Tuple{}"><code>MoM_Kernels.truncationLCal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">truncationLCal(;rel_l) where {FT&lt;:Real}</code></pre><p>该函数计算八叉树各层截断项数 输入为相对波长</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/IntegralInterpolationInfo.jl#L11-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.use_CSR-Tuple{}" href="#MoM_Kernels.use_CSR-Tuple{}"><code>MoM_Kernels.use_CSR</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">use_CSR()
use_CSC()</code></pre><p>设置近场阻抗矩阵是否采用CSR（CSC转置）。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/MLFMAParams.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.volumeSingularityIg-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}" href="#MoM_Kernels.volumeSingularityIg-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, HexahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.volumeSingularityIg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">volumeSingularityIg(rtveclc::AbstractVector{FT}, volumeCell::HexahedraInfo{IT, FT, CT}) where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}</code></pre><p>计算场点<code>rgt</code>在体网格<code>volumeCell</code>上的奇异性。 计算结果为：</p><p class="math-container">\[\begin{aligned}
I_{gV}  &amp;= \int{g(R)dV&#39;}\\
        &amp;= -\sum_{S_i}{d_i\sum_{n}^{SglrOrder}{\frac{coeffgreen(n)}{n+2}I_{RS}^{n-1}}}\\
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/Singularity/VolumeSingularity.jl#L299-L310">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.volumeSingularityIgIvecg-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}" href="#MoM_Kernels.volumeSingularityIgIvecg-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.volumeSingularityIgIvecg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">volumeSingularityIgIvecg(rtveclc::AbstractVector{FT}, volumeCell::TetrahedraInfo{IT, FT, CT}) where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}
volumeSingularityIgIvecg(rtveclc::AbstractVector{FT}, volumeCell::HexahedraInfo{IT, FT, CT}) where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}</code></pre><p>计算场点<code>rgt</code>在体网格<code>volumeCell</code>上的奇异性。 计算结果为：</p><p class="math-container">\[\begin{aligned}
I_{gV}  &amp;= \int{g(R)dV&#39;}\\
        &amp;= -\sum_{S_i}{d_i\sum_{n}^{SglrOrder}{\frac{coeffgreen(n)}{n+2}I_{RS}^{n-1}}}\\
\boldsymbol{I}_{gV}  &amp;= \int{\boldsymbol{R}g(R)dV&#39;}\\
        &amp;= -\sum_{S_i}{\hat{\bm{n}}_i \sum_{n=0}^{SglrOrder}{\frac{coeffgreen(n)}{n+1}I^{n+1}_{RS}}}\\
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/Singularity/VolumeSingularity.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.volumeSingularityLOpDyad-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}" href="#MoM_Kernels.volumeSingularityLOpDyad-Union{Tuple{CT}, Tuple{FT}, Tuple{IT}, Tuple{AbstractVector{FT}, TetrahedraInfo{IT, FT, CT}}} where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}"><code>MoM_Kernels.volumeSingularityLOpDyad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">volumeSingularityLOpDyad(rtveclc::AbstractVector{FT}, volumeCell::TetrahedraInfo{IT, FT, CT}) where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}
volumeSingularityLOpDyad(rtveclc::AbstractVector{FT}, volumeCell::HexahedraInfo{IT, FT, CT}) where {IT&lt;:Integer, FT&lt;:Real, CT&lt;:Complex{FT}}</code></pre><p>计算场点<code>rtveclc</code>在体网格<code>volumeCell</code>上的并矢格林函数奇异性。 计算结果为：</p><p class="math-container">\[\begin{aligned}
\overline{I}_{V}  &amp;= \int{(k^2 I + ∇∇)G(R) dV&#39;}
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/ZmatAndVvec/Singularity/VolumeSingularity.jl#L442-L453">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MoM_Kernels.writeZtt!-Union{Tuple{GT}, Tuple{T}, Tuple{Any, Any, T, GT, Bool}} where {T&lt;:Number, GT&lt;:VolumeCellType}" href="#MoM_Kernels.writeZtt!-Union{Tuple{GT}, Tuple{T}, Tuple{Any, Any, T, GT, Bool}} where {T&lt;:Number, GT&lt;:VolumeCellType}"><code>MoM_Kernels.writeZtt!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>为适应类型变化而将写入部分单独封装</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/deltaeecs/MoM_Kernels.jl/blob/e8adb0d8f46143f227fbd1ba2e8d92cd30ba94a2/src/MLFMA/Znear/ZnearEFIE.jl#L1172-L1174">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Thursday 2 May 2024 17:44">Thursday 2 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
